<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Mozziehh.github.io</id>
    <title>mozzie</title>
    <updated>2020-03-02T05:11:42.291Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Mozziehh.github.io"/>
    <link rel="self" href="https://Mozziehh.github.io/atom.xml"/>
    <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
    <logo>https://Mozziehh.github.io/images/avatar.png</logo>
    <icon>https://Mozziehh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, mozzie</rights>
    <entry>
        <title type="html"><![CDATA[Gradle与插件的升级-5.4.1排坑之旅]]></title>
        <id>https://Mozziehh.github.io/post/gradle-yu-cha-jian-de-sheng-ji-541-pai-keng-zhi-lu/</id>
        <link href="https://Mozziehh.github.io/post/gradle-yu-cha-jian-de-sheng-ji-541-pai-keng-zhi-lu/">
        </link>
        <updated>2020-02-11T02:18:18.000Z</updated>
        <summary type="html"><![CDATA[<p>2020年来了，一年一度的升级活动又要如期展开了，项目里面的老东西也该改进改进了。随着项目越来越大，编译时间成为了我们的瓶颈，虽然改变工程结构等方式能够提升编译速度，但是升级Gradle其实是不二法门。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2020年来了，一年一度的升级活动又要如期展开了，项目里面的老东西也该改进改进了。随着项目越来越大，编译时间成为了我们的瓶颈，虽然改变工程结构等方式能够提升编译速度，但是升级Gradle其实是不二法门。</p>
<!-- more -->
<p>目前项目的状态：<br>
android studio : 3.4.2<br>
gradle : 4.10.1<br>
gradle插件：3.3.1<br>
首次执行编译时间（执行命令-&gt; ./gradlew assembleDebug）：9m 17s<br>
第二次执行编译时间： 6m 18s</p>
<p>以下是来自官网的数据：<br>
插件版本              所需的 Gradle 版本<br>
1.0.0 - 1.1.3        2.2.1 - 2.3<br>
1.2.0 - 1.3.1        2.2.1 - 2.9<br>
1.5.0                2.2.1 - 2.13<br>
2.0.0 - 2.1.2        2.10 - 2.13<br>
2.1.3 - 2.2.3        2.14.1+<br>
2.3.0+               3.3+<br>
3.0.0+               4.1+<br>
3.1.0+               4.4+<br>
3.2.0 - 3.2.1        4.6+<br>
3.3.0 - 3.3.2        4.10.1+<br>
3.4.0 - 3.4.1        5.1.1+<br>
3.5.0+               5.4.1-5.6.4</p>
<p>预计更新为：<br>
android studio : 3.5.0（必须）<br>
gradle : 5.4.1<br>
gradle插件：3.5.3<br>
SDK Build Tools： 28.0.3 +</p>
<p>#影响范围<br>
根据下文的初步调研，这里给出影响范围，以备参考：<br>
##整体升级计划</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>是否影响到安居客</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android Studio</td>
<td>升级到3.5</td>
<td>系统运行状况、功能完善和错误修复，参考《Android Studio升级表》</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Gradle</td>
<td>升级5.4.1</td>
<td>优化语法，使用R8提升编译速度，参考《Gradle升级表》</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Gradle 插件</td>
<td>升级3.5.3</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>SDK Build Tools</td>
<td>28.0.3 +</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>JDK</td>
<td>1.8</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Kotlin Gradle 插件</td>
<td>1.3.40</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
</tbody>
</table>
<p>##Android Studio升级表</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>增量注释</td>
<td>数据绑定注释处理器支持增量注释处理</td>
<td>提高了增量构建的性能</td>
<td>暂时用不到</td>
</tr>
<tr>
<td>单元测试</td>
<td>可缓存的单元测试</td>
<td>提效</td>
<td>暂时用不到</td>
</tr>
<tr>
<td>推荐内存设置</td>
<td>手动分配RAM上限</td>
<td>提高性能</td>
<td>开发者根据需要自己设置</td>
</tr>
<tr>
<td>内存使用情况报告</td>
<td>提交内存使用报告</td>
<td>供goolge完成内存分析</td>
<td>开发者根据需要自己设置</td>
</tr>
<tr>
<td>Windows：防病毒文件 I/O 优化</td>
<td>防病毒检测</td>
<td>防止病毒侵害</td>
<td>无win，不用</td>
</tr>
<tr>
<td>Apply Changes</td>
<td>将代码和资源更改推送给正在运行的应用</td>
<td>无需重复构建</td>
<td>需要运行在Android 8.0及更高</td>
</tr>
<tr>
<td>Layout Editor</td>
<td>对布局可视化、管理和互动功能</td>
<td>ConstraintLayout构建布局时会更方便</td>
<td>升级即可使用</td>
</tr>
<tr>
<td>NDK 并排版本</td>
<td>同一计算机上可以使用不同版本的 NDK，甚至可以指定项目中每个模块应使用的 NDK 版本</td>
<td>并行构建</td>
<td>开发者可用</td>
</tr>
</tbody>
</table>
<p>##Gradle升级表</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>是否影响到安居客</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认标签</td>
<td>不再需要enableFeaturePreview('IMPROVED_POM_SUPPORT')和enableFeaturePreview('STABLE_PUBLISHING')标志</td>
<td>自动配置</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>Java 9 &amp; JAXB</td>
<td>默认捆绑</td>
<td>自动配置</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>语法修改</td>
<td>publishing {}不支持延时操作</td>
<td>使用afterEvaluate {}</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>Java库分发插件</td>
<td>基于Java库插件而不是Java插件</td>
<td>使其行为略有不同</td>
<td>是，若有，则请确保在升级后检查内部版本是否符合预期</td>
</tr>
<tr>
<td>Java库分发插件</td>
<td>基于Java库插件而不是Java插件</td>
<td>使其行为略有不同</td>
<td>是，若有，则请确保在升级后检查内部版本是否符合预期</td>
</tr>
<tr>
<td>属性修改</td>
<td>CheckstyleReport和FindBugsReport的html属性现在返回一个CustomizableHtmlReport实例</td>
<td>更易于从静态类型的语言（如Java和Kotlin）进行配置</td>
<td>是，若有，则请确保在升级后检查是否符合预期</td>
</tr>
<tr>
<td>语法修改</td>
<td>&lt;&lt;对于任务定义不再有效</td>
<td>不能使用语法task myTask &lt;&lt; { … } ，改用Task.doLast（）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>域对象名称使用规范</td>
<td>不能使用<space> / \ : &lt; &gt; &quot; ? * .作为项目和任务名称，也不能将.用作开头或结尾字符</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-Dtest.single</td>
<td>命令行删除，使用test filtering替代</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-Dtest.debug</td>
<td>命令行删除，使用--debug-jvm替代</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-u / --no-search-upward</td>
<td>命令行删除，使用settings.gradle文件</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>--recompile-scripts</td>
<td>命令行删除</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>DirectoryBuildCache.setTargetSizeInMB(long)方法已被删除</td>
<td>改成DirectoryBuildCache.removeUnusedEntriesAfterDays</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>.org.gradle.readLoggingConfigFile系统属性不再执行任何操作</td>
<td>使用java.util.logging设置</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>不再可以使用as关键字或asType()方法将FileCollection对象转换为其他类型</td>
<td>无</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>不能再传递null作为CopySpec.from（Object，Action）的配置</td>
<td>无</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>CopySpec.duplicatesStrategy不再可以为空</td>
<td>默认值的方法. 请改用DuplicatesStrategy.INHERIT</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>FileCollection.stopExecutionIfEmpty()方法已被删除</td>
<td>在FileCollection任务属性上使用@SkipWhenEmpty批注</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>FileCollection.add()方法已删除</td>
<td>使用Project.files（）和Project.fileTree（）创建可配置的文件集合/文件树，并通过ConfigurableFileCollection.from（）将其添加到它们</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>SimpleFileCollection已被删除</td>
<td>改为使用Project.files（Object ...）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>无法扩展AbstractFileCollection改用Project.files（）方法</td>
<td>改为使用getBuildDependencies()方法</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>CompileOptions.bootClasspath属性已被删除</td>
<td>请改用CompileOptions.bootstrapClasspath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>无法将-source-path用作通用编译器参数</td>
<td>CompileOptions.sourcepath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>无法将-processorpath用作通用编译器参数</td>
<td>应改用CompileOptions.annotationProcessorPath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>不再自动应用编译类路径上的注释处理器</td>
<td>应改用CompileOptions.annotationProcessorPath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>testClassesDir属性已从&quot; 测试&quot;任务中删除</td>
<td>改用testClassesDirs</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>从JDepend任务和SourceSetOutput中都删除了classesDir属性</td>
<td>改用JDepend.classesDirs和SourceSetOutput.classesDirs属性</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>JavaBasePlugin.configureForSourceSet()方法已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>不可以创建自己的JavaPluginConvention ， ApplicationPluginConvention ， WarPluginConvention ， EarPluginConvention ， BasePluginConvention和ProjectReportsPluginConvention实例</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了以下属性</td>
<td>使用ObjectFactory.property（）创建Property实例</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了内部的@Option和@OptionValues注释</td>
<td>改用公共@Option和@OptionValues</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了Task.deleteAllActions()方法</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了Task.dependsOnTaskDidWork()方法</td>
<td>改用声明的输入和输出</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了TaskInternal的以下属性和方法</td>
<td>重用的实用程序方法或Worker API代替直接执行任务</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Kotlin DSL</td>
<td>Artifact配置访问器现在具有NamedDomainObjectProvider<Configuration>类型，而不是Configuration</td>
<td>请参阅Gradle Kotlin DSL发行说明</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Kotlin DSL</td>
<td>PluginAware.apply<T>(to)重命名为PluginAware.applyTo<T>(target)</td>
<td>请参阅Gradle Kotlin DSL发行说明</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>ConfigurableReport.setDestination(Object)方法已被删除</td>
<td>改用ConfigurableReport.setDestination（File）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>Signature.setFile(File)方法已被删除，只读的Signature.toSignArtifact属性已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>@DeferredConfigurable批注已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>方法isDeferredConfigurable()已从ExtensionSchema中删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>.IdeaPlugin.performPostEvaluationActions()和EclipsePlugin.performPostEvaluationActions()已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>BroadcastingCollectionEventRegister.getAddAction()方法已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>内部的org.gradle.util软件包默认不再导入</td>
<td>显式导入</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>Tooling API不能再使用Gradle 2.6以下的Gradle版本连接到构建</td>
<td>升级到3.0</td>
<td>是，若有，则需要修改，可能也涉及到QA的改动</td>
</tr>
</tbody>
</table>
<!-- more -->
<!-- more -->
<p>接下来，开撸：</p>
<p>#升级Android Studio</p>
<p>首先，要升级一下Android Studio：Android Studio -&gt; check for updates...<br>
点击之后就会出现让你升级的按钮，耐心的等一会：<br>
<img src="https://Mozziehh.github.io/post-images/1581424536552.png" alt="" loading="lazy"></p>
<p>升级的过程中会报错，如果不继续就无法继续升级，好吧：<br>
<img src="https://Mozziehh.github.io/post-images/1581424635886.png" alt="" loading="lazy"></p>
<p>升级完成之后效果：<br>
<img src="https://Mozziehh.github.io/post-images/1581424849282.png" alt="" loading="lazy"></p>
<!-- more -->
<p>重启之后就是漫长的等待，没事，它等待它的，我们看看这Android Studio 3.5都干了啥：</p>
<p>Android Gradle 插件 3.5.0 和 Android Studio 3.5 是一个重大版本，同时也是 Project Marble 计划的成果，该计划主要围绕 Android 开发者工具的三大核心领域进行改进，分别是系统运行状况、功能完善和错误修复。值得注意的是，本次更新的重中之重是提高项目的构建速度。</p>
<p>要详细了解这些更新以及其他 Project Marble 更新，请参阅 Android 开发者博文或以下几个部分的内容。</p>
<p>此版本的 Android 插件需要使用以下工具：</p>
<p>Gradle 5.4.1 或更高版本。要了解详情，请阅读有关更新 Gradle 的部分。</p>
<p>3.5.3（2019 年 12 月）<br>
本次要更新对 Android Studio 3.5.3 构成补充，修复了各种错误并做出了多项性能改进。<br>
3.5.2（2019 年 11 月）<br>
本次要更新对 Android Studio 3.5.2 构成补充，修复了各种错误并做出了多项性能改进。要查看重要问题修复列表，请阅读版本更新博客上的相关博文。<br>
3.5.1（2019 年 10 月）<br>
本次要更新对 Android Studio 3.5.1 构成补充，修复了各种错误并做出了多项性能改进。要查看重要问题修复列表，请阅读版本更新博客上的相关博文。</p>
<p>##增量注释处理<br>
如果您在 gradle.properties 文件中设置了 android.databinding.incremental=true，数据绑定注释处理器支持增量注释处理。这项优化提高了增量构建的性能。要查看经过优化的注释处理器的完整列表，请参阅增量注释处理器表格。</p>
<p>此外，KAPT 1.3.30 及更高版本也支持增量注释处理器，您可以通过在 gradle.properties 文件中添加 kapt.incremental.apt=true 来启用此支持。</p>
<p>##可缓存的单元测试<br>
通过将 includeAndroidResources 设置为 true，您可以允许单元测试使用 Android 资源、资产和清单，此时 Android Gradle 插件会生成包含绝对路径的测试配置文件，绝对路径会打破缓存可再定位性。您可以指示插件使用相对路径生成测试配置，以便通过在 gradle.properties 文件中添加以下内容来完全缓存 AndroidUnitTest 任务：<br>
android.testConfig.useRelativePath = true</p>
<p>##已知问题<br>
在使用 Kotlin Gradle 插件 1.3.31 或更早版本时，您可能会在构建或同步项目时看到以下警告：</p>
<p>WARNING: API 'variant.getPackageLibrary()' is obsolete and has been replaced<br>
with 'variant.getPackageLibraryProvider()'.</p>
<p>要解决此问题，请将插件升级到 1.3.40 或更高版本。</p>
<p>##推荐内存设置</p>
<p>现在，如果 Android Studio 检测到您可以通过增加操作系统应该为 Android Studio 进程（例如核心 IDE、Gradle 守护进程和 Kotlin 守护进程）分配的 RAM 上限来提高性能，它会通知您。您可以通过点击通知中的操作链接来接受推荐设置，或者，您可以通过以下方式手动调整这些设置：依次选择 File &gt; Settings（或者，在 macOS 上依次选择 Android Studio &gt; Preferences），然后在 Appearance &amp; Behavior &gt; System Settings 下找到 Memory Settings 部分。<br>
<img src="https://Mozziehh.github.io/post-images/1581425138056.png" alt="" loading="lazy"></p>
<p>##内存使用情况报告<br>
Android Studio 中的内存问题有时难以重现和报告。为了解决此问题，您可以在 Android Studio 中从菜单栏依次点击 Help &gt; Analyze Memory Usage，生成内存使用情况报告。执行此操作后，Android Studio 会在本地清理掉数据中的个人信息，然后询问您是否希望将数据发送给 Android Studio 团队以帮助识别内存问题的来源。<br>
PS：不过这个功能对开发而言好像没啥用。</p>
<p>##Windows：防病毒文件 I/O 优化<br>
Android Studio 现在会自动检查某些项目目录是否已从实时防病毒扫描中排除。当能够进行调整以提高构建性能时，Android Studio 会通知您并提供有关如何优化防病毒配置的说明。<br>
PS：Mac表示没有此类困扰</p>
<p>##Apply Changes：<br>
借助 Apply Changes，您可以将代码和资源更改推送给正在运行的应用，而无需重启应用（在某些情况下，甚至无需重启当前的 Activity）。Apply Changes 实现了一种全新的方法来保持应用的状态。与重写 APK 字节码的 Instant Run 不同，Apply Changes 会利用 Android 8.0（API 级别 26）或更高版本中支持的运行时插桩，实时地重新定义类。<br>
<img src="https://Mozziehh.github.io/post-images/1581425288637.png" alt="" loading="lazy"></p>
<p>##Layout Editor<br>
Android Studio 3.5 对布局可视化、管理和互动功能进行了多项改进。</p>
<p>使用 ConstraintLayout 时，Attributes 面板中新的 Constraints 部分会列出所选界面组件的约束关系。您可以从设计图面或约束列表中选择一个约束条件，突出显示这两个区域中的约束条件。</p>
<p><img src="https://Mozziehh.github.io/post-images/1581425465223.png" alt="" loading="lazy"><br>
同样，您现在可以选择某个约束条件并按 Delete 键，删除约束条件。您还可以按住 Control 键（在 macOS 上，按住 Command）并点击约束条件定位点来删除约束条件。请注意，当您按住 Control 或 Command 键并将鼠标悬停在定位点上时，任何关联的约束条件都会变成红色，表示您可以点击以将其删除。</p>
<p>选择视图后，您可以点击 Attributes 面板的 Constraint Widget 部分的任何一个 + 图标来创建约束条件，如下图所示。当您创建新的约束条件时，Layout Editor 现在会选择并突出显示该约束条件，为您刚刚添加的约束条件提供即时视觉反馈。<br>
<img src="https://Mozziehh.github.io/post-images/1581425489275.png" alt="" loading="lazy"></p>
<p>##NDK 并排版本<br>
现在，您可以并排使用 NDK 的多个版本。此功能可让您更灵活地配置项目，例如，如果项目在同一计算机上使用了不同版本的 NDK。</p>
<p>如果您的项目使用 Android Gradle 插件 3.5.0 或更高版本，您还可以指定项目中每个模块应使用的 NDK 版本。您可以使用此功能来创建可重现的构建版本，并缓解 NDK 版本与 Android Gradle 插件之间的不兼容性。</p>
<p>##从4.10更新过来的同学看这里<br>
接下来我们来说说，Gradle升级的好处：<br>
如果您尚未使用4.10版本，请跳至适用于当前Gradle版本的部分，然后逐步升级，直至到达此处. 然后，从Gradle 4.10移至5.0时应用这些更改.</p>
<p>1.不再需要enableFeaturePreview('IMPROVED_POM_SUPPORT')和enableFeaturePreview('STABLE_PUBLISHING')标志. 现在默认情况下启用了这些功能.</p>
<p>2.Gradle现在捆绑了Java 9及更高版本的JAXB . 您可以从org.gradle.jvmargs删除--add-modules java.xml.bind选项（如果已设置）.</p>
<p>##其他可能会出现问题的点</p>
<p>1.对publishing {}块的评估不再推迟到需要时才执行，但其行为与其他任何块一样. 如果您需要推迟评估，请使用afterEvaluate {} .</p>
<p>2.Javadoc和Groovydoc任务现在在执行之前删除了文档的目标目录. 已添加它以从上一次任务执行中删除过时的输出文件.</p>
<p>3.Java库分发插件现在基于Java库插件而不是Java插件 .<br>
在应用Java插件时，其行为略有不同（例如，它添加了api配置）. 因此，请确保在升级后检查内部版本是否符合预期.</p>
<p>4.CheckstyleReport和FindBugsReport的html属性现在返回一个CustomizableHtmlReport实例，该实例更易于从静态类型的语言（如Java和Kotlin）进行配置.</p>
<p>5.以下重大更改将在Gradle 4.10中作为弃用警告显示：</p>
<p>##General<br>
&lt;&lt;对于任务定义不再有效. 换句话说，您不能使用语法task myTask &lt;&lt; { … } .<br>
改用Task.doLast（）方法，如下所示：<br>
task myTask {<br>
doLast {<br>
...<br>
}<br>
}<br>
您不能再在域对象名称中使用以下任何字符，例如项目和任务名称：<space> / \ : &lt; &gt; &quot; ? * | .您也不应将.用作开头或结尾字符.</p>
<p>##Running Gradle &amp; build environment<br>
如前所述，Gradle不能再在Java 7上运行.但是，您仍然可以使用派生的编译和测试来构建和测试Java 6及更高版本的软件.</p>
<p>1.The -Dtest.single command-line option has been removed — use test filtering instead.</p>
<p>2.-Dtest.debug命令行选项已删除-使用--debug-jvm选项代替.</p>
<p>3.-u / --no-search-upward命令行选项已被删除-确保所有构建均具有settings.gradle文件.</p>
<p>4.--recompile-scripts命令行选项已删除.</p>
<p>5.除非嵌套的构建具有settings.gradle文件，否则您不能再将Gradle嵌套在另一个Gradle构建的子目录中.</p>
<p>6.DirectoryBuildCache.setTargetSizeInMB(long)方法已被删除-改用DirectoryBuildCache.removeUnusedEntriesAfterDays .</p>
<p>7.org.gradle.readLoggingConfigFile系统属性不再执行任何操作-更新受影响的测试以使用您的java.util.logging设置.</p>
<h2 id="文件操作">文件操作</h2>
<p>1.您不再可以使用as关键字或asType()方法将FileCollection对象转换为其他类型.</p>
<p>2.您不能再传递null作为CopySpec.from（Object，Action）的配置操作.</p>
<p>3.为了与Kotlin DSL更好地兼容， CopySpec.duplicatesStrategy不再可以为空. 属性设置器不再接受null作为将属性重置为其默认值的方法. 请改用DuplicatesStrategy.INHERIT .</p>
<p>4.FileCollection.stopExecutionIfEmpty()方法已被删除-在FileCollection任务属性上使用@SkipWhenEmpty批注.</p>
<p>FileCollection.add()方法已删除-使用Project.files（）和Project.fileTree（）创建可配置的文件集合/文件树，并通过ConfigurableFileCollection.from（）将其添加到它们.</p>
<p>5.SimpleFileCollection已被删除-改为使用Project.files（Object ...） .</p>
<p>6.没有您自己的类扩展AbstractFileCollection改用Project.files（）方法. 此问题可能表现为缺少的getBuildDependencies()方法.</p>
<p>##Java构建<br>
1.CompileOptions.bootClasspath属性已被删除，请改用CompileOptions.bootstrapClasspath .</p>
<p>2.您不能再将-source-path用作通用编译器参数，而应改用CompileOptions.sourcepath .</p>
<p>3.您不能再将-processorpath用作通用编译器参数，而应改用CompileOptions.annotationProcessorPath .</p>
<p>4.Gradle将不再自动应用编译类路径上的注释处理器，而应改用CompileOptions.annotationProcessorPath .</p>
<p>5.testClassesDir属性已从&quot; 测试&quot;任务中删除-改用testClassesDirs .</p>
<p>6.从JDepend任务和SourceSetOutput中都删除了classesDir属性. 请改用JDepend.classesDirs和SourceSetOutput.classesDirs属性.</p>
<p>7.JavaLibrary(PublishArtifact, DependencySet)构造函数— Shadow Plugin使用了该构造函数，因此请确保至少升级到该插件的2.x版本.</p>
<p>8.JavaBasePlugin.configureForSourceSet()方法已被删除.</p>
<p>9.您不再可以创建自己的JavaPluginConvention ， ApplicationPluginConvention ， WarPluginConvention ， EarPluginConvention ， BasePluginConvention和ProjectReportsPluginConvention实例.</p>
<p>10.Maven插件用于发布过时的Maven 2元数据格式. 它已更改，现在将发布Maven 3元数据，就像Maven Publish插件一样.<br>
随着Maven 2支持的删除，配置唯一快照行为的方法也已删除. Maven 3仅支持唯一的快照，因此我们决定删除它们.</p>
<p>##Tasks &amp; properties<br>
1.删除了以下与惰性属性相关的旧类和方法-使用ObjectFactory.property（）创建Property实例：</p>
<p>PropertyState<br>
DirectoryVar<br>
RegularFileVar<br>
ProjectLayout.newDirectoryVar()<br>
ProjectLayout.newFileVar()<br>
Project.property(Class)<br>
Script.property(Class)<br>
ProviderFactory.property(Class)<br>
使用任务配置避免 API配置和注册的任务对可以从配置操作中调用的其他方法有更多限制.</p>
<p>2.内部的@Option和@OptionValues注释（软件包org.gradle.api.internal.tasks.options ）已被删除. 请改用公共@Option和@OptionValues批注.</p>
<p>3.Task.deleteAllActions()方法已被删除，无法替代.</p>
<p>4.Task.dependsOnTaskDidWork()方法已被删除-改用声明的输入和输出 .</p>
<p>5.已删除TaskInternal的以下属性和方法-使用任务依赖项，任务规则，可重用的实用程序方法或Worker API代替直接执行任务.<br>
execute()<br>
executer<br>
getValidators()<br>
addValidator()<br>
TaskInputs.file（Object）方法不能再使用可解析为单个常规文件以外的任何参数的参数来调用.<br>
TaskInputs.dir（Object）方法不能再使用解析为单个目录以外的任何参数的参数来调用.<br>
您不再可以通过TaskInputs和TaskOutputs注册无效的输入和输出.<br>
TaskDestroyables.file()和TaskDestroyables.files()方法已被删除-改用TaskDestroyables.register（） .<br>
SimpleWorkResult已被删除-使用WorkResult.didWork .<br>
现在，覆盖4.8中弃用的内置任务会产生错误.<br>
尝试替换内置任务将产生类似于以下内容的错误：</p>
<blockquote>
<p>Cannot add task 'wrapper' as a task with that name already exists.<br>
Scala &amp; Play<br>
不再支持Play 2.2-请升级您使用的Play版本.<br>
ScalaDocOptions.styleSheet属性已被删除-Scala 2.11.8及更高版本中的Scaladoc Ant任务不再支持此属性.</p>
</blockquote>
<p>##Kotlin DSL<br>
Artifact配置访问器现在具有NamedDomainObjectProvider<Configuration>类型，而不是Configuration<br>
PluginAware.apply<T>(to)重命名为PluginAware.applyTo<T>(target) .<br>
两项更改都可能导致脚本编译错误. 请参阅Gradle Kotlin DSL发行说明，以获取更多信息以及如何修复因上述更改而损坏的构建.</p>
<p>##Miscellaneous<br>
1.ConfigurableReport.setDestination(Object)方法已被删除-改用ConfigurableReport.setDestination（File） .</p>
<p>2.Signature.setFile(File)方法已被删除-Gradle不支持更改生成的签名的输出文件.<br>
只读的Signature.toSignArtifact属性已被删除-永远不应成为公共API的一部分.</p>
<p>3.@DeferredConfigurable批注已被删除.</p>
<p>4.方法isDeferredConfigurable()已从ExtensionSchema中删除.</p>
<p>5.IdeaPlugin.performPostEvaluationActions()和EclipsePlugin.performPostEvaluationActions()已被删除.</p>
<p>6.The `BroadcastingCollectionEventRegister.getAddAction()方法已被删除，无法替代.</p>
<p>7.内部的org.gradle.util软件包默认不再导入.<br>
理想情况下，您不应该使用此程序包中的类，但是，作为一种快速解决方案，您可以将显式导入添加到这些类的构建脚本中.</p>
<p>8.The gradlePluginPortal() repository no longer looks for JARs without a POM by default.</p>
<p>9.Tooling API不能再使用Gradle 2.6以下的Gradle版本连接到构建. 通过TestKit运行的构建也是如此.</p>
<p>10.Gradle 5.0需要最低版本的Tooling API客户端版本3.0. 较旧的客户端库无法再使用Gradle 5.0运行构建.</p>
<p>11.IdeaModule Tooling API模型元素包含用于检索资源和测试资源的方法，因此这些元素已从IdeaModule.getSourceDirs()和IdeaModule.getTestSourceDirs()的结果中删除.<br>
In previous Gradle versions, the source field in SourceTask was accessible from subclasses. This is not the case anymore as the source field is now declared as private.</p>
<p>12.在Worker API中， 不能再设置worker的工作目录 .<br>
与依赖关系和版本约束有关的行为更改可能会影响少量用户.<br>
对DefaultTask上的属性工厂方法进行了一些更改，这些更改可能会影响自定义任务的创建.</p>
<p>#升级Gradle和Gradle插件</p>
<p>升级跟砍传奇一样，只有你升级了之后才之后哪些是报错，哪些不是报错，报错了一个一个解决，都解决完成，升级完成。</p>
<p>##报错一<br>
ERROR: Unable to resolve dependency for ':58WuxianClient@wubaDebug/compileClasspath': Could not resolve com.anjuke.mobile:sign:1.1.2-SNAPSHOT.</p>
<p>##报错二<br>
com.facebook.imagepipeline.image.CloseableAnimatedImage 错误:找不到符号<br>
解决：经排查是因为&quot;com.facebook.fresco:animated-base&quot;这个库找不到导致，在原来的版本上是可以有这一层依赖的。它是在animated-gif下，不过目前看到的是没有的。所以，最后添加了对此库的依赖。</p>
<p>##报错三<br>
transformClassesAndResourcesWithR8ForWubaRelease FAILED<br>
解决：这是R8编译时发生的错误，禁止R8即可；<br>
Disables R8 for Android Library modules only.<br>
android.enableR8.libraries = false<br>
Disables R8 for all modules.<br>
android.enableR8 = false</p>
<p>##报错四<br>
Caused by: com.android.tools.r8.utils.AbortException: Error: null, Cannot fit requested classes in the main-dex file (# methods: 69437 &gt; 65536)<br>
[exec]  at com.android.tools.r8.utils.Reporter.a(:21)<br>
[exec]  at com.android.tools.r8.utils.Reporter.a(:7)<br>
[exec]  at com.android.tools.r8.dex.VirtualFile.a(:33)<br>
[exec]  at com.android.tools.r8.dex.VirtualFile$e.a(:37)<br>
[exec]  at com.android.tools.r8.dex.ApplicationWriter.a(:13)<br>
[exec]  at com.android.tools.r8.dex.ApplicationWriter.write(:35)<br>
[exec]  at com.android.tools.r8.D8.d(:44)<br>
[exec]  at com.android.tools.r8.D8.b(:1)<br>
[exec]  at com.android.tools.r8.utils.t.a(:23)</p>
<p>分析：目前有两种方案，一种是没有配置multidex，一种是java的JDK没有升级1.8</p>
<p>添加了android.enableD8=false之后，发现会报错：<br>
Java 8 language support, as requested by 'android.enableD8.desugaring= true' in your gradle.properties file, is not supported when 'android.enableD8= false'</p>
<p>现在反向思路解决不了问题，咱们就正向解决，让它放在main-dex里面，然后再分析，先保证打包能过去；<br>
去掉了一些文件在主dex之后，继续开启编译之路，但是很快，就遇到了新的问题：</p>
<p>##报错五<br>
com.android.tools.build.apkzlib.zip.compress.Zip64NotSupportedException: Zip64 EOCD locator found but Zip64 format is not supported: /opt/build/temp/74638/beta/android/58WuxianClient/build/intermediates/transforms/proguard/wuba/release/0.jar</p>
<p>从字面意思分析是从配置上支持了使用Zip64打包APK，但是发现我们release下的jar包不支持。那大概有两种思路，一种是让我们的包支持zip64，另外一种是想办法把zip64禁用。</p>
<p>我尝试了本地打包，居然通过了，看的我老泪纵横：<br>
Tasks spend time &gt; 50ms:<br>
04:25.78   :58WuxianClient:multiDexListWubaDebug<br>
04:17.27   :58WuxianClient:transformClassesWithDexBuilderForWubaDebug<br>
02:41.24   :58WuxianClient:javaPreCompileWubaDebug<br>
01:29.50   :58WuxianClient:mergeWubaDebugResources<br>
01:06.02   :58WuxianClient:checkConflictDependencies<br>
00:55.43   :58WuxianClient:mergeDexWubaDebug<br>
00:46.11   :58WuxianClient:processWubaDebugResources<br>
00:30.93   :58WuxianClient:mergeWubaDebugNativeLibs<br>
00:28.55   :58WuxianClient:compileWubaDebugJavaWithJavac<br>
00:24.20   :58WuxianClient:packageWubaDebug<br>
00:21.95   :58WuxianClient:mergeWubaDebugJavaResource<br>
00:19.80   :58WuxianClient:checkWubaDebugDuplicateClasses<br>
00:14.39   :58WuxianClient:stripWubaDebugDebugSymbols<br>
00:12.02   :58WuxianClient:processWubaDebugManifest<br>
00:05.95   :58WuxianClient:transformClassesWithAjxForWubaDebug<br>
00:04.09   :PublishDex:javaPreCompileDebug<br>
00:03.39   :PublishDex:mergeDebugJavaResource<br>
00:03.17   :PublishDex:transformClassesWithDexBuilderForDebug<br>
00:02.84   :PublishDex:mergeExtDexDebug<br>
00:02.67   :58WuxianClient:transformClassesWithCom.alibaba.arouterForWubaDebug<br>
00:02.56   :PublishDex:compileDebugJavaWithJavac<br>
00:02.29   :PublishDex:processDebugResources<br>
00:01.87   :58WuxianClient:mergeWubaDebugAssets<br>
00:01.04   :PublishDex:packageDebug<br>
00:00.68   :PublishDex:processDebugManifest<br>
00:00.63   :PublishDex:mergeDebugResources<br>
00:00.26   :PublishDex:mergeDexDebug<br>
00:00.22   :58WuxianClient:clean<br>
00:00.11   :PublishDex:generateDebugBuildConfig<br>
00:00.10   :PublishDex:checkDebugManifest<br>
00:00.08   :PublishDex:preBuild<br>
00:00.07   :58WuxianClient:mergeWubaDebugShaders<br>
BUILD SUCCESSFUL in 11m 4s<br>
53 actionable tasks: 53 executed<br>
bjdhj-124-7:58ClientProject $</p>
<p>看了一下具体的区别，发现我们是没有构建release的包的过程，本地目前用的是debug，而AVM用的是Release构建，想到这，我发现有一个配置：useProguard true，跟我本地配置是不太一样的。</p>
<p>解决：<br>
查看配置文件，发现我们配置了：android.useDeprecatedNdk=true，所以直接去掉就行了，编译器会自动帮我们做。</p>
<p>##参考链接<br>
https://developer.android.google.cn/studio/releases/gradle-plugin?hl=zh_cn<br>
https://www.jianshu.com/p/13a62e1ac396</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[android开源框架分析系列之-EventBus]]></title>
        <id>https://Mozziehh.github.io/post/eventbuszen-me-jiu-xue-bu-ming-bai-ni/</id>
        <link href="https://Mozziehh.github.io/post/eventbuszen-me-jiu-xue-bu-ming-bai-ni/">
        </link>
        <updated>2020-02-10T14:01:54.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在看开源框架，对于经常使用的EventBus，觉得用起来非常简单，所以比较好奇，看了几篇文章。然后把EventBus的关键点提取到了Anki上，随着时间的推移，突然发现印象越来越模糊，反反复复的看光是看理论印象还是不够深刻。于是，打算深挖一下EventBus的源码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在看开源框架，对于经常使用的EventBus，觉得用起来非常简单，所以比较好奇，看了几篇文章。然后把EventBus的关键点提取到了Anki上，随着时间的推移，突然发现印象越来越模糊，反反复复的看光是看理论印象还是不够深刻。于是，打算深挖一下EventBus的源码。</p>
<!-- more -->
<p>开篇习惯，带着问题看源码，如果你能回答出如下问题，那么，出门右转，不要浪费宝贵的大好青春~<br>
1.简单的描述一个EventBus的使用Demo？<br>
2.EventBus的注册是怎么回事？<br>
3.当我使用PostEvent发送事件之后，EventBus会执行哪些流程？它是如何找到对应的事件的？<br>
4.EventBus的取消注册是怎么回事？<br>
5.简单的说一下粘性事件？</p>
<!-- more -->
<p>#关于EventBus</p>
<p>EventBus的简介，网上有的是，这里不再赘述，你只要知道，它使用的是观察者模式，通过Event来传递。</p>
<p>#带着问题看源码</p>
<p>##简单的描述一个EventBus的使用Demo？</p>
<p>###注册</p>
<pre><code>EventBus.getDefault().register(this)；
</code></pre>
<p>###自定义事件</p>
<pre><code>public class MessageEvent{
    private String message;
    public  MessageEvent(String message){
        this.message=message;
    }
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>
<p>###发送</p>
<pre><code>EventBus.getDefault().post(messageEvent);
</code></pre>
<p>###处理事件</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MAIN)
public void XXX(MessageEvent messageEvent) {
    ...
}
</code></pre>
<p>###取消注册</p>
<pre><code>EventBus.getDefault().unRegister(this)；
</code></pre>
<p>##EventBus的注册是怎么回事？</p>
<p>接下来就带你看看注册的源码是怎么回事，先回忆一下上一节的代码，我们就使用了一句简单的EventBus.getDefault().register(this)；就完成了注册，它主要分为两个部分：getDefault()和register(this)；</p>
<p>那么getDefault是什么呢？<br>
查看源代码得知，原来它就是一个使用了volatile和synchronized双重锁单例：</p>
<pre><code>static volatile EventBus defaultInstance;
public static EventBus getDefault() {
        EventBus instance = defaultInstance;
        if (instance == null) {
            synchronized (EventBus.class) {
                instance = EventBus.defaultInstance;
                if (instance == null) {
                    instance = EventBus.defaultInstance = new EventBus();
                }
            }
        }
        return instance;
}

这里面还有一个小技巧：
/**
 * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
 * central bus, consider {@link #getDefault()}.
 */
public EventBus() {
    this(DEFAULT_BUILDER);
}

public static EventBusBuilder builder() {
    return new EventBusBuilder();
}
发现没，它是在单例的EventBus里面，默认设置了一个EventBusBuilder，通过EventBusBuilder的名字你大概能轻易的猜出来使用了构建者模式，最终返回的这个真正的EventBus。
</code></pre>
<p>在得到单例之后，就进行了注册：</p>
<p>下面就是注册方法：<br>
注册的时候要注意，首先使用注册就一定要使用反注册，否则，你将会一直收到该消息；然后是一定要为处理该消息的方法进行声明，Subscribe也行，或者是再加上ThreadMode和优先级；</p>
<pre><code>    public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>注册主要分为两步：<br>
###获取到注册类的所有的声明了Subscribe注解的事件：<br>
注册的时候，会获取你注册的类对象，然后调用findSubscriberMethods方法，返回List<SubscriberMethod>集合，我们叫做观察者集合（我自己起的名）。<br>
这里面用到了一个METHOD_CACHE，它是一个ConcurrentHashMap，考考你：什么是ConcurrentHashMap？它是如何使用size()方法如何容器大小的？</p>
<pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {

        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);
        //这个地方就是一个设计模式：享元
        if (subscriberMethods != null) {
            return subscriberMethods;
        }

        if (ignoreGeneratedIndex) {
            subscriberMethods = findUsingReflection(subscriberClass);
        } else {
            subscriberMethods = findUsingInfo(subscriberClass);
        }
        if (subscriberMethods.isEmpty()) {
            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
        } else {
            METHOD_CACHE.put(subscriberClass, subscriberMethods);
            return subscriberMethods;
        }
    }
</code></pre>
<p>然后接下来就是findUsingReflection</p>
<p>#参考文章<br>
https://www.jianshu.com/p/f9ae5691e1bb</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python使用规范]]></title>
        <id>https://Mozziehh.github.io/post/python-shi-yong-gui-fan/</id>
        <link href="https://Mozziehh.github.io/post/python-shi-yong-gui-fan/">
        </link>
        <updated>2020-01-07T06:10:45.000Z</updated>
        <content type="html"><![CDATA[<p>最近一直在写python脚本，马上开源了，发现里面有很多不规范的使用方法，在这里特别记录：</p>
<p>##编码</p>
<ul>
<li>统一使用 UTF-8 编码；</li>
<li>导入的包在代码的最前面；</li>
<li>每行代码不宜过长，不要超过120字符；</li>
<li>使用面向对象思想编程，按照功能划分类，按照职责划分方法；</li>
</ul>
<p>##关于注释</p>
<ul>
<li>单行文档注释可以使用#标注；</li>
<li>多行可以使用三个双引号&quot;&quot;&quot;...&quot;&quot;&quot;；</li>
<li>关键方法要使用注释，方便维护；</li>
</ul>
<p>##类和方法</p>
<ul>
<li>对于一个类，里面有多个方法可以使用_init_()方法来初始化变量，以便该类中各个方法使用；假如接入该类只有一个方法，那么可以忽略_init()方法，直接自定义方法;</li>
<li>方法之间可以不空行，类与类之间要空行；</li>
<li>类的名字使用驼峰命名法，首字母大写；</li>
<li>所有方法，全部使用小写；</li>
<li>私有方法，使用_下划线开头；</li>
<li>常量使用大写；</li>
<li>每个语句执行完可以不加&quot;;&quot;，但是要注意使用换行</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开源框架分析系列之-Fresco]]></title>
        <id>https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco/</id>
        <link href="https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco/">
        </link>
        <updated>2019-12-14T02:43:38.000Z</updated>
        <content type="html"><![CDATA[<p>##为什么选择Fresco<br>
1、它是Facebook出品的开源库，避免重复造轮子；</p>
<p>2、Fresco 支持 Android2.3(API level 9) 及其以上系统,基本上可以含盖目前市场上的绝大部分android手机，我们目前的支持的最低版本android 4.0(API level 14);</p>
<p>3、在5.0以下系统，Fresco将图片放到一个特别的内存共享区域（ashmem）。在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
<p>4、使用简单，一行代码setImageURI()就可以加载图片和显示；</p>
<p>5、支持三级缓存，Bitmap缓存、未解码图片缓存、文件缓存；</p>
<p>6、对okHttp和volley网络库的兼容，目前我们项目中使用的是volley网络库，可以灵活配置；</p>
<p>7、支持的图片格式有jpg/jpeg、png、jpeg图片的渐进式呈现、gif、webP；</p>
<p>##带着问题看文章<br>
按照国际惯例，请先阅读如下题目，如果你会了，那么就可以关闭文章了：</p>
<p>1、Fresco和Glide的对比？（大小、加载生命周期、图片格式、旋转裁减、缓存方式）</p>
<p>2、DraweeView中成员变量DraweeHolder与DraweeHierarchy与DraweeController三者之间的关系？</p>
<p>3、当view被从ViewGroup临时分离时回调，执行了Fresco的哪个方法？</p>
<p>4、Fresco加载图片的几种方式？（Center.CENTER_INSIDE、Fit.CENTER等）</p>
<p>5、Fresco在管理ashmem区域采用了哪种方式回收内存？</p>
<p>6、Fresco在加载图片时，为了缓解OOM除了采用ashmem，还有什么策略？采样的策略是如何做的？</p>
<p>7、Fresco内部使用LRU算法维护图片池，那么对于那些不经常变动但是需要常驻的图片，Fresco可以怎么处理？</p>
<p>8、Fresco内部是如何获取本地缓存路径的？<br>
##它和Glide的对比<br>
###包大小&amp;复杂度<br>
fresco的包比较复杂，因此Facebook将其拆分成几个不同的aar库，可根据需要分别加载依赖，大小3M左右。</p>
<p>glide包还好，除okhttp拆分出单独的aar包外，其他功能均在一个aar包中。glide拆分出了单独的图片处理库，可以支持对图片的裁剪，旋转，模糊和滤镜等操作，大小300KB左右。</p>
<p>###影响一次图片加载过程的生命周期对象（即一次图片加载受谁的生命周期控制影响）<br>
fresco：图片的加载受view生命周期的影响</p>
<p>glide：图片的加载受context的生命周期影响，context可以是fragment、activity、application。</p>
<p>###支持的图片格式<br>
fresco：png、jpeg、webp、gif、jfif；<br>
glide：png、jpeg、webp、gif。</p>
<p>###支持图片的旋转和裁剪<br>
fresco和glide均支持图片的旋转和裁剪。</p>
<p>fresco：</p>
<p>图片旋转：</p>
<p>imageRequestBuilder.setRotationOptions(RotationOptions.forceRotation(RotationOptions.ROTATE_90));</p>
<p>图片的裁剪：</p>
<p>imageRequestBuilder.setResizeOptions(new ResizeOptions(reqWidth, reqHeight));</p>
<p>glide：</p>
<p>图片的旋转：</p>
<p>创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new RotateTransformation( context, 90f )).into( imageView);</p>
<p>图片的裁剪：</p>
<p>a、直接使用override(imageWidth, imageWidth)方法，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).override(imageWidth, imageWidth).into( imageView);</p>
<p>b、创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new ResizeTransformation( context, width,height )).into( imageView);</p>
<h3 id="缓存方式">缓存方式</h3>
<p>fresco：三级缓存：二级内存缓存 + 磁盘文件缓存，只有第一级内存缓存在UI线程中操作，其他均在io线程中</p>
<p>fresco二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、png、jpeg等格式的文件缓存，需要解码成bitmap对象。</p>
<p>glide：二级内存缓存（严格意义上来说只有一级，第二级可以忽略）加磁盘文件缓存，内存缓存均在UI线程中，磁盘缓存在io线程中操作。</p>
<p>glide二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、WeakReference(bitmap)缓存，即弱引用bitmap对象缓存。</p>
<h3 id="代码侵入式">代码侵入式</h3>
<p>fresco在使用的时候基本都要引入其封装的DraweeView，代码侵入性很强。glide代码侵入性相比不强。</p>
<p>##Fresco架构<br>
<img src="https://Mozziehh.github.io/post-images/1576291547391.png" alt="" loading="lazy"></p>
<p>DraweeView中成员变量DraweeHolder主要用于控制逻辑层，DraweeHolder包含DraweeHierarchy和DraweeController，DraweeHierarchy用于存储图像，DraweeController用于控制显示图像，为什么把DraweeHierarchy和DraweeController封装到DraweeHolder 中呢？是为了解藕，通过DraweeHolder可以方便的使用这两个组件。DraweeView 把获得的 Event 转发给 Controller，然后 Controller 根据 Event 来决定是否需要显示和隐藏 （包括动画）图像，而这些图像都存储在 Hierarchy 中，最后 DraweeView 绘制时直接通过 getTopLevelDrawable 就可以获取需要显示的图像。</p>
<p>##Fresco核心显示处理<br>
看一下DraweeView重写了View的四个方法：<br>
@Override<br>
protected void onAttachedToWindow() {<br>
super.onAttachedToWindow();<br>
mDraweeHolder.onAttach();<br>
}</p>
<pre><code>@Override
protected void onDetachedFromWindow() {
super.onDetachedFromWindow();
mDraweeHolder.onDetach();
}

@Override
public void onStartTemporaryDetach() {
super.onStartTemporaryDetach();
mDraweeHolder.onDetach();
}

@Override
public void onFinishTemporaryDetach() {
super.onFinishTemporaryDetach();
mDraweeHolder.onAttach();
}
</code></pre>
<p>onAttachedToWindow 是view 本身的回调，当view 被添加到window中，被绘制之前的回调。如addview（this view）；<br>
onDetachedFromWindow 是view 本身的回调，当view被从window中删除时的回调。如 removeview（this view）;<br>
onStartTemporaryDetach 是view本身的回调，当view被从ViewGroup临时分离时回调，如listview中的item移出屏幕时；<br>
onFinishTemporaryDetach 是view本身的回调，当view在回调onStartTemporaryDetach完成改变后，再次添加到ViewGroup时回调，如listview中复用的item划入屏幕时；<br>
DraweeView通过这个两对方法来保证当view移出屏幕容器和添加进入屏幕容器时来调用mDraweeHolder.onAttach()和mDraweeHolder.onDetach()来保证显示图片的逻辑的，mDraweeHolder.onAttach()就是从Controller中获取要现实的图片资源显示，mDraweeHolder.onAttach()就是释放资源，具体实现可以跟一下源码查看；</p>
<p>##fresco对内存缓存策略</p>
<p>Fresco的内存缓存策略是根据android系统版本不同做了不同处理，5.0以下系统：图片不存储在Java heap，而是存储在ashmem，中间的字节 buffer同样位于native heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆 内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统 Fresco将Bitmap缓存直接放到了堆内存中。</p>
<p>关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种 为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性inPurgeable：</p>
<pre><code>BitmapFactory.Options = new BitmapFactory.Options();
options.inPurgeable = true;
Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);
</code></pre>
<p>所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。</p>
<p>既然Fresco中Bitmap缓存在5.0以下是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收 它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个 SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方 法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提 供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同 时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在 调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与 CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：</p>
<p>1）在赋值CloseableReference给新对象的时候，调用.clone()进行赋值</p>
<p>2）在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用</p>
<p>##图片采样处理<br>
为防止使用者对图片的大小没有概念或者直接加载过大图片时造成内存溢出的风险加大，按照经验统一了三个采样标准：<br>
DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.BIG_TYPE</p>
<p>##对于那些不经常变动的图片，我们应该怎么处理；</p>
<p>当我们有些图片不经常动时需要能长时间保存，但如果放入同一个本地缓存文件下时，随着不断加载图片到文件缓存设定上限时，根据LruCach的规则，需要长时间保存的图片可能就会被清除掉，那这就不满足我们的需求了，应该怎么处理呢？</p>
<p>1）强大的fresco已经给我们提供了解决方案，引用官网资料：<br>
用一个文件还是两个文件缓存?<br>
如果要使用2个缓存，在配置image pipeline 时调用 setMainDiskCacheConfig 和 setSmallImageDiskCacheConfig 方法即可。大部分的应用有一个文件缓存就够了，但是在一些情况下，你可能需要两个缓存。比如你也许想把小文件放在一个缓存中，大文件放在另外一个文件中，这样小文件就不会因大文件的频繁变动而被从缓存中移除。<br>
至于什么是小文件，这个由应用来区分，在创建image request, 设置 ImageType 即可:<br>
ImageRequest request = ImageRequest.newBuilderWithSourceUri(uri)<br>
.setImageType(ImageType.SMALL)</p>
<p>如果你仅仅需要一个缓存，那么不调用setSmallImageDiskCacheConfig即可。Image pipeline 默认会使用同一个缓存，同时ImageType也会被忽略。</p>
<p>2）实现方法：</p>
<pre><code>配置
DiskCacheConfig diskCacheConfig = DiskCacheConfig.newBuilder()            
.setBaseDirectoryName()//设置主缓存目录文件名
.setBaseDirectoryPath()//设置主缓存目录根目录
.setMaxCacheSize()//设置主缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置主缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置主缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();
DiskCacheConfig smallDiskCacheConfig = DiskCacheConfig.newBuilder()
.setBaseDirectoryName()//设置次缓存目录文件名
.setBaseDirectoryPath()//设置次缓存目录根目录
.setMaxCacheSize()//设置次缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置次缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置次缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();

ImagePipelineConfig pipelineConfig = ImagePipelineConfig.newBuilder(mContext)
.setSmallImageDiskCacheConfig(smallDiskCacheConfig)//磁盘缓存配置，存储首页图片的配置（总，三级缓存）
.setMainDiskCacheConfig(diskCacheConfig)//磁盘缓存配置（总，三级缓存）
.setCacheKeyFactory(new CdnAwareCacheKeyFactory())//uri匹配策略，目前只匹配path，就是为了避免cdn图片会多次请求
.build();
</code></pre>
<p>自定义WubaDraweeView控件中添加缓存到次缓存目录的方法；</p>
<pre><code>public void setSmallDiskImageURI(Uri uri){
ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)
.setImageType(ImageRequest.ImageType.SMALL)
.build();
DraweeController controller = FrescoWubaCore.newDraweeControllerBuilder()
.setImageRequest(request)
.setOldController(getController())
.build();
setController(controller);
}
</code></pre>
<p>对于需要不经常变动需要长时间保存的可以使用以上方法；<br>
目前ImageRequest.ImageType只支持两种，以下是fresco源码，Default是默认的回放入DiskCacheConfig，根据类型选择disk缓存策略，源码：</p>
<pre><code>/**    * An enum describing type of the image.
*/
public enum ImageType {
/* Indicates that this image should go in the small disk cache, if one is being used */
SMALL,

/* Default */
DEFAULT,
}

public void produceResults(
final Consumer&lt;EncodedImage&gt; consumer,
final ProducerContext producerContext) {
ImageRequest imageRequest = producerContext.getImageRequest();
if (!imageRequest.isDiskCacheEnabled()) {
maybeStartInputProducer(consumer, consumer, producerContext);
return;
}

producerContext.getListener().onProducerStart(producerContext.getId(), PRODUCER_NAME);

final CacheKey cacheKey =
    mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());
boolean isSmallRequest = (imageRequest.getImageType() == ImageRequest.ImageType.SMALL);
final BufferedDiskCache preferredCache = isSmallRequest ?
    mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;//根据类型选择disk缓存；
</code></pre>
<p>......</p>
<p>##如何获取本地缓存路径？<br>
有时我们将需要fresco已加载的图片的本地路径获取到，然后对本地路径作处理，获取方法：<br>
1）判断图片的uri是否已缓存；</p>
<pre><code>/**
* 判断是否已缓存本地
* @param loadUri
* @return
*/
private boolean isDownloaded(Uri loadUri) {
    if (loadUri == null) {
        return false;
    }
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    return ImagePipelineFactory.getInstance()
            .getMainFileCache().hasKey(cacheKey);
}
</code></pre>
<p>2）如果已缓存可获取本地路径</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>@Override
public boolean hasKey(final CacheKey key) {
synchronized (mLock) {
    if (hasKeySync(key)) {
    return true;
    }
    try {
    String resourceId = null;
    boolean retval = false;
    if (mIndex.containsKey(key)) {
        resourceId = mIndex.get(key);
        retval = mStorage.contains(resourceId, key);
    } else {
        List&lt;String&gt; resourceIds = getResourceIds(key);
        for (int i = 0; i &lt; resourceIds.size(); i++) {
        resourceId = resourceIds.get(i);
        retval = mStorage.contains(resourceId, key);
        if (retval) {
            break;
        }
        }
    }
    if (retval) {
        mIndex.put(key, resourceId);
    } else {
        mIndex.remove(key);
    }
    return retval;
    } catch (IOException e) {
    return false;
    }
}
}
@VisibleForTesting
static List&lt;String&gt; getResourceIds(final CacheKey key) {
try {
    final List&lt;String&gt; ids;
    if (key instanceof MultiCacheKey) {
    List&lt;CacheKey&gt; keys = ((MultiCacheKey) key).getCacheKeys();
    ids = new ArrayList&lt;&gt;(keys.size());
    for (int i = 0; i &lt; keys.size(); i++) {
        ids.add(SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;)));
    }
    } else {
    ids = new ArrayList&lt;&gt;(1);
    ids.add(SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes(&quot;UTF-8&quot;)));
    }
    return ids;
} catch (UnsupportedEncodingException e) {
    // This should never happen. All VMs support UTF-8
    throw new RuntimeException(e);
}
}

public static String makeSHA1HashBase64(byte[] bytes) {
try {
    MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);
    md.update(bytes, 0, bytes.length);
    byte[] sha1hash = md.digest();
    return Base64.encodeToString(sha1hash, Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP);
} catch (NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
}
}
</code></pre>
<p>可以看出CachKey的匹配规则时，调用SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;))用UTF－8对CachKey的toString值encode，然后用SHA-1算法加密获取摘要，再用Base64 encode成字符串来进行比较的，所以关键方法时CachKey的toString方法，一切操作都是基于这个方法生成的；</p>
<p>##为降低OOM风险，我们应该向下采样Downsampling，设置setResizeOptions</p>
<p>###向下采样如何配置；<br>
向下采样是一个正在实验中的特性。使用的话需要在设置 image pipeline 时进行设置：<br>
.setDownsampleEnabled(true)<br>
如果开启该选项，pipeline 会向下采样你的图片， 同时需要设置setResizeOptions 。<br>
如果不开启该项，设置setResizeOptions，只有JPEG图片格式才起作用；<br>
向下采样在大部分情况下比 resize 更快。除了支持 JPEG 图片，它还支持 PNG 和 WebP(除动画外) 图片；</p>
<p>###自定义向下采样的方法；</p>
<pre><code>/**
* 根据图片的uri、屏幕要显示图片的宽高来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeWidth 图片要显示的宽 单位px
* @param resizeHeight 图片要显示的高 单位px
* @param uri 图片的uri
*
*/
public void setResizeOptionsImageURI(@Nullable Uri uri,int resizeWidth,int resizeHeight){
    LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeWidth=&quot;+resizeWidth+&quot;,resizeHeight=&quot;+resizeHeight);
    ImageRequest imageRequest = null;
    if (uri == null){
        LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == uri is null&quot;);
    }else {
        ResizeOptions options = null;
        if (resizeHeight&gt;0&amp;&amp;resizeWidth&gt;0) {
            options = new ResizeOptions(resizeWidth, resizeHeight);
        }else{
            LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeHeight &lt; 0 or resizeWidth &lt; 0&quot;);
        }
        imageRequest = ImageRequestBuilder.newBuilderWithSource(uri)
                .setResizeOptions(options)
                .build();
    }
    setControllerWithParams(imageRequest,null);
}
/**
* 根据图片的uri、屏幕要显示图片采样类型的来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeOptionsType 图片采样类型，DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE/MIDDLE_TYPE/BIG_TYPE；
* @param uri 图片的uri
*
*/
public void setResizeOptionsTypeImageURI(Uri uri,int resizeOptionsType){
    setResizeOptionsImageURI(uri, WubaResizeOptionsUtil.getNewResizeOptionsByType(resizeOptionsType));
}
</code></pre>
<p>###自定义向下采样的类型有三种，大中小；<br>
根据项目中使用图片宽高频率较多的情况分为三种：</p>
<pre><code>/**
* 根据图片的采样类型获取ResizeOptions对象；
* @param resizeOptionsType 图片的采样类型
*/
public static ResizeOptions getNewResizeOptionsByType(int resizeOptionsType){
    int width = 0;
    int height = 0;
    switch (resizeOptionsType){
        case DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE:
            width = 200;
            height = 150;
            break;
        case DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE:
            width = 360;
            height = 300;
            break;
        case DefaultConfigCentre.ResizeOptionsType.BIG_TYPE:
            width = 720;
            height = 600;
            break;
        default:
            checkResizeOptionsType(resizeOptionsType);
            break;

    }
    return new ResizeOptions(width,height);
}
</code></pre>
<p>###默认向下采样类型；<br>
如果我们不设置向下采样的类型，那默认我们会采用DefaultConfigCentre.ResizeOptionsType.BIG_TYPE，是为了预防图片太大，我们默认处理造成OOM的情况；</p>
<pre><code>@Override
public void setImageURI(Uri uri, @Nullable Object callerContext) {
    setResizeOptionsTypeImageURI(uri,DefaultConfigCentre.ResizeOptionsType.BIG_TYPE);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java知识体系之-泛型与泛型擦除]]></title>
        <id>https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu/</id>
        <link href="https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu/">
        </link>
        <updated>2019-12-06T05:59:36.000Z</updated>
        <content type="html"><![CDATA[<p>#Java泛型与进阶<br>
##什么是泛型<br>
泛型是Java中一种常用的用于解决编译期间的类型转换异常的方式，防止在运行期间出现classCastException。</p>
<p>代码如下：</p>
<pre><code>public class GlmapperGeneric&lt;T&gt; {
		private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
  
    public static void main(String[] args) {
        // do nothing
    }

  /**
    * 不指定类型
    */
  public void noSpecifyType(){
    GlmapperGeneric glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 需要强制类型转换
    String test = (String) glmapperGeneric.get();
    System.out.println(test);
  }

  /**
    * 指定类型
    */
  public void specifyType(){
    GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 不需要强制类型转换
    String test = glmapperGeneric.get();
    System.out.println(test);
  }
}
</code></pre>
<p>##泛型中的通配符<br>
在泛型中，通常使用的通配符有如下几种：T，E，K，V ？ ，这些符号你可以自己指定，但是为了更好的理解，我们通常使用上述作为默认规则。<br>
T：代表指定的Java类型；<br>
E：代表Element；<br>
K和V：用于在Map中存储的key-value；<br>
？：代表不确定的Java类型；</p>
<p>###？通配符<br>
我们先来看一个例子：List&lt;? extend Animals&gt; list = new List();<br>
此时，它表示的意思就是我们的这个list可以传递的就是继承了Animals的子类；</p>
<p>###上届通配符<br>
所谓的上届通配符就是&lt; ? extends E&gt;，代表的意思是传递任意一个E本身或者E的子类都OK。<br>
###下届通配符<br>
所谓的下届通配符就是&lt; ? super E&gt;，代表的意思是传递任意一个是E本身或者E的父类都OK。</p>
<pre><code>private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src){
    for (T t : src) {
        dst.add(t);
    }
}

public static void main(String[] args) {
    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();
    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();
    new Test3().test(animals,dogs);
}
// Dog 是 Animal 的子类
class Dog extends Animal {

}
</code></pre>
<p>###？和T的区别<br>
从字面的意思上来看：？代表的是非指定的任意Java类，T代表的是指定的Java类，T只可以继承某个类，而？可以标识父类或者子类：? extend A , ? super A。</p>
<p>##泛型擦除</p>
<pre><code>// 指定泛型为String

List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
// 指定泛型为Integer
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();

System.out.println(list1.getClass() == list2.getClass()); // true
</code></pre>
<p>在编译时，对于这些已经指定过的泛型，编译器会将它们都清除掉，这样的操作我们叫做泛型擦除。<br>
规则：如果我们给泛型指定了上届，那么在擦除之后，它会指定到上届。否则，它将指定到Object。</p>
<p>##参考地址</p>
<p>https://juejin.im/post/5d5789d26fb9a06ad0056bd9</p>
<p>https://juejin.im/post/5ceba1a2f265da1b95703558</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-线程池[转]]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan/</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan/">
        </link>
        <updated>2019-12-05T12:46:45.000Z</updated>
        <content type="html"><![CDATA[<p>#线程池概念<br>
线程池： 简单理解，它就是一个管理线程的池子。</p>
<p>#带着问题看文章<br>
问题1：Java的线程池说一下，各个参数的作用，如何进行的?<br>
问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。<br>
问题3：线程池都有哪几种工作队列？<br>
问题4：使用无界队列的线程池会导致内存飙升吗？<br>
问题5：说说几种常见的线程池及使用场景?</p>
<p>#线程池的优点<br>
·它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗：<br>
因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。<br>
·提高响应速度：<br>
如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。<br>
·重复利用：<br>
线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
<p>#线程池的创建<br>
线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue&lt;Runnable&gt; workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) 
</code></pre>
<p>corePoolSize： 线程池核心线程数最大值<br>
maximumPoolSize： 线程池最大线程数大小<br>
keepAliveTime： 线程池中非核心线程空闲的存活时间大小<br>
unit： 线程空闲存活时间单位<br>
workQueue： 存放任务的阻塞队列<br>
threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。<br>
handler：  线城池的饱和策略事件，主要有四种类型。</p>
<p>#任务执行<br>
线程池执行流程，即对应execute()方法：<br>
<img src="https://Mozziehh.github.io/post-images/1575550465980.png" alt="" loading="lazy"></p>
<p>·提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。<br>
·如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。<br>
·当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达·到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。<br>
·如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p>
<p>#四种拒绝策略<br>
·AbortPolicy(抛出一个异常，默认的)<br>
·DiscardPolicy(直接丢弃任务)<br>
·DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）<br>
·CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p>
<p>#为了形象描述线程池执行，我打个比喻：</p>
<p>·核心线程比作公司正式员工<br>
·非核心线程比作外包员工<br>
·阻塞队列比作需求池<br>
·提交任务比作提需求</p>
<figure data-type="image" tabindex="1"><img src="https://Mozziehh.github.io/post-images/1575550700308.png" alt="" loading="lazy"></figure>
<p>·当产品提个需求，正式员工（核心线程）先接需求（执行任务）<br>
·如果正式员工都有需求在做，(即核心线程数已满），产品就把需求先放需求池（阻塞队列）。<br>
·如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。<br>
·如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。<br>
·如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</p>
<p>##问题1 Java的线程池说一下，各个参数的作用，如何进行的?</p>
<p>答案：线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</p>
<p>#线程池异常处理</p>
<p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<p>#线程池exec.submit(runnable)的执行流程</p>
<p>通过debug上面有异常的submit方法（建议大家也去debug看一下,图上的每个方法内部是我打断点的地方），处理有异常submit方法的主要执行流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://Mozziehh.github.io/post-images/1575551509586.png" alt="" loading="lazy"></figure>
<p>#线程池的工作队列<br>
##线程池都有哪几种工作队列？</p>
<p>·ArrayBlockingQueue:（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<p>·LinkedBlockingQueue:（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p>
<p>·DelayQueue:是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<p>·PriorityBlockingQueue:（优先级队列）是具有优先级的无界阻塞队列；</p>
<p>·SynchronousQueue:（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，</p>
<p>·newCachedThreadPool线程池使用了这个队列。</p>
<p>#几种常用的线程池</p>
<p>##newFixedThreadPool (固定数目线程的线程池)<br>
##newCachedThreadPool(可缓存线程的线程池)<br>
##newSingleThreadExecutor(单线程的线程池)<br>
##newScheduledThreadPool(定时及周期执行的线程池)</p>
<p>##newFixedThreadPool<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory);
    }
</code></pre>
<p>###线程池特点：<br>
核心线程数和最大线程数大小一样<br>
没有所谓的非空闲时间，即keepAliveTime为0<br>
阻塞队列为无界队列LinkedBlockingQueue</p>
<p>####工作机制：<br>
<img src="https://Mozziehh.github.io/post-images/1575555765273.png" alt="" loading="lazy"></p>
<p>####提交任务<br>
如果线程数少于核心线程，创建核心线程执行任务<br>
如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列<br>
如果线程执行完任务，去阻塞队列取任务，继续执行。</p>
<p>####实例代码</p>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);
                for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
                    executor.execute(()-&gt;{
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException e) {
                            //do nothing
                        }
        });
</code></pre>
<p>####使用场景<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<p>###newCachedThreadPool</p>
<p>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {<br>
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>
60L, TimeUnit.SECONDS,<br>
new SynchronousQueue<Runnable>(),<br>
threadFactory);<br>
}<br>
####线程池特点：<br>
核心线程数为0<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是SynchronousQueue<br>
非核心线程空闲存活时间为60秒</p>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。<br>
工作机制<br>
<img src="https://Mozziehh.github.io/post-images/1575555947765.png" alt="" loading="lazy"></p>
<p>####提交任务<br>
因为没有核心线程，所以任务直接加到SynchronousQueue队列。<br>
判断是否有空闲线程，如果有，就去取出任务执行。<br>
如果没有空闲线程，就新建一个线程执行。<br>
执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newCachedThreadPool();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
用于并发执行大量短期的小任务。</p>
<p>###newSingleThreadExecutor</p>
<p>public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {<br>
return new FinalizableDelegatedExecutorService<br>
(new ThreadPoolExecutor(1, 1,<br>
0L, TimeUnit.MILLISECONDS,<br>
new LinkedBlockingQueue<Runnable>(),<br>
threadFactory));<br>
}<br>
####线程池特点</p>
<p>核心线程数为1<br>
最大线程数也为1<br>
阻塞队列是LinkedBlockingQueue<br>
keepAliveTime为0</p>
<p>####工作机制</p>
<p>####提交任务<br>
线程池是否有一条线程在，如果没有，新建线程执行任务<br>
如果有，讲任务加到阻塞队列<br>
当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newSingleThreadExecutor();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<p>###newScheduledThreadPool</p>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
</code></pre>
<p>####线程池特点<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是DelayedWorkQueue<br>
keepAliveTime为0<br>
scheduleAtFixedRate() ：按某种速率周期执行<br>
scheduleWithFixedDelay()：在某个延迟后执行</p>
<p>####工作机制<br>
添加一个任务<br>
线程池中的线程从 DelayQueue 中取任务<br>
线程从 DelayQueue 中获取 time 大于等于当前时间的task<br>
执行完后修改这个 task 的 time 为下次被执行的时间<br>
这个 task 放回DelayQueue队列中</p>
<p>####实例代码<br>
/**<br>
创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间<br>
*/<br>
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);<br>
scheduledExecutorService.scheduleWithFixedDelay(()-&gt;{<br>
System.out.println(&quot;current Time&quot; + System.currentTimeMillis());<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
}, 1, 3, TimeUnit.SECONDS);</p>
<p>####运行结果：</p>
<pre><code>/**
创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) 
*/
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
        System.out.println(&quot;current Time&quot; + System.currentTimeMillis());
        System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
    }, 1, 3, TimeUnit.SECONDS);;
</code></pre>
<p>####使用场景<br>
周期性执行任务的场景，需要限制线程数量的场景</p>
<p>##线程池状态<br>
线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。<br>
//线程池状态<br>
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;<br>
复制代码线程池各个状态切换图：<br>
<img src="https://Mozziehh.github.io/post-images/1575556444104.png" alt="" loading="lazy"></p>
<p>###RUNNING</p>
<p>该状态的线程池会接收新任务，并处理阻塞队列中的任务;<br>
调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;<br>
调用线程池的shutdownNow()方法，可以切换到STOP状态;</p>
<p>###SHUTDOWN</p>
<p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>
队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</p>
<p>###STOP</p>
<p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>
线程池中执行的任务为空,进入TIDYING状态;</p>
<p>###TIDYING</p>
<p>该状态表明所有的任务已经运行终止，记录的任务数量为0。<br>
terminated()执行完毕，进入TERMINATED状态</p>
<p>###TERMINATED</p>
<p>该状态表示线程池彻底终止</p>
<p>作者：Jay_huaxiao<br>
链接：https://juejin.im/post/5d1882b1f265da1ba84aa676</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-Handler]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler/</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler/">
        </link>
        <updated>2019-12-05T07:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>##概述<br>
工作中，我们经常遇到多线程用来处理耗时任务，因为主线程中操作很容易引起ANR。于是在Android中使用Handler进行异步的消息处理，处理完成后将再返回给UI线程执行后续逻辑。</p>
<p>##带着问题去看文章</p>
<p>Q1：子线程可以更新UI么，为什么？</p>
<p>Q2：一个Thread可以有几个Looper？几个Handler？</p>
<p>Q3：可以在子线程直接new一个Handler吗？该怎么做？</p>
<p>Q4：Message的创建方法有几种？哪种效果更好，为什么？</p>
<p>Q5：主线程中Looper的轮询死循环为何没有阻塞主线程？</p>
<p>Q6：使用Hanlder的postDealy()后消息队列会发生什么变化？</p>
<p>Q7：点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>Q8：Handler是如何完成子线程和主线程通信的？</p>
<p>Q9：关于ThreadLocal，谈谈你的理解？</p>
<p>Q10：生产者-消费者设计模式？</p>
<p>Q11：享元设计模式？</p>
<p>Q12：Thread两次调用start()方法会发生问题么？</p>
<p>Q13：开启三个线程，循环打印出1到100；<br>
T1：1,4,7....  T2:2,5,8.....  T3:3,6,9....</p>
<p>上述这十三个问题，如果你能清晰透彻的了解，那么你大可关闭这篇文章~</p>
<p>##常见用法</p>
<pre><code>//处理
private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MESSAGE_TEXT_VIEW:
                    mTextView.setText(&quot;UI成功更新&quot;);
                default:
                    super.handleMessage(msg);
            }
        }
};

//调用
new Thread(new Runnable() {
            @Override
            public void run() {
				mHandler.obtainMessage(MESSAGE_TEXT_VIEW).sendToTarget();
            }
        }).start();
</code></pre>
<p>##Handler的构造方法<br>
我们先来剖析一下Handler的构造方法：</p>
<pre><code>public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre>
<p>在构造方法里面，我们看到通过Looper.myLooper()去获取当前Hander的looper，发现获取不到，于是触发异常：&quot;Can't create handler inside thread that has not called Looper.prepare()&quot;，它的意思就是不能在没有得到looper的情况下，就使用handler。但是，我们发现在实际的使用过程中，我们并没有调用Looper.prepare()方法，也没有事，其实是主线程已经帮我们调用，让我们看一下如下的代码：</p>
<p>在ActivityThread中的main方法，它主要做了两个事情：一个准备mainLooper，一个是通过loop()方法创建一个looper：</p>
<pre><code>public static void main(String[] args) {
    ...

    Looper.prepareMainLooper();

    ...
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre>
<p>在得到looper之后，又通过looper获取了消息队列，这个消息队列其实是一个消息链表，它里面存储的就是Message，即消息。</p>
<p>然后我们再来看一下这个Looper.prepareMainLooper（）</p>
<pre><code>public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre>
<p>所以说，ActivityThread在启动的过程中就创建了looper和messageQueue。</p>
<p>##Looper<br>
接下来，我们看一下Looper.prepare()方法里面都做了什么？</p>
<pre><code>static final ThreadLocal sThreadLocal = new ThreadLocal();

public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
</code></pre>
<p>我们看到，它是在ThreadLocal中存储了对应的Looper对象；我们看到ThreadLocal是被static和final同时修饰，所以，它是不可以被继承的并且全局静态的。所以，它只存在一份。</p>
<pre><code>private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<p>所以，这里我们看到，当我们多次调用prepare的时候，就会报错：&quot;Only one Looper may be created per thread&quot;	，意思是：每一个线程有且只有一个Looper。</p>
<p>那么，这个Looper里面都有什么呢？</p>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>首先Looper会定义一个消息链表，然后获取Handler当前的线程。<br>
Looper的最主要作用：开启消息循环机制，不断从MessageQueue里面获取Message，然后调用msg.target.dispatchMessage将消息分发出去。</p>
<p>接下来，我们去看一下Loop()方法：</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    
    //无限循环，这里可以思考一下，为什么不会阻塞主线程
    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;+ Long.toHexString(ident) + &quot; to 0x&quot;+ Long.toHexString(newIdent) + &quot; while dispatching to &quot;+ msg.target.getClass().getName() + &quot; &quot;+ msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre>
<p>#消息的发送<br>
发送消息，我们调用的是obtainMessage，然后sendtoTarget();在obtainMessage中我们获取的是Message.obtain()方法：</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>这是一个静态的方法，使用了同步锁，获取消息，同时把自己清空掉，放在链表头；然后，sendToTarget负责发送消息，最终调用的是sendMessageAtTime(Message msg, long uptimeMillis)</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<p>首先，获取消息链表，然后把消息入链表。</p>
<p>##消息的处理</p>
<p>刚才我们说过，我们调用的是msg.target.dispatchMessage，这个msg.target获取的就是handler。然后我们来看一下dispatchMessage都做了什么？</p>
<pre><code>public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>
<p>这个时候我们可以看到，当我们没有给Message设置callback或者没有设置全局的callback的时候，它会默认的调用handleMessage(msg);这个时候，我们自己的handler就接收到了这个handleMessage。</p>
<p>##问题回顾</p>
<p>###子线程可以更新UI么，为什么？<br>
子线程更新UI要分两种情况，一种是在onCreate里面，一种是在onResume里面。onCreate里面调用没事（如果不sleep()的话），在onResume里面调用就会发生异常：&quot;Only the original thread that created a view hierarchy can touch its views.&quot;，根本原因是在Activity初始化的时候，使用WindowManagerGlobal的addView方法，构造出ViewRootImpl，然后使用ViewRootImpl来判断是否在子线程中，而它的创建是在onResume方法里面进行回调的。</p>
<p>###一个Thread可以有几个Looper？几个Handler？<br>
一个Looper，因为调用Looper.prepare()会得到一个looper，多次调用会报错。一个Thread里面可以有多个Handler，通过msg.target进行关联。</p>
<p>###可以在子线程直接new一个Handler吗？该怎么做？<br>
我们正常是不会调用Looper.prepare()方法的，是主线程帮我们调用的。但是假如我们在Thread里面创建了一个Handler的时候，你会发现这个Handler直接在构造函数的时候就会报错。所以解决办法是：在new Handler之前，手动给它创建一个looper，也就是Looper.prepare()；</p>
<p>###Message的创建方法有几种？哪种效果更好，为什么？<br>
三种，new Message(), Message.obtain(), mHandler.obtainMessage()<br>
第一种就是直接创建，后两种是从消息链表里面取Message，使用了享元模式。</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>###主线程中Looper的轮询死循环为何没有阻塞主线程？<br>
android的UI线程本质上就是一个轮训机制，你可以理解如果没有这个循环，那么将无法监听用户的时间，无法响应UI。</p>
<p>###使用Hanlder的postDealy()后消息队列会发生什么变化？假如这个时候再来一条延迟消息Handler应该怎么处理？</p>
<p>MessageQueue里面调用nativePollOnce方法来停止阻塞线程，阻塞的时间根据msg.when与now的差值来计算应该阻塞多长时间，如果再来一条非延迟消息，会将当前时间清空，直接执行，如果再来一条延迟消息，会计算当前时间与上一个时间比较，然后执行短的那个。</p>
<pre><code>int nextPollTimeoutMillis = 0;
for(;;) {
    if (nextPollTimeoutMillis != 0) {
        Binder.flushPendingCommands();
    }
 
    nativePollOnce(ptr, nextPollTimeoutMillis);
 
    synchronized (this) {
        // Try to retrieve the next message.  Return if found.
        final long now = SystemClock.uptimeMillis();
        Message prevMsg = null;
        Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            // Stalled by a barrier.  Find the next asynchronous message in the queue.
            do {
                prevMsg = msg;
                msg = msg.next;
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        if (msg != null) {
            if (now &lt; msg.when) {
                // Next message is not ready.  Set a timeout to wake up when it is ready.
                nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
            } else {
                // Got a message.
                mBlocked = false;
                if (prevMsg != null) {
                    prevMsg.next = msg.next;
                } else {
                    mMessages = msg.next;
                }
                msg.next = null;
                if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                msg.markInUse();
                return msg;
            }
        } else {
            // No more messages.
            nextPollTimeoutMillis = -1;
        }
        ...
    }
    nextPollTimeoutMillis = 0;
</code></pre>
<p>###点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>###Handler是如何完成子线程和主线程通信的？<br>
见消息的处理</p>
<p>###关于ThreadLocal，谈谈你的理解？</p>
<p>static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();</p>
<p>Thread相当于是简单了实现了一个HashMap，key对应的是每一个线程，value对应它的looper。为啥不用HashMap？因为HashMap里面有很多功能是不需要的，所以单独实现了一个。</p>
<p>###生产者-消费者设计模式？<br>
一个用于生产，一个用于消费，生产者将事件丢进缓冲区，缓冲区满则不继续生产，消费者去消费缓冲区的事件，如果缓冲区空就不消费，并且会通知生产者去生产，同时，生产者生产完成后，要通知消费者去消费。</p>
<p>###Thread两次调用start()方法会发生问题么？</p>
<p>线程首先会运行一次，然后抛出java.lang.IllegalThreadStateException<br>
异常。</p>
<pre><code>if (threadStatus != 0 || started)
            throw new IllegalThreadStateException();
</code></pre>
<p>###使用三个线程顺序打印1到100<br>
使用wait和notifyAll，然后利用同步锁volatile将loackNum加锁，利用synchronized对object加锁，实现同步。</p>
<pre><code>static volatile int loackNum = 1;
static Object object = new Object();
public static void main(String args[]){
    final Thread thread1 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 1) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        }
    });
    Thread thread2 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 2) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    Thread thread3 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 0) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    thread1.start();
    thread2.start();
    thread3.start();
}
</code></pre>
<p>#总结<br>
Handler负责发送消息和处理消息，Message就是那个消息，通过obtain方法获取消息队列，使用sendMessage将消息入队列。最终通过Looper.loop()方法中的无限循环去dispatchMessage回调到Handler里面。</p>
<p>参考：</p>
<p>https://juejin.im/entry/5708b3c38ac247004c1deef7</p>
<p>https://blog.csdn.net/songzi1228/article/details/82835982</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GifView在android的应用指南]]></title>
        <id>https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan/</id>
        <link href="https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan/">
        </link>
        <updated>2019-11-22T00:48:04.000Z</updated>
        <content type="html"><![CDATA[<p>##背景<br>
目前，大部分市场应用在展示产品的时候都会选择图片配文字的形式，显得更加直观。随着人们手机设备性能的提高与Wifi以及4G网络的提速，为了能让用户的体验更加立体，很多APP在”秀“自己的产品的时候都会直接展示视频。然而图片和视频之间还是有一定的流量差距，为了让用户可以更好的过渡这一差距，图片展示gifview，点击gifview观看视频这样的用户行为正在慢慢的被接受。</p>
<p>##部落来袭<br>
58部落目前是非常大的用户群体，他们也会经常发表一些自己的作品，看法，目前也是列表页展示图片，点击进入后展示详情。那么如果需要有这个过渡，就需要在列表页上增加gifview来达到更好的曝光率。</p>
<p>##大众点评&amp;马蜂窝</p>
<p>###点评 &amp; 马蜂窝 效果展示</p>
<!--todo-->
<p>###效果分析<br>
我们先来自己想想，如果要是我们自己来实现这个效果应该如何来做：</p>
<p>两种方法：</p>
<p><em><strong>方案一：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义GifView，包含展示静态图和gif图的功能；</p>
<p>3.进入页面，请求首页，获取json得到gif；</p>
<p>4.解析gif的第一帧，得到Image的比特流，让GifView展示图片；</p>
<p>5.图片展示完成后，自定义GifView播放GifView；</p>
<hr>
<p>优点：</p>
<p>简化json输出，json里面的返回值返回一套gif就可以，自己解析gif的第一帧用于展示图片；</p>
<p>缺点：</p>
<p>速度慢，本来列表页快速滑动展示大图片都考虑加载时间，如果再去自己解析，成本太高，内存要求大；</p>
<hr>
<p><em><strong>方案二：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义ImageView，展示Image；</p>
<p>3.自定义GifView，展示gif图；</p>
<p>4.进入页面，请求首页，获取json得到image和gif；</p>
<p>5.自定义ImageView展示imageview占位，然后紧接着加载gif；</p>
<p>优点：</p>
<p>1.速度快；</p>
<p>2.解耦，一旦出现问题，可以快速降级；</p>
<hr>
<p>另外，从版本的迭代的上来考虑，我个人更倾向于方案二：</p>
<p>###点评效果深入研究<br>
接下来，先上常规操作让我们看一下大众点评是不是酱样婶的吧：</p>
<p>####dump一下，你不知道<br>
Running activities (most recent first):<br>
Run #1: ActivityRecord{1b8520 u0 com.dianping.v1/.NovaMainActivity t15792}<br>
Run #0: ActivityRecord{2a47964 u0 com.tencent.mm/.ui.LauncherUI t15793}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{945d44 u0 com.miui.home/.launcher.Launcher t1}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{52d96ba u0 com.android.systemui/.recents.RecentsActivity t15788}<br>
ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)<br>
User #0: state=RUNNING_UNLOCKED</p>
<p>首先，我们来看一下dump信息，NovaMainActivity，是它的首页，但是显然根据这个我们没有任何头绪。正向查一个控件我们要知道哪个布局，哪个控件，哪个View。所以，我想能不能看看Log，结果还真的让我找到了蛛丝马迹。</p>
<p>####logcat<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been started:</p>
<p>在我快速滑动的时候，我发现居然有这么些可爱的代码在控制台打印出来。于是，我就看到了新的曙光。</p>
<p>万幸的是，我还在logcat里面额外看到了webp格式的图片和动图的日志：</p>
<pre><code>//动图
https://img.xxx.net/coverpic/2d348f2ea08616ab1e8c652800373740.webp
//非动图
https://img.xxx.net/coverpic/4cf4cfa5469f95444986f83f194f6acb35706.jpg%40320w_426h_1e_1c_1l%7Cwatermark%3D0.webp
</code></pre>
<p>这个日志初步印证了我的想法，我决定看一下&quot;GifImageVIew&quot;都干了啥。点评是有混淆和做了加壳的，常规的jd-gui查看的代码看不到。通过脱壳，获取其相关代码，为了更好地理解，里面的关键代码做了注释：</p>
<pre><code>public class GifImageView extends FrameLayout {

    public GifImageView(Context context) {
        super(context);
    }
    public static final String TAG = &quot;GifImageView&quot;;
    public PicassoImageView gifImageView; //Picasso 
    private String gifIvGroup;
    private double gifPriority; //gif的优先级
    private String gifUrl; //gif的url
    public PicassoImageView imageView;  //又来一个Picasso

	 //构造函数
    public GifImageView(Context context) {
        this(context, null);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet) {
        this(context, attributeSet, 0);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
        init(context);
    }
    
    //初始化 *关键*
    private void init(Context context) {
        LayoutParams layoutParams = new FrameLayout.LayoutParams(-1, -1);
        this.imageView = new PicassoImageView(context);
        this.gifImageView = new PicassoImageView(context);
        this.gifImageView.setFadeInDisplayEnabled(false);
        addView(this.gifImageView, layoutParams);
        addView(this.imageView, layoutParams);
        //开始进行gif加载的设置
        this.gifImageView.setOnLoadChangeListener(new u() {

            //gif加载开始
            public void onImageLoadStart() {
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
  
            //gif加载完成
            public void onImageLoadSuccess(Bitmap bitmap) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif success : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.GONE);
            }
  
            //加载失败如何处理
            public void onImageLoadFailed() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif failed : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
        });
    }
    
    //设置布局
    public void setLayoutParams(LayoutParams layoutParams) {
        super.setLayoutParams(layoutParams);
        setViewParams(this.imageView, layoutParams);
        setViewParams(this.gifImageView, layoutParams);
    }


    //设置布局
    private void setViewParams(View view, LayoutParams layoutParams) {
        LayoutParams layoutParams2 = view.getLayoutParams();
        if (layoutParams2 instanceof FrameLayout.LayoutParams) {
            layoutParams2.width = layoutParams.width;
            layoutParams2.height = layoutParams.height;
            view.setLayoutParams(layoutParams2);
        }
    }


    //开始执行gif播放
    public void startGif() {
        if (this.gifImageView.isImageAnimating()) {
            Log.d(TAG, &quot;gifIv has already been started: &quot;);
        } else {
            this.gifImageView.setAnimatedImageLooping(-1);
            this.gifImageView.startImageAnimation();
            Log.d(TAG, &quot;gifIv has been started: &quot;);
        }
    }

    //停止执行gif播放
    public void stopGif() {
        if (this.gifImageView.isImageAnimating()) {
            this.gifImageView.setAnimatedImageLooping(0);
            this.gifImageView.stopImageAnimation();
            Log.d(TAG, &quot;gifIv has been stoped: &quot;);
        } else {
            Log.d(TAG, &quot;gifIv has already been stoped: &quot;);
        }
    }

    //设置image和gif图像地址
    public void setGifImage(String str, String str2) {

        this.imageView.setImage(str);
        this.gifImageView.setAnimatedImageLooping(0);
        this.gifImageView.setImage(str2);
        this.imageView.setVisibility(0);
        this.gifUrl = str2;
        if (TextUtils.isEmpty(str2)) {
            GifImageViewManager.getInstance().addGifIv(this);
        } else {
            GifImageViewManager.getInstance().removeGifIv(this);
        }
    }

    public void setAnimatedImageLooping(int i) {
        this.imageView.setAnimatedImageLooping(i);
    }

    public void setScaleType(ImageView.ScaleType scaleType) {
        this.imageView.setScaleType(scaleType);
        this.gifImageView.setScaleType(scaleType);
    }

    //支持直接设置drawable
    public void setImageDrawable(Drawable drawable) {
        this.imageView.setVisibility(0);
        this.imageView.setImageDrawable(drawable);
    }
   
   .....此处省略1000字
}
</code></pre>
<p>另外，还发现它的自定义图片PicassoImageView（好像跟git上面的Picasso没什么关系）。</p>
<pre><code>import com.dianping.imagemanager.DPImageView;
public class PicassoImageView extends DPImageView implements Clippable {
}


public class DPImageView extends ImageView implements OnClickListener {
}
</code></pre>
<p>还有。。。。咳咳，让我们点到为止吧。</p>
<p>###点评效果总结<br>
所以，点评的基本逻辑跟我之前说的第二种方案几乎无差，我们再来回顾一下：</p>
<p>1.自定义View命名为PicassoImageView，可以展示Gif图也可以展示ImageView；</p>
<p>2.封装GifImageView，里面包含两个PicassoImageView；</p>
<p>3.其中一个PicassoImageView展示imageview占位，同时另外一个PicassoImageView进行gif的加载，加载完成后，把第一个PicassoImageView消失；</p>
<p>so，感谢点评为我们提供宝贵的思路，接下来让我们去看看马蜂窝是怎么实现的吧。</p>
<p>###马蜂窝效果深入研究<br>
####dump之后依然没有有用信息<br>
也不是完全没有用，至少你知道了程序的入口在哪里。<br>
####看看logcat</p>
<pre><code>2019-09-18 16:53:11.786 25404-25919/? D/SoLoader: About to load: libgifimage.so
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so not found on /data/data/com.mfw.roadbook/lib-main
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so found on /data/app/com.mfw.roadbook-U4eSwGYqvGPqtvkBe8R4gw==/lib/arm
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: Not resolving dependencies for libgifimage.so
2019-09-18 16:53:11.795 25404-25919/? D/SoLoader: Loaded: libgifimage.so
</code></pre>
<p>嗯，果然，看看还是有收获的。又Get到一个新知识，可以通过加载so（libgifimage.so）的方式，提升GifView加载速度。</p>
<p>###马蜂窝效果总结</p>
<p>在实际体验的过程中，我发现滑动到没有加载的图片时，马蜂窝会用一个加载的灰色占位图占位，然后去下载gif，它旁边的图片都展示出来了，gif还没有下载完，体验不是很好。这点可以借鉴一下大众点评的。</p>
<p>由于马蜂窝也加壳了，脱壳其实是很开(fei)心(shen)的，有了点评的思路，我就没有特别深入的研究马蜂窝的内部实现，其实直接看效果也能看出个大概。</p>
<p>##有没有开源的库呢？<br>
我们并不想把点评或者马蜂窝的代码直接拷过来，毕竟人家没有开源，而且也不一定契合我们的风格。在git上找一个demo实现以下？<br>
于是，我看到了这个android-gif-drawable，这个看起来还不错，7K的赞，Fork了1.6K，正合我意，来吧，研究一波。</p>
<p>###API解读<br>
android-gif-drawable是通过JNI来渲染帧的，比使用WebView或者Movie性能要好一些。</p>
<p><strong>依赖</strong></p>
<pre><code>dependencies {
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'
}

repositories {
	mavenCentral()
	maven { 
		url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; }
	}
	dependencies {
    i	mplementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.+'
	}

&lt;dependency&gt;
    &lt;groupId&gt;pl.droidsonroids.gif&lt;/groupId&gt;
    &lt;artifactId&gt;android-gif-drawable&lt;/artifactId&gt;
    &lt;version&gt;insert latest version here&lt;/version&gt;
    &lt;type&gt;aar&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
<p>基本使用：</p>
<pre><code>//1. asset文件
GifDrawable gifFromAssets = new GifDrawable( getAssets(), &quot;anim.gif&quot; );

//2. resource (drawable or raw)
GifDrawable gifFromResource = new GifDrawable( getResources(), R.drawable.anim );

//3. byte array
byte[] rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//4. FileDescriptor
FileDescriptor fd = new RandomAccessFile( &quot;/path/anim.gif&quot;, &quot;r&quot; ).getFD();
GifDrawable gifFromFd = new GifDrawable( fd );

//5. file path
GifDrawable gifFromPath = new GifDrawable( &quot;/path/anim.gif&quot; );

//6. file
File gifFile = new File(getFilesDir(),&quot;anim.gif&quot;);
GifDrawable gifFromFile = new GifDrawable(gifFile);

//7. AssetFileDescriptor
AssetFileDescriptor afd = getAssets().openFd( &quot;anim.gif&quot; );
GifDrawable gifFromAfd = new GifDrawable( afd );

//8. InputStream (it must support marking)
InputStream sourceIs = ...
BufferedInputStream bis = new BufferedInputStream( sourceIs, GIF_LENGTH );
GifDrawable gifFromStream = new GifDrawable( bis );

//9. direct ByteBuffer
ByteBuffer rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//10.加载网络图片其实本质上也离不开上面这些内容，推荐RxJava；
</code></pre>
<p>额外的API：</p>
<pre><code>- 停止GIF动画
·stop() 

- 开始GIF动画
·start() 

- GIf动画是否在执行
isRunning() 

- 重置GIF动画
reset() 

- 控制执行动画的速度
setSpeed(float factor) 

- 从该动画的执行位置开始执行
seekTo(int position) 

- 动画的持续时间
getDuration() 

- 当前动画的播放时间
getCurrentPosition() 
</code></pre>
<p>调用方法也是非常简单：</p>
<pre><code>&lt;pl.droidsonroids.gif.GifImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:src=&quot;@drawable/src_anim&quot;
android:background=&quot;@drawable/bg_anim&quot;
/&gt;

try {
            GifDrawable gifFromResDrawable = new GifDrawable( mContext.getResources(), getIntGifRes(imageData.gifUrl));
            viewHolder.gifImageView.setImageDrawable(gifFromResDrawable);
            viewHolder.gifImageView.setVisibility(View.VISIBLE);
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>
<p>所以，我们看到，本质上还是这个GifDrawable在起作用，因为GifImageView继承的是ImageView。</p>
<p>###效果如下</p>
<!--todo-->
<p>##撸一个Demo<br>
我们看完了大众点评、马蜂窝、github上的实现效果。它们有自己的优点，结合58自己的技术特点，我打算采用的技术架构：FRESCO + RecyclerView的StaggeredGridLayoutManager，具体实现思路如下：</p>
<p>###使用StaggeredGridLayoutManager实现瀑布布局；</p>
<pre><code>RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);
    StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2,
            StaggeredGridLayoutManager.VERTICAL);
    recyclerView.setLayoutManager(layoutManager);

    FrescoAdapter adapter = new FrescoAdapter(this, DataUtils.getFrescoImageData());
    recyclerView.setAdapter(adapter);
</code></pre>
<p>###自定义Adapter继承自RecyclerView.Adapter，用于加载图片和GIF：</p>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

    SimpleDraweeView draweeImage;
    SimpleDraweeView draweeGif;
    TextView textView;
    public ViewHolder(@NonNull View itemView) {
        super(itemView);
        draweeImage = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview);
        draweeGif = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview_gif);
        textView = (TextView) itemView.findViewById(R.id.item_draweeview_text);
    }
}
</code></pre>
<p>###加载图片和GIF</p>
<pre><code>/**
     * Fresco 加载webp图片
     * @param draweeView
     * @param imageUrl
     */
    public static void loadWebpImage(final Context context, final SimpleDraweeView draweeView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()
                .setUri(Uri.parse(imageUrl))
                .setAutoPlayAnimations(true)
                .setOldController(draweeView.getController())
                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }

                        if(imageData.getScale() == 0){
                            int width = imageInfo.getWidth();
                            int height = imageInfo.getHeight();
                            float scale = (float) width/ (float) height;
                            imageData.setScale(scale);
                        }
                        final ViewGroup.LayoutParams layoutParams = draweeView.getLayoutParams();
                        layoutParams.width = DisplayUtils.getScreenWidth((Activity) context) / 2 - DisplayUtils.dp2px(context,10);
                        layoutParams.height = (int) (layoutParams.width/ imageData.getScale());

                        imageData.setWidth(layoutParams.width);
                        imageData.setHeight(layoutParams.height);

                        imageData.setPosition(position);

                        draweeView.setLayoutParams(layoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        draweeView.setController(controller);

    }

    /**
     * Fresco 加载webpGID
     * @param imageView
     * @param imageUrl
     */
    public static void loadWebpGif(final Context context, final SimpleDraweeView imageView,final SimpleDraweeView gifView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()

                .setUri(Uri.parse(imageUrl))

                .setAutoPlayAnimations(true)

                .setOldController(gifView.getController())

                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }
                        final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
                        final ViewGroup.LayoutParams gifLayoutParams = gifView.getLayoutParams();
                        gifLayoutParams.width = layoutParams.width;
                        gifLayoutParams.height = layoutParams.height;

                        gifView.setLayoutParams(gifLayoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        gifView.setController(controller);
    }
</code></pre>
<p>###效果如下：</p>
<!--todo-->
<p>###缺点与不足<br>
Demo里面还有很多的异常边界情况没有考虑，比如各类的容错判断，性能问题监控，等等</p>
<p>传送门：<a href="https://github.com/Mozziehh/GifView">github.com/mozzie</a></p>
<p>##参考文章</p>
<ol>
<li>
<p>https://www.jianshu.com/p/057f48df855b</p>
</li>
<li>
<p>https://github.com/koral--/android-gif-drawable</p>
</li>
<li>
<p>https://www.dev2qa.com/how-to-play-gif-file-use-android-graphics-movie-class/</p>
</li>
<li>
<p>https://blog.csdn.net/feather_wch/article/details/79558240</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过NDK实现Zxing二维码扫描放大功能]]></title>
        <id>https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng/</id>
        <link href="https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng/">
        </link>
        <updated>2019-11-22T00:43:25.000Z</updated>
        <content type="html"><![CDATA[<p> 在各个APP中几乎都能看见它的身影。二维码扫描虽然是一个普通的功能，但是在APP中占依然都放在很抢眼的位置。比如像淘宝、58这类APP主要解决PC端扫码登录，微信、支付宝这类主要使用支付，摩拜小蓝这类APP主要是用于扫码骑车。所以，能更快捷更方便的使用二维码，可以极大的提升用户体验。</p>
<p>##快捷与方便<br>
 曾经或许会有那么一个寒冷的夜晚，你骑着刚共享单车飞驰在回家的路上，突然，街边飘来哈尔滨烤冷面的香气让你不知不觉的来到那个小摊面前，迟疑了很久，你说了一句：“老板，来一份。。。再。。。加个肠。”昏暗的灯光下、其他的食客中，老板熟练的抄起手中的家伙，你熟练掏出手机，打开扫一扫，老板的二维码在你的手里一次次对焦、一次次放大，“滴”的一声，付钱，取餐，嗝~。<br>
 你有没有想过，为什么在扫描的过程中，被扫描的二维码会在扫描框里从模糊到清晰，然后再从清晰到模糊，周而复始？<br>
 你有没有想过，为什么在稍远的距离，二维码扫描就会慢慢放大？<br>
 是的，在这个寒冷的夜，为了能让你的手机更快速的识别出对方的二维码，我们做了很多。</p>
<p>##二维码解读</p>
<p>我们来看一下二维码扫描主要展示信息，主要分为功能图形和编码区格式。其中功能图形的位置探测图形、定位图形、矫正图形在定位的过程中起着举足轻重的地位。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/Mozziehh/mypapers/blob/master/images/qrcode_structure.png?raw=true" alt="" loading="lazy"></figure>
<p>##二维码扫描的源码解读<br>
 从你拿出手机对准二维码直到扫描结束，整个过程都发生了什么？为了能让你生动的了解整个过程，我打算用下面的方式讲：<br>
打开相机执行扫描-&gt;获取Byte流-&gt;灰度-&gt;二值化-&gt;霍夫变换-&gt;找到二维码定位点-&gt;识别-&gt;返回结果。</p>
<p>###打开相机执行扫描</p>
<pre><code>private void initCamera(SurfaceHolder surfaceHolder) {
        if (surfaceHolder == null) {
            throw new IllegalStateException(&quot;No SurfaceHolder provided&quot;);
        }
        if (cameraManager.isOpen()) {
            Log.w(TAG, &quot;initCamera() while already open -- late SurfaceView callback?&quot;);
            return;
        }
        try {
            cameraManager.openDriver(surfaceHolder);
            // Creating the handler starts the preview, which can also throw a
            // RuntimeException.
            if (handler == null) {
                handler = new CaptureActivityHandler(this, cameraManager, DecodeThread.ALL_MODE);
            }

            initCrop();
        } catch (IOException ioe) {
            Log.w(TAG, ioe);
            displayFrameworkBugMessageAndExit();
        } catch (RuntimeException e) {
            // Barcode Scanner has seen crashes in the wild of this variety:
            // java.?lang.?RuntimeException: Fail to connect to camera service
            Log.w(TAG, &quot;Unexpected error initializing camera&quot;, e);
            displayFrameworkBugMessageAndExit();
        }
    }
</code></pre>
<p>###设置支持的二维码类型</p>
<p>目前二维码支持如下类型：<br>
<img src="https://i.loli.net/2019/06/17/5d0734bfd44a794589.png" alt="support-zxing-pic.png" loading="lazy"><br>
代码在这里配置：</p>
<pre><code>// The prefs can't change while the thread is running, so pick them up once here.
    if (decodeFormats == null || decodeFormats.isEmpty()) {
      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
      decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) {
        decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) {
        decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) {
        decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) {
        decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) {
        decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) {
        decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
      }
    }
    hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
</code></pre>
<p>###获取相机预览的Byte流</p>
<pre><code>public class PreviewCallback implements Camera.PreviewCallback {

	private static final String TAG = PreviewCallback.class.getSimpleName();

	private final CameraConfigurationManager configManager;
	private Handler previewHandler;
	private int previewMessage;

	public PreviewCallback(CameraConfigurationManager configManager) {
		this.configManager = configManager;
	}

	public void setHandler(Handler previewHandler, int previewMessage) {
		this.previewHandler = previewHandler;
		this.previewMessage = previewMessage;
	}

	@Override
	public void onPreviewFrame(byte[] data, Camera camera) {
		Point cameraResolution = configManager.getCameraResolution();
		Handler thePreviewHandler = previewHandler;
		if (cameraResolution != null &amp;&amp; thePreviewHandler != null) {
			Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x, cameraResolution.y, data);
			message.sendToTarget();
			previewHandler = null;
		} else {
			Log.d(TAG, &quot;Got preview callback, but no handler or resolution available&quot;);
		}
	}

}

//在这里通过相机框获取bitmap的byte流
PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);

BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

</code></pre>
<p>###对bitmap的byte流解码</p>
<pre><code>if (formats != null) {
  boolean addOneDReader =
	  formats.contains(BarcodeFormat.UPC_A) ||
	  formats.contains(BarcodeFormat.UPC_E) ||
	  formats.contains(BarcodeFormat.EAN_13) ||
	  formats.contains(BarcodeFormat.EAN_8) ||
	  formats.contains(BarcodeFormat.CODABAR) ||
	  formats.contains(BarcodeFormat.CODE_39) ||
	  formats.contains(BarcodeFormat.CODE_93) ||
	  formats.contains(BarcodeFormat.CODE_128) ||
	  formats.contains(BarcodeFormat.ITF) ||
	  formats.contains(BarcodeFormat.RSS_14) ||
	  formats.contains(BarcodeFormat.RSS_EXPANDED);
  // Put 1D readers upfront in &quot;normal&quot; mode
  readers.add(new MultiFormatOneDReader(hints));
  if (formats.contains(BarcodeFormat.QR_CODE)) {
	readers.add(new QRCodeReader(mActivity));
  }
  if (formats.contains(BarcodeFormat.DATA_MATRIX)) {
	readers.add(new DataMatrixReader());
  }
  if (formats.contains(BarcodeFormat.AZTEC)) {
	readers.add(new AztecReader());
  }
  if (formats.contains(BarcodeFormat.PDF_417)) {
	 readers.add(new PDF417Reader());
  }
  if (formats.contains(BarcodeFormat.MAXICODE)) {
	 readers.add(new MaxiCodeReader());
  }
  // At end in &quot;try harder&quot; mode
  readers.add(new MultiFormatOneDReader(hints));

</code></pre>
<h3 id="解码调用接口的实现类">解码，调用接口的实现类</h3>
<pre><code>private Result decodeInternal(BinaryBitmap image) throws NotFoundException {
    if (readers != null) {
      for (Reader reader : readers) {
        try {
          return reader.decode(image, hints);
        } catch (ReaderException re) {
          // continue
        }
      }
    }
    throw NotFoundException.getNotFoundInstance();
  }
// QRCodeReader.java
	@Override
	  public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)
		  throws NotFoundException, ChecksumException, FormatException {
		DecoderResult decoderResult; //解析结果
		ResultPoint[] points; //解析的点
		if (hints != null &amp;&amp; hints.containsKey(DecodeHintType.PURE_BARCODE)) {
		  //二值化：image.getBlackMatrix()
		  BitMatrix bits = extractPureBits(image.getBlackMatrix());
		  decoderResult = decoder.decode(bits, hints);
		  points = NO_POINTS;
		} else {
		  //二值化：image.getBlackMatrix()
		  DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);
		  decoderResult = decoder.decode(detectorResult.getBits(), hints);
		  points = detectorResult.getPoints();
		}

		// If the code was mirrored: swap the bottom-left and the top-right points.
		if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
		  ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);
		}

		Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);
		List&lt;byte[]&gt; byteSegments = decoderResult.getByteSegments();
		if (byteSegments != null) {
		  result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);
		}
		String ecLevel = decoderResult.getECLevel();
		if (ecLevel != null) {
		  result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);
		}
		if (decoderResult.hasStructuredAppend()) {
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,
							 decoderResult.getStructuredAppendSequenceNumber());
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,
							 decoderResult.getStructuredAppendParity());
		}
		return result;
	  }


	/**
	   * &lt;p&gt;Detects a QR Code in an image.&lt;/p&gt;
	   *
	   * @param hints optional hints to detector
	   * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	   * @throws NotFoundException if QR Code cannot be found
	   * @throws FormatException if a QR Code cannot be decoded
	   */
	  public final DetectorResult detect(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException, FormatException {

		resultPointCallback = hints == null ? null :
			(ResultPointCallback) hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);

		FinderPatternFinder finder = new FinderPatternFinder(image, resultPointCallback);
		FinderPatternInfo info = finder.find(hints);

		return processFinderPatternInfo(info);
	  }

</code></pre>
<p>###定位特征点</p>
<pre><code>	final FinderPatternInfo find(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException {
		boolean tryHarder = hints != null &amp;&amp; hints.containsKey(DecodeHintType.TRY_HARDER);
		int maxI = image.getHeight();
		int maxJ = image.getWidth();
		int iSkip = (3 * maxI) / (4 * MAX_MODULES);
		if (iSkip &lt; MIN_SKIP || tryHarder) {
		  iSkip = MIN_SKIP;
		}

		boolean done = false;
		int[] stateCount = new int[5];
		for (int i = iSkip - 1; i &lt; maxI &amp;&amp; !done; i += iSkip) {
		  // Get a row of black/white values
		  clearCounts(stateCount);
		  int currentState = 0;
		  for (int j = 0; j &lt; maxJ; j++) {
			if (image.get(j, i)) {
			  // Black pixel
			  if ((currentState &amp; 1) == 1) { // Counting white pixels
				currentState++;
			  }
			  stateCount[currentState]++;
			} else { // White pixel
			  if ((currentState &amp; 1) == 0) { // Counting black pixels
				if (currentState == 4) { // A winner?
				  if (foundPatternCross(stateCount)) { // Yes
					boolean confirmed = handlePossibleCenter(stateCount, i, j);
					if (confirmed) {
					  iSkip = 2;
					  if (hasSkipped) {
						done = haveMultiplyConfirmedCenters();
					  } else {
						int rowSkip = findRowSkip();
						if (rowSkip &gt; stateCount[2]) {
						  i += rowSkip - stateCount[2] - iSkip;
						  j = maxJ - 1;
						}
					  }
					} else {
					  shiftCounts2(stateCount);
					  currentState = 3;
					  continue;
					}
					// Clear state to start looking again
					currentState = 0;
					clearCounts(stateCount);
				  } else { // No, shift counts back by two
					shiftCounts2(stateCount);
					currentState = 3;
				  }
				} else {
				  stateCount[++currentState]++;
				}
			  } else { // Counting white pixels
				stateCount[currentState]++;
			  }
			}
		  }
		  if (foundPatternCross(stateCount)) {
			boolean confirmed = handlePossibleCenter(stateCount, i, maxJ);
			if (confirmed) {
			  iSkip = stateCount[0];
			  if (hasSkipped) {
				// Found a third one
				done = haveMultiplyConfirmedCenters();
			  }
			}
		  }
		}
	//找到定位点
		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
	  }
</code></pre>
<p>###返回结果</p>
<pre><code>	protected final DetectorResult processFinderPatternInfo(FinderPatternInfo info)
		  throws NotFoundException, FormatException {

		FinderPattern topLeft = info.getTopLeft();
		FinderPattern topRight = info.getTopRight();
		FinderPattern bottomLeft = info.getBottomLeft();

		float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
		if (moduleSize &lt; 1.0f) {
		  throw NotFoundException.getNotFoundInstance();
		}
		int dimension = computeDimension(topLeft, topRight, bottomLeft, moduleSize);
		Version provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
		int modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;

		AlignmentPattern alignmentPattern = null;
		// Anything above version 1 has an alignment pattern
		if (provisionalVersion.getAlignmentPatternCenters().length &gt; 0) {

		  // Guess where a &quot;bottom right&quot; finder pattern would have been
		  float bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
		  float bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();

		  // Estimate that alignment pattern is closer by 3 modules
		  // from &quot;bottom right&quot; to known top left location
		  float correctionToTopLeft = 1.0f - 3.0f / modulesBetweenFPCenters;
		  int estAlignmentX = (int) (topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
		  int estAlignmentY = (int) (topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));

		  // Kind of arbitrary -- expand search radius before giving up
		  for (int i = 4; i &lt;= 16; i &lt;&lt;= 1) {
			try {
			  alignmentPattern = findAlignmentInRegion(moduleSize,
				  estAlignmentX,
				  estAlignmentY,
				  i);
			  break;
			} catch (NotFoundException re) {
			  // try next round
			}
		  }
		}

		PerspectiveTransform transform =
			createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);

		BitMatrix bits = sampleGrid(image, transform, dimension);

		ResultPoint[] points;
		if (alignmentPattern == null) {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight};
		} else {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight, alignmentPattern};
		}
		return new DetectorResult(bits, points);
	  }
</code></pre>
<p>##问题来了<br>
在阅读源码之后，我们发现这里面并没有解读放大相关的功能，这是为什么呢？<br>
是的，因为Zxing库本来就没有提供放大的功能，那么我们想实现放大功能应该怎么做？<br>
对，答案就是利用相机的放大功能setZoom来放大相机即可。<br>
那么，什么时机放大呢？</p>
<p>###相机放大功能和二维码建立关系<br>
为了解决这个放大时机的问题，我们再来回顾一下源码。<br>
有这样一段源码，它的作用是找到定位点：</p>
<pre><code>		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
</code></pre>
<p>那么，我们是不是利用这个定位点，就可以和相机扫描框的间距搞一些事情就可以了？<br>
事实上，网上也有很多例子是这么做的。<br>
行，既然已经有了，那我们直接拿来用就可以了吧？<br>
NONONO，事情并不是那么简单：<br>
<img src="https://i.loli.net/2019/06/17/5d0758dd0179c16484.png" alt="bucunzai.png" loading="lazy"></p>
<p>##58APP二维码扫描的应用<br>
因为58APP，用的不是Java实现的。核心解码流程使用的是C++，通过JNI编译生成的so，然后再打入到58APP里的。<br>
兵来将挡水来土掩，行，既然java实现的思路已经有了，我们就用C++再写一遍怎么了，谁让咱也是科班出身。</p>
<p>###找到核心C++实现<br>
我们发现，是在这里执行的decode，然后也是调用了decodeWithState，然后将得到的结果返回给java。<br>
仔细跟进去，发现逻辑差不多，只不过一个是用java，一个是用C++。</p>
<pre><code>jbyte *yuvData = env-&gt;GetByteArrayElements(yuvData_, NULL);

    std::string codeResult = &quot;&quot;;
    try {
        ......
		省略部分代码
        // Perform the decoding.
        MultiFormatReader reader;
        reader.setHints(hints);
        Ref&lt;Result&gt; result(reader.decodeWithState(image));

        // Output the result.
        codeResult = result-&gt;getText()-&gt;getText();
        cout &lt;&lt; result-&gt;getText()-&gt;getText() &lt;&lt; endl;
    } catch (zxing::Exception&amp; e) {
        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;
    }

    env-&gt;ReleaseByteArrayElements(yuvData_, yuvData, 0);

    return env-&gt;NewStringUTF(codeResult.c_str());
</code></pre>
<p>###QRCodeReader.cpp核心实现</p>
<p>下面就是decode使用c++的核心实现，因为前面已经讲过了Java的实现，所以这里找到C++的代码也是非常容易的<br>
这里我们看到，有一句</p>
<pre><code>	Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
</code></pre>
<p>它的意思就是通过detect得到了detectorResult，然后通过下面的，</p>
<pre><code>	ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
</code></pre>
<p>得到了points，即定位点；<br>
一开始我想着把这个定位点独立出一个方法，然后再通过回调的形式传递给Java层，这样做的好处就是我们可以通过Java来实现放大功能。但是因为我们相机预览的速度是特别快的，所以这样做其实并不合适。于是，把相机的参数传递进去，然后在C++里面完成对于相机的放大。</p>
<pre><code>QRCodeReader::QRCodeReader() :decoder_() {
		}
		//TODO: see if any of the other files in the qrcode tree need tryHarder
		Ref&lt;Result&gt; QRCodeReader::decode(Ref&lt;BinaryBitmap&gt; image, DecodeHints hints) {
			Detector detector(image-&gt;getBlackMatrix());
			Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
			ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
			Ref&lt;DecoderResult&gt; decoderResult(decoder_.decode(detectorResult-&gt;getBits()));
			Ref&lt;Result&gt; result(
							   new Result(decoderResult-&gt;getText(), decoderResult-&gt;getRawBytes(), points, BarcodeFormat::QR_CODE));
			return result;
		}
</code></pre>
<p>###传递Java的Camera对象<br>
主要是在原来的基础上多传递了扫描框的位置和Camera这个对象：</p>
<pre><code>	xxx_QbarNative_decode(JNIEnv *env, jobject instance, jbyteArray bytes_, jint width,
										  jint height, jint cropLeft, jint cropRight, jint cropTop,
										  jint cropWidth, jint cropHeight, jboolean reverseHorizontal,
										  jobject camera, jobject parameters)
</code></pre>
<p>###放大代码使用C++实现<br>
最后，根据参数进行实现：简单的说就是判断二维码定位点的距离，然后用这个距离和相框之间的距离做个比对，小于一半，我们递增。</p>
<pre><code>	//执行检测逻辑，检测得到执行放大照相机逻辑，否则执行解析逻辑
	if(NULL != resultPoints &amp;&amp; !(resultPoints-&gt;empty())){
		//省去部分核心代码

		if(isZoomSupported){
		//这里做了简化，主要解决放大倍数过多，使得二维码突然不在扫描框里。
			if (len &lt;= frameWidth / 2){
				if(zoom &lt; maxZoom){
					zoom = zoom + 8;
				}else{
					zoom = maxZoom;
				}
				jmethodID setZoomMth = env-&gt;GetMethodID(parametersCls, &quot;setZoom&quot;, &quot;(I)V&quot;);
				env-&gt;CallVoidMethod(parameters, setZoomMth, zoom);

				jmethodID setParametersMth = env-&gt;GetMethodID(camearCls, &quot;setParameters&quot;, &quot;(Landroid/hardware/Camera$Parameters;)V&quot;);
				env-&gt;CallVoidMethod(camera, setParametersMth, parameters);

				env-&gt;ReleaseByteArrayElements(bytes_, yuvData, 0);
				string ss = strStream.str();
			}
		}
	}
</code></pre>
<p>###导出so，打入58APP<br>
最后，在demo中运行一下，看看效果。<br>
<img src="https://i.loli.net/2019/06/17/5d077e8e60ec060459.gif" alt="1557793019816360 (1).gif" loading="lazy"></p>
<p>##心得<br>
其实最终解决这个问题不难，重点在于发现问题，解决问题的过程学到了什么。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手把手教你如何不刷机Hook代码]]></title>
        <id>https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma/</id>
        <link href="https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma/">
        </link>
        <updated>2019-11-22T00:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>##1. 背景</p>
<blockquote>
<p>前几个月，我们同TEG的同学一起排查一个问题：B端用户使用黑产提供的软件来Hook我们的API，达到在发送IM消息时发送自定义消息的目的，比如：在tips里面弹出，“淘宝客服，日结300，加V xxxxxxx”</p>
</blockquote>
<blockquote>
<p>带着一颗强烈的好奇心，我走进了Xposed的世界，发现原来Android的世界还可以如此精彩。</p>
</blockquote>
<p>##2. Xposed-从入门到放弃<br>
提起Xposed，可能很多人都听过它的名字，知道它是什么。</p>
<p>但是具体再深挖一下，它的原理是什么，可能大家就会回答的很模糊。</p>
<p>如果再深挖一下，const u2* insns是干什么用的？</p>
<p>如何再涉及到实践，如何Hook一个私有方法？</p>
<p>相信大家心里就会说：“这跟我有什么关系~~”</p>
<p>对的，一开始我也是这样的。但是一步步走下来，你会发现这个东西根本没那么难。那么，就跟我一起来学习下这块的相关知识吧。</p>
<p>###2.1 什么是Xpose？<br>
Xposed 框架是一款可以在不修改 APK 的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作，在这个框架下，我们可以加载很多插件 App ，这些插件 App 可以直接或间接劫持、篡改、伪造一些信息。</p>
<p>###2.2 它的原理是什么？</p>
<p>####2.2.1 Xposed资源<br>
·XposedBridge.jar：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。</p>
<p>·Xposed：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p>·XposedInstaller：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。</p>
<p>·XposedMods：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<p>####2.2.2 Zygote<br>
在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。</p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<p>####2.2.3 Hook<br>
在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
<p>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。在hookMethodNative的实现中，会调用XposedBridge中的handleHookedMethod这个方法来传递参数。handleHookedMethod这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是xposedCallHandler。而handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数，并调用他们的before, after函数。</p>
<p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：</p>
<p>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
<p>###2.3 为什么后来又放弃了？<br>
研究了一段时间之后，寻思就开始上手吧。<br>
####2.3.1 刷机成本<br>
Xposed是需要root手机的，于是就开始研究刷机，我手里有两个锤子手机，其中一个呢，已经被我彻底刷成了“锤子”，平时砸个核桃啥的用起来还算是顺手。另外一个，刷完之后，我手机里面的东西还都需要重新安装，有些APK是市场上已经找不到了。而且，我们目前使用的手机，主流的小米、OPPO、VIVI、华为，这些手机的刷机方式已经不再像原来那样简单，下载一个安装包，同时按住电源键+ Home + 音量“+”等一会那么简单了。而且刷完之后，不是NFC不好用，就是WIFI坏了。要是没有一款可要可不要的闲置手机，真的不建议刷。<br>
####2.3.2 脱壳也是一件麻烦事<br>
接下来再想，我们突破了种种困难，完成了刷机。但是当我们需要Hook方法的时候又会犯难，因为现在加壳的APK，反编译之后外面就一两个类，根本无从下手，还需要再研究脱壳。</p>
<p>渐渐地，我就发现原本我的目标：想看看如何模拟黑产去Hook一个API，但是这样的路让我越走越远。方向没错，但是不禁觉得这是在浪费时间。难道就真的没有办法了么？</p>
<p>接下来就来介绍一下，今天的猪脚，Virtual Xposed~~<br>
##3. Virutal Xposed<br>
对于我这样的“刚需”，它是一款神器。为什么，首先它不需要刷机，它的脱壳也是非常的简单。就这么简单的两点，完全解决了我的痛点。<br>
###3.1 它与Xposed从原理上的区别<br>
VirtualXposed 并未对系统底层进行任何修改，也没有利用什么神奇的漏洞。它的工作原理有点像那些双开软件。</p>
<p>VirtualXposed 是通过在你的手机里创建一个「虚拟环境」，然后在此虚拟环境中启用 Xposed。</p>
<p>###3.2 FDex2</p>
<p>###3.3 Demo<br>
##偷偷搞一波58试试</p>
<p>参考文章：<br>
http://yx.bsh.me/23278.html<br>
https://mp.weixin.qq.com/s/PG7ykzTWkw4tARjp0yKeAQ<br>
https://mp.weixin.qq.com/s/AlZMhMZ-SFOxRMtXfcev1g<br>
https://blog.csdn.net/ascii2/article/details/47974217<br>
https://blog.csdn.net/wxyyxc1992/article/details/17320911</p>
]]></content>
    </entry>
</feed>