<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Mozziehh.github.io</id>
    <title>差不多胡先生</title>
    <updated>2019-12-14T03:22:42.705Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Mozziehh.github.io"/>
    <link rel="self" href="https://Mozziehh.github.io/atom.xml"/>
    <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
    <logo>https://Mozziehh.github.io/images/avatar.png</logo>
    <icon>https://Mozziehh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 差不多胡先生</rights>
    <entry>
        <title type="html"><![CDATA[Android开源框架分析系列之-Fresco]]></title>
        <id>https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco</id>
        <link href="https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco">
        </link>
        <updated>2019-12-14T02:43:38.000Z</updated>
        <content type="html"><![CDATA[<p>##为什么选择Fresco<br>
1、它是Facebook出品的开源库，避免重复造轮子；</p>
<p>2、Fresco 支持 Android2.3(API level 9) 及其以上系统,基本上可以含盖目前市场上的绝大部分android手机，我们目前的支持的最低版本android 4.0(API level 14);</p>
<p>3、在5.0以下系统，Fresco将图片放到一个特别的内存共享区域（ashmem）。在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
<p>4、使用简单，一行代码setImageURI()就可以加载图片和显示；</p>
<p>5、支持三级缓存，Bitmap缓存、未解码图片缓存、文件缓存；</p>
<p>6、对okHttp和volley网络库的兼容，目前我们项目中使用的是volley网络库，可以灵活配置；</p>
<p>7、支持的图片格式有jpg/jpeg、png、jpeg图片的渐进式呈现、gif、webP；</p>
<p>##带着问题看文章<br>
按照国际惯例，请先阅读如下题目，如果你会了，那么就可以关闭文章了：</p>
<p>1、Fresco和Glide的对比？（大小、加载生命周期、图片格式、旋转裁减、缓存方式）</p>
<p>2、DraweeView中成员变量DraweeHolder与DraweeHierarchy与DraweeController三者之间的关系？</p>
<p>3、当view被从ViewGroup临时分离时回调，执行了Fresco的哪个方法？</p>
<p>4、Fresco加载图片的几种方式？（Center.CENTER_INSIDE、Fit.CENTER等）</p>
<p>5、Fresco在管理ashmem区域采用了哪种方式回收内存？</p>
<p>6、Fresco在加载图片时，为了缓解OOM除了采用ashmem，还有什么策略？采样的策略是如何做的？</p>
<p>7、Fresco内部使用LRU算法维护图片池，那么对于那些不经常变动但是需要常驻的图片，Fresco可以怎么处理？</p>
<p>8、Fresco内部是如何获取本地缓存路径的？<br>
##它和Glide的对比<br>
###包大小&amp;复杂度<br>
fresco的包比较复杂，因此Facebook将其拆分成几个不同的aar库，可根据需要分别加载依赖，大小3M左右。</p>
<p>glide包还好，除okhttp拆分出单独的aar包外，其他功能均在一个aar包中。glide拆分出了单独的图片处理库，可以支持对图片的裁剪，旋转，模糊和滤镜等操作，大小300KB左右。</p>
<p>###影响一次图片加载过程的生命周期对象（即一次图片加载受谁的生命周期控制影响）<br>
fresco：图片的加载受view生命周期的影响</p>
<p>glide：图片的加载受context的生命周期影响，context可以是fragment、activity、application。</p>
<p>###支持的图片格式<br>
fresco：png、jpeg、webp、gif、jfif；<br>
glide：png、jpeg、webp、gif。</p>
<p>###支持图片的旋转和裁剪<br>
fresco和glide均支持图片的旋转和裁剪。</p>
<p>fresco：</p>
<p>图片旋转：</p>
<p>imageRequestBuilder.setRotationOptions(RotationOptions.forceRotation(RotationOptions.ROTATE_90));</p>
<p>图片的裁剪：</p>
<p>imageRequestBuilder.setResizeOptions(new ResizeOptions(reqWidth, reqHeight));</p>
<p>glide：</p>
<p>图片的旋转：</p>
<p>创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new RotateTransformation( context, 90f )).into( imageView);</p>
<p>图片的裁剪：</p>
<p>a、直接使用override(imageWidth, imageWidth)方法，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).override(imageWidth, imageWidth).into( imageView);</p>
<p>b、创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new ResizeTransformation( context, width,height )).into( imageView);</p>
<h3 id="缓存方式">缓存方式</h3>
<p>fresco：三级缓存：二级内存缓存 + 磁盘文件缓存，只有第一级内存缓存在UI线程中操作，其他均在io线程中</p>
<p>fresco二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、png、jpeg等格式的文件缓存，需要解码成bitmap对象。</p>
<p>glide：二级内存缓存（严格意义上来说只有一级，第二级可以忽略）加磁盘文件缓存，内存缓存均在UI线程中，磁盘缓存在io线程中操作。</p>
<p>glide二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、WeakReference(bitmap)缓存，即弱引用bitmap对象缓存。</p>
<h3 id="代码侵入式">代码侵入式</h3>
<p>fresco在使用的时候基本都要引入其封装的DraweeView，代码侵入性很强。glide代码侵入性相比不强。</p>
<p>##Fresco架构<br>
<img src="https://Mozziehh.github.io/post-images/1576291547391.png" alt=""></p>
<p>DraweeView中成员变量DraweeHolder主要用于控制逻辑层，DraweeHolder包含DraweeHierarchy和DraweeController，DraweeHierarchy用于存储图像，DraweeController用于控制显示图像，为什么把DraweeHierarchy和DraweeController封装到DraweeHolder 中呢？是为了解藕，通过DraweeHolder可以方便的使用这两个组件。DraweeView 把获得的 Event 转发给 Controller，然后 Controller 根据 Event 来决定是否需要显示和隐藏 （包括动画）图像，而这些图像都存储在 Hierarchy 中，最后 DraweeView 绘制时直接通过 getTopLevelDrawable 就可以获取需要显示的图像。</p>
<p>##Fresco核心显示处理<br>
看一下DraweeView重写了View的四个方法：<br>
@Override<br>
protected void onAttachedToWindow() {<br>
super.onAttachedToWindow();<br>
mDraweeHolder.onAttach();<br>
}</p>
<pre><code>@Override
protected void onDetachedFromWindow() {
super.onDetachedFromWindow();
mDraweeHolder.onDetach();
}

@Override
public void onStartTemporaryDetach() {
super.onStartTemporaryDetach();
mDraweeHolder.onDetach();
}

@Override
public void onFinishTemporaryDetach() {
super.onFinishTemporaryDetach();
mDraweeHolder.onAttach();
}
</code></pre>
<p>onAttachedToWindow 是view 本身的回调，当view 被添加到window中，被绘制之前的回调。如addview（this view）；<br>
onDetachedFromWindow 是view 本身的回调，当view被从window中删除时的回调。如 removeview（this view）;<br>
onStartTemporaryDetach 是view本身的回调，当view被从ViewGroup临时分离时回调，如listview中的item移出屏幕时；<br>
onFinishTemporaryDetach 是view本身的回调，当view在回调onStartTemporaryDetach完成改变后，再次添加到ViewGroup时回调，如listview中复用的item划入屏幕时；<br>
DraweeView通过这个两对方法来保证当view移出屏幕容器和添加进入屏幕容器时来调用mDraweeHolder.onAttach()和mDraweeHolder.onDetach()来保证显示图片的逻辑的，mDraweeHolder.onAttach()就是从Controller中获取要现实的图片资源显示，mDraweeHolder.onAttach()就是释放资源，具体实现可以跟一下源码查看；</p>
<p>##fresco对内存缓存策略</p>
<p>Fresco的内存缓存策略是根据android系统版本不同做了不同处理，5.0以下系统：图片不存储在Java heap，而是存储在ashmem，中间的字节 buffer同样位于native heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆 内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统 Fresco将Bitmap缓存直接放到了堆内存中。</p>
<p>关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种 为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性inPurgeable：</p>
<pre><code>BitmapFactory.Options = new BitmapFactory.Options();
options.inPurgeable = true;
Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);
</code></pre>
<p>所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。</p>
<p>既然Fresco中Bitmap缓存在5.0以下是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收 它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个 SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方 法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提 供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同 时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在 调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与 CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：</p>
<p>1）在赋值CloseableReference给新对象的时候，调用.clone()进行赋值</p>
<p>2）在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用</p>
<p>##图片采样处理<br>
为防止使用者对图片的大小没有概念或者直接加载过大图片时造成内存溢出的风险加大，按照经验统一了三个采样标准：<br>
DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.BIG_TYPE</p>
<p>##对于那些不经常变动的图片，我们应该怎么处理；</p>
<p>当我们有些图片不经常动时需要能长时间保存，但如果放入同一个本地缓存文件下时，随着不断加载图片到文件缓存设定上限时，根据LruCach的规则，需要长时间保存的图片可能就会被清除掉，那这就不满足我们的需求了，应该怎么处理呢？</p>
<p>1）强大的fresco已经给我们提供了解决方案，引用官网资料：<br>
用一个文件还是两个文件缓存?<br>
如果要使用2个缓存，在配置image pipeline 时调用 setMainDiskCacheConfig 和 setSmallImageDiskCacheConfig 方法即可。大部分的应用有一个文件缓存就够了，但是在一些情况下，你可能需要两个缓存。比如你也许想把小文件放在一个缓存中，大文件放在另外一个文件中，这样小文件就不会因大文件的频繁变动而被从缓存中移除。<br>
至于什么是小文件，这个由应用来区分，在创建image request, 设置 ImageType 即可:<br>
ImageRequest request = ImageRequest.newBuilderWithSourceUri(uri)<br>
.setImageType(ImageType.SMALL)</p>
<p>如果你仅仅需要一个缓存，那么不调用setSmallImageDiskCacheConfig即可。Image pipeline 默认会使用同一个缓存，同时ImageType也会被忽略。</p>
<p>2）实现方法：</p>
<pre><code>配置
DiskCacheConfig diskCacheConfig = DiskCacheConfig.newBuilder()            
.setBaseDirectoryName()//设置主缓存目录文件名
.setBaseDirectoryPath()//设置主缓存目录根目录
.setMaxCacheSize()//设置主缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置主缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置主缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();
DiskCacheConfig smallDiskCacheConfig = DiskCacheConfig.newBuilder()
.setBaseDirectoryName()//设置次缓存目录文件名
.setBaseDirectoryPath()//设置次缓存目录根目录
.setMaxCacheSize()//设置次缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置次缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置次缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();

ImagePipelineConfig pipelineConfig = ImagePipelineConfig.newBuilder(mContext)
.setSmallImageDiskCacheConfig(smallDiskCacheConfig)//磁盘缓存配置，存储首页图片的配置（总，三级缓存）
.setMainDiskCacheConfig(diskCacheConfig)//磁盘缓存配置（总，三级缓存）
.setCacheKeyFactory(new CdnAwareCacheKeyFactory())//uri匹配策略，目前只匹配path，就是为了避免cdn图片会多次请求
.build();
</code></pre>
<p>自定义WubaDraweeView控件中添加缓存到次缓存目录的方法；</p>
<pre><code>public void setSmallDiskImageURI(Uri uri){
ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)
.setImageType(ImageRequest.ImageType.SMALL)
.build();
DraweeController controller = FrescoWubaCore.newDraweeControllerBuilder()
.setImageRequest(request)
.setOldController(getController())
.build();
setController(controller);
}
</code></pre>
<p>对于需要不经常变动需要长时间保存的可以使用以上方法；<br>
目前ImageRequest.ImageType只支持两种，以下是fresco源码，Default是默认的回放入DiskCacheConfig，根据类型选择disk缓存策略，源码：</p>
<pre><code>/**    * An enum describing type of the image.
*/
public enum ImageType {
/* Indicates that this image should go in the small disk cache, if one is being used */
SMALL,

/* Default */
DEFAULT,
}

public void produceResults(
final Consumer&lt;EncodedImage&gt; consumer,
final ProducerContext producerContext) {
ImageRequest imageRequest = producerContext.getImageRequest();
if (!imageRequest.isDiskCacheEnabled()) {
maybeStartInputProducer(consumer, consumer, producerContext);
return;
}

producerContext.getListener().onProducerStart(producerContext.getId(), PRODUCER_NAME);

final CacheKey cacheKey =
    mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());
boolean isSmallRequest = (imageRequest.getImageType() == ImageRequest.ImageType.SMALL);
final BufferedDiskCache preferredCache = isSmallRequest ?
    mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;//根据类型选择disk缓存；
</code></pre>
<p>......</p>
<p>##如何获取本地缓存路径？<br>
有时我们将需要fresco已加载的图片的本地路径获取到，然后对本地路径作处理，获取方法：<br>
1）判断图片的uri是否已缓存；</p>
<pre><code>/**
* 判断是否已缓存本地
* @param loadUri
* @return
*/
private boolean isDownloaded(Uri loadUri) {
    if (loadUri == null) {
        return false;
    }
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    return ImagePipelineFactory.getInstance()
            .getMainFileCache().hasKey(cacheKey);
}
</code></pre>
<p>2）如果已缓存可获取本地路径</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>@Override
public boolean hasKey(final CacheKey key) {
synchronized (mLock) {
    if (hasKeySync(key)) {
    return true;
    }
    try {
    String resourceId = null;
    boolean retval = false;
    if (mIndex.containsKey(key)) {
        resourceId = mIndex.get(key);
        retval = mStorage.contains(resourceId, key);
    } else {
        List&lt;String&gt; resourceIds = getResourceIds(key);
        for (int i = 0; i &lt; resourceIds.size(); i++) {
        resourceId = resourceIds.get(i);
        retval = mStorage.contains(resourceId, key);
        if (retval) {
            break;
        }
        }
    }
    if (retval) {
        mIndex.put(key, resourceId);
    } else {
        mIndex.remove(key);
    }
    return retval;
    } catch (IOException e) {
    return false;
    }
}
}
@VisibleForTesting
static List&lt;String&gt; getResourceIds(final CacheKey key) {
try {
    final List&lt;String&gt; ids;
    if (key instanceof MultiCacheKey) {
    List&lt;CacheKey&gt; keys = ((MultiCacheKey) key).getCacheKeys();
    ids = new ArrayList&lt;&gt;(keys.size());
    for (int i = 0; i &lt; keys.size(); i++) {
        ids.add(SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;)));
    }
    } else {
    ids = new ArrayList&lt;&gt;(1);
    ids.add(SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes(&quot;UTF-8&quot;)));
    }
    return ids;
} catch (UnsupportedEncodingException e) {
    // This should never happen. All VMs support UTF-8
    throw new RuntimeException(e);
}
}

public static String makeSHA1HashBase64(byte[] bytes) {
try {
    MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);
    md.update(bytes, 0, bytes.length);
    byte[] sha1hash = md.digest();
    return Base64.encodeToString(sha1hash, Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP);
} catch (NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
}
}
</code></pre>
<p>可以看出CachKey的匹配规则时，调用SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;))用UTF－8对CachKey的toString值encode，然后用SHA-1算法加密获取摘要，再用Base64 encode成字符串来进行比较的，所以关键方法时CachKey的toString方法，一切操作都是基于这个方法生成的；</p>
<p>##为降低OOM风险，我们应该向下采样Downsampling，设置setResizeOptions</p>
<p>###向下采样如何配置；<br>
向下采样是一个正在实验中的特性。使用的话需要在设置 image pipeline 时进行设置：<br>
.setDownsampleEnabled(true)<br>
如果开启该选项，pipeline 会向下采样你的图片， 同时需要设置setResizeOptions 。<br>
如果不开启该项，设置setResizeOptions，只有JPEG图片格式才起作用；<br>
向下采样在大部分情况下比 resize 更快。除了支持 JPEG 图片，它还支持 PNG 和 WebP(除动画外) 图片；</p>
<p>###自定义向下采样的方法；</p>
<pre><code>/**
* 根据图片的uri、屏幕要显示图片的宽高来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeWidth 图片要显示的宽 单位px
* @param resizeHeight 图片要显示的高 单位px
* @param uri 图片的uri
*
*/
public void setResizeOptionsImageURI(@Nullable Uri uri,int resizeWidth,int resizeHeight){
    LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeWidth=&quot;+resizeWidth+&quot;,resizeHeight=&quot;+resizeHeight);
    ImageRequest imageRequest = null;
    if (uri == null){
        LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == uri is null&quot;);
    }else {
        ResizeOptions options = null;
        if (resizeHeight&gt;0&amp;&amp;resizeWidth&gt;0) {
            options = new ResizeOptions(resizeWidth, resizeHeight);
        }else{
            LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeHeight &lt; 0 or resizeWidth &lt; 0&quot;);
        }
        imageRequest = ImageRequestBuilder.newBuilderWithSource(uri)
                .setResizeOptions(options)
                .build();
    }
    setControllerWithParams(imageRequest,null);
}
/**
* 根据图片的uri、屏幕要显示图片采样类型的来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeOptionsType 图片采样类型，DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE/MIDDLE_TYPE/BIG_TYPE；
* @param uri 图片的uri
*
*/
public void setResizeOptionsTypeImageURI(Uri uri,int resizeOptionsType){
    setResizeOptionsImageURI(uri, WubaResizeOptionsUtil.getNewResizeOptionsByType(resizeOptionsType));
}
</code></pre>
<p>###自定义向下采样的类型有三种，大中小；<br>
根据项目中使用图片宽高频率较多的情况分为三种：</p>
<pre><code>/**
* 根据图片的采样类型获取ResizeOptions对象；
* @param resizeOptionsType 图片的采样类型
*/
public static ResizeOptions getNewResizeOptionsByType(int resizeOptionsType){
    int width = 0;
    int height = 0;
    switch (resizeOptionsType){
        case DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE:
            width = 200;
            height = 150;
            break;
        case DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE:
            width = 360;
            height = 300;
            break;
        case DefaultConfigCentre.ResizeOptionsType.BIG_TYPE:
            width = 720;
            height = 600;
            break;
        default:
            checkResizeOptionsType(resizeOptionsType);
            break;

    }
    return new ResizeOptions(width,height);
}
</code></pre>
<p>###默认向下采样类型；<br>
如果我们不设置向下采样的类型，那默认我们会采用DefaultConfigCentre.ResizeOptionsType.BIG_TYPE，是为了预防图片太大，我们默认处理造成OOM的情况；</p>
<pre><code>@Override
public void setImageURI(Uri uri, @Nullable Object callerContext) {
    setResizeOptionsTypeImageURI(uri,DefaultConfigCentre.ResizeOptionsType.BIG_TYPE);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java知识体系之-泛型与泛型擦除]]></title>
        <id>https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu</id>
        <link href="https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu">
        </link>
        <updated>2019-12-06T05:59:36.000Z</updated>
        <content type="html"><![CDATA[<p>#Java泛型与进阶<br>
##什么是泛型<br>
泛型是Java中一种常用的用于解决编译期间的类型转换异常的方式，防止在运行期间出现classCastException。</p>
<p>代码如下：</p>
<pre><code>public class GlmapperGeneric&lt;T&gt; {
		private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
  
    public static void main(String[] args) {
        // do nothing
    }

  /**
    * 不指定类型
    */
  public void noSpecifyType(){
    GlmapperGeneric glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 需要强制类型转换
    String test = (String) glmapperGeneric.get();
    System.out.println(test);
  }

  /**
    * 指定类型
    */
  public void specifyType(){
    GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 不需要强制类型转换
    String test = glmapperGeneric.get();
    System.out.println(test);
  }
}
</code></pre>
<p>##泛型中的通配符<br>
在泛型中，通常使用的通配符有如下几种：T，E，K，V ？ ，这些符号你可以自己指定，但是为了更好的理解，我们通常使用上述作为默认规则。<br>
T：代表指定的Java类型；<br>
E：代表Element；<br>
K和V：用于在Map中存储的key-value；<br>
？：代表不确定的Java类型；</p>
<p>###？通配符<br>
我们先来看一个例子：List&lt;? extend Animals&gt; list = new List();<br>
此时，它表示的意思就是我们的这个list可以传递的就是继承了Animals的子类；</p>
<p>###上届通配符<br>
所谓的上届通配符就是&lt; ? extends E&gt;，代表的意思是传递任意一个E本身或者E的子类都OK。<br>
###下届通配符<br>
所谓的下届通配符就是&lt; ? super E&gt;，代表的意思是传递任意一个是E本身或者E的父类都OK。</p>
<pre><code>private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src){
    for (T t : src) {
        dst.add(t);
    }
}

public static void main(String[] args) {
    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();
    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();
    new Test3().test(animals,dogs);
}
// Dog 是 Animal 的子类
class Dog extends Animal {

}
</code></pre>
<p>###？和T的区别<br>
从字面的意思上来看：？代表的是非指定的任意Java类，T代表的是指定的Java类，T只可以继承某个类，而？可以标识父类或者子类：? extend A , ? super A。</p>
<p>##泛型擦除</p>
<pre><code>// 指定泛型为String

List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
// 指定泛型为Integer
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();

System.out.println(list1.getClass() == list2.getClass()); // true
</code></pre>
<p>在编译时，对于这些已经指定过的泛型，编译器会将它们都清除掉，这样的操作我们叫做泛型擦除。<br>
规则：如果我们给泛型指定了上届，那么在擦除之后，它会指定到上届。否则，它将指定到Object。</p>
<p>##参考地址</p>
<p>https://juejin.im/post/5d5789d26fb9a06ad0056bd9</p>
<p>https://juejin.im/post/5ceba1a2f265da1b95703558</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-线程池[转]]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan">
        </link>
        <updated>2019-12-05T12:46:45.000Z</updated>
        <content type="html"><![CDATA[<p>#线程池概念<br>
线程池： 简单理解，它就是一个管理线程的池子。</p>
<p>#带着问题看文章<br>
问题1：Java的线程池说一下，各个参数的作用，如何进行的?<br>
问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。<br>
问题3：线程池都有哪几种工作队列？<br>
问题4：使用无界队列的线程池会导致内存飙升吗？<br>
问题5：说说几种常见的线程池及使用场景?</p>
<p>#线程池的优点<br>
·它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗：<br>
因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。<br>
·提高响应速度：<br>
如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。<br>
·重复利用：<br>
线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
<p>#线程池的创建<br>
线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue&lt;Runnable&gt; workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) 
</code></pre>
<p>corePoolSize： 线程池核心线程数最大值<br>
maximumPoolSize： 线程池最大线程数大小<br>
keepAliveTime： 线程池中非核心线程空闲的存活时间大小<br>
unit： 线程空闲存活时间单位<br>
workQueue： 存放任务的阻塞队列<br>
threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。<br>
handler：  线城池的饱和策略事件，主要有四种类型。</p>
<p>#任务执行<br>
线程池执行流程，即对应execute()方法：<br>
<img src="https://Mozziehh.github.io/post-images/1575550465980.png" alt=""></p>
<p>·提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。<br>
·如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。<br>
·当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达·到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。<br>
·如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p>
<p>#四种拒绝策略<br>
·AbortPolicy(抛出一个异常，默认的)<br>
·DiscardPolicy(直接丢弃任务)<br>
·DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）<br>
·CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p>
<p>#为了形象描述线程池执行，我打个比喻：</p>
<p>·核心线程比作公司正式员工<br>
·非核心线程比作外包员工<br>
·阻塞队列比作需求池<br>
·提交任务比作提需求</p>
<figure data-type="image" tabindex="1"><img src="https://Mozziehh.github.io/post-images/1575550700308.png" alt=""></figure>
<p>·当产品提个需求，正式员工（核心线程）先接需求（执行任务）<br>
·如果正式员工都有需求在做，(即核心线程数已满），产品就把需求先放需求池（阻塞队列）。<br>
·如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。<br>
·如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。<br>
·如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</p>
<p>##问题1 Java的线程池说一下，各个参数的作用，如何进行的?</p>
<p>答案：线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</p>
<p>#线程池异常处理</p>
<p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<p>#线程池exec.submit(runnable)的执行流程</p>
<p>通过debug上面有异常的submit方法（建议大家也去debug看一下,图上的每个方法内部是我打断点的地方），处理有异常submit方法的主要执行流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://Mozziehh.github.io/post-images/1575551509586.png" alt=""></figure>
<p>#线程池的工作队列<br>
##线程池都有哪几种工作队列？</p>
<p>·ArrayBlockingQueue:（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<p>·LinkedBlockingQueue:（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p>
<p>·DelayQueue:是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<p>·PriorityBlockingQueue:（优先级队列）是具有优先级的无界阻塞队列；</p>
<p>·SynchronousQueue:（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，</p>
<p>·newCachedThreadPool线程池使用了这个队列。</p>
<p>#几种常用的线程池</p>
<p>##newFixedThreadPool (固定数目线程的线程池)<br>
##newCachedThreadPool(可缓存线程的线程池)<br>
##newSingleThreadExecutor(单线程的线程池)<br>
##newScheduledThreadPool(定时及周期执行的线程池)</p>
<p>##newFixedThreadPool<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory);
    }
</code></pre>
<p>###线程池特点：<br>
核心线程数和最大线程数大小一样<br>
没有所谓的非空闲时间，即keepAliveTime为0<br>
阻塞队列为无界队列LinkedBlockingQueue</p>
<p>####工作机制：<br>
<img src="https://Mozziehh.github.io/post-images/1575555765273.png" alt=""></p>
<p>####提交任务<br>
如果线程数少于核心线程，创建核心线程执行任务<br>
如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列<br>
如果线程执行完任务，去阻塞队列取任务，继续执行。</p>
<p>####实例代码</p>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);
                for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
                    executor.execute(()-&gt;{
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException e) {
                            //do nothing
                        }
        });
</code></pre>
<p>####使用场景<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<p>###newCachedThreadPool</p>
<p>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {<br>
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>
60L, TimeUnit.SECONDS,<br>
new SynchronousQueue<Runnable>(),<br>
threadFactory);<br>
}<br>
####线程池特点：<br>
核心线程数为0<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是SynchronousQueue<br>
非核心线程空闲存活时间为60秒</p>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。<br>
工作机制<br>
<img src="https://Mozziehh.github.io/post-images/1575555947765.png" alt=""></p>
<p>####提交任务<br>
因为没有核心线程，所以任务直接加到SynchronousQueue队列。<br>
判断是否有空闲线程，如果有，就去取出任务执行。<br>
如果没有空闲线程，就新建一个线程执行。<br>
执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newCachedThreadPool();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
用于并发执行大量短期的小任务。</p>
<p>###newSingleThreadExecutor</p>
<p>public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {<br>
return new FinalizableDelegatedExecutorService<br>
(new ThreadPoolExecutor(1, 1,<br>
0L, TimeUnit.MILLISECONDS,<br>
new LinkedBlockingQueue<Runnable>(),<br>
threadFactory));<br>
}<br>
####线程池特点</p>
<p>核心线程数为1<br>
最大线程数也为1<br>
阻塞队列是LinkedBlockingQueue<br>
keepAliveTime为0</p>
<p>####工作机制</p>
<p>####提交任务<br>
线程池是否有一条线程在，如果没有，新建线程执行任务<br>
如果有，讲任务加到阻塞队列<br>
当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newSingleThreadExecutor();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<p>###newScheduledThreadPool</p>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
</code></pre>
<p>####线程池特点<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是DelayedWorkQueue<br>
keepAliveTime为0<br>
scheduleAtFixedRate() ：按某种速率周期执行<br>
scheduleWithFixedDelay()：在某个延迟后执行</p>
<p>####工作机制<br>
添加一个任务<br>
线程池中的线程从 DelayQueue 中取任务<br>
线程从 DelayQueue 中获取 time 大于等于当前时间的task<br>
执行完后修改这个 task 的 time 为下次被执行的时间<br>
这个 task 放回DelayQueue队列中</p>
<p>####实例代码<br>
/**<br>
创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间<br>
*/<br>
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);<br>
scheduledExecutorService.scheduleWithFixedDelay(()-&gt;{<br>
System.out.println(&quot;current Time&quot; + System.currentTimeMillis());<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
}, 1, 3, TimeUnit.SECONDS);</p>
<p>####运行结果：</p>
<pre><code>/**
创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) 
*/
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
        System.out.println(&quot;current Time&quot; + System.currentTimeMillis());
        System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
    }, 1, 3, TimeUnit.SECONDS);;
</code></pre>
<p>####使用场景<br>
周期性执行任务的场景，需要限制线程数量的场景</p>
<p>##线程池状态<br>
线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。<br>
//线程池状态<br>
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;<br>
复制代码线程池各个状态切换图：<br>
<img src="https://Mozziehh.github.io/post-images/1575556444104.png" alt=""></p>
<p>###RUNNING</p>
<p>该状态的线程池会接收新任务，并处理阻塞队列中的任务;<br>
调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;<br>
调用线程池的shutdownNow()方法，可以切换到STOP状态;</p>
<p>###SHUTDOWN</p>
<p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>
队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</p>
<p>###STOP</p>
<p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>
线程池中执行的任务为空,进入TIDYING状态;</p>
<p>###TIDYING</p>
<p>该状态表明所有的任务已经运行终止，记录的任务数量为0。<br>
terminated()执行完毕，进入TERMINATED状态</p>
<p>###TERMINATED</p>
<p>该状态表示线程池彻底终止</p>
<p>作者：Jay_huaxiao<br>
链接：https://juejin.im/post/5d1882b1f265da1ba84aa676</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-Handler]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler">
        </link>
        <updated>2019-12-05T07:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>##概述<br>
工作中，我们经常遇到多线程用来处理耗时任务，因为主线程中操作很容易引起ANR。于是在Android中使用Handler进行异步的消息处理，处理完成后将再返回给UI线程执行后续逻辑。</p>
<p>##带着问题去看文章</p>
<p>Q1：子线程可以更新UI么，为什么？</p>
<p>Q2：一个Thread可以有几个Looper？几个Handler？</p>
<p>Q3：可以在子线程直接new一个Handler吗？该怎么做？</p>
<p>Q4：Message的创建方法有几种？哪种效果更好，为什么？</p>
<p>Q5：主线程中Looper的轮询死循环为何没有阻塞主线程？</p>
<p>Q6：使用Hanlder的postDealy()后消息队列会发生什么变化？</p>
<p>Q7：点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>Q8：Handler是如何完成子线程和主线程通信的？</p>
<p>Q9：关于ThreadLocal，谈谈你的理解？</p>
<p>Q10：生产者-消费者设计模式？</p>
<p>Q11：享元设计模式？</p>
<p>Q12：Thread两次调用start()方法会发生问题么？</p>
<p>Q13：开启三个线程，循环打印出1到100；<br>
T1：1,4,7....  T2:2,5,8.....  T3:3,6,9....</p>
<p>上述这十三个问题，如果你能清晰透彻的了解，那么你大可关闭这篇文章~</p>
<p>##常见用法</p>
<pre><code>//处理
private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MESSAGE_TEXT_VIEW:
                    mTextView.setText(&quot;UI成功更新&quot;);
                default:
                    super.handleMessage(msg);
            }
        }
};

//调用
new Thread(new Runnable() {
            @Override
            public void run() {
				mHandler.obtainMessage(MESSAGE_TEXT_VIEW).sendToTarget();
            }
        }).start();
</code></pre>
<p>##Handler的构造方法<br>
我们先来剖析一下Handler的构造方法：</p>
<pre><code>public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre>
<p>在构造方法里面，我们看到通过Looper.myLooper()去获取当前Hander的looper，发现获取不到，于是触发异常：&quot;Can't create handler inside thread that has not called Looper.prepare()&quot;，它的意思就是不能在没有得到looper的情况下，就使用handler。但是，我们发现在实际的使用过程中，我们并没有调用Looper.prepare()方法，也没有事，其实是主线程已经帮我们调用，让我们看一下如下的代码：</p>
<p>在ActivityThread中的main方法，它主要做了两个事情：一个准备mainLooper，一个是通过loop()方法创建一个looper：</p>
<pre><code>public static void main(String[] args) {
    ...

    Looper.prepareMainLooper();

    ...
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre>
<p>在得到looper之后，又通过looper获取了消息队列，这个消息队列其实是一个消息链表，它里面存储的就是Message，即消息。</p>
<p>然后我们再来看一下这个Looper.prepareMainLooper（）</p>
<pre><code>public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre>
<p>所以说，ActivityThread在启动的过程中就创建了looper和messageQueue。</p>
<p>##Looper<br>
接下来，我们看一下Looper.prepare()方法里面都做了什么？</p>
<pre><code>static final ThreadLocal sThreadLocal = new ThreadLocal();

public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
</code></pre>
<p>我们看到，它是在ThreadLocal中存储了对应的Looper对象；我们看到ThreadLocal是被static和final同时修饰，所以，它是不可以被继承的并且全局静态的。所以，它只存在一份。</p>
<pre><code>private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<p>所以，这里我们看到，当我们多次调用prepare的时候，就会报错：&quot;Only one Looper may be created per thread&quot;	，意思是：每一个线程有且只有一个Looper。</p>
<p>那么，这个Looper里面都有什么呢？</p>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>首先Looper会定义一个消息链表，然后获取Handler当前的线程。<br>
Looper的最主要作用：开启消息循环机制，不断从MessageQueue里面获取Message，然后调用msg.target.dispatchMessage将消息分发出去。</p>
<p>接下来，我们去看一下Loop()方法：</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    
    //无限循环，这里可以思考一下，为什么不会阻塞主线程
    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;+ Long.toHexString(ident) + &quot; to 0x&quot;+ Long.toHexString(newIdent) + &quot; while dispatching to &quot;+ msg.target.getClass().getName() + &quot; &quot;+ msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre>
<p>#消息的发送<br>
发送消息，我们调用的是obtainMessage，然后sendtoTarget();在obtainMessage中我们获取的是Message.obtain()方法：</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>这是一个静态的方法，使用了同步锁，获取消息，同时把自己清空掉，放在链表头；然后，sendToTarget负责发送消息，最终调用的是sendMessageAtTime(Message msg, long uptimeMillis)</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<p>首先，获取消息链表，然后把消息入链表。</p>
<p>##消息的处理</p>
<p>刚才我们说过，我们调用的是msg.target.dispatchMessage，这个msg.target获取的就是handler。然后我们来看一下dispatchMessage都做了什么？</p>
<pre><code>public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>
<p>这个时候我们可以看到，当我们没有给Message设置callback或者没有设置全局的callback的时候，它会默认的调用handleMessage(msg);这个时候，我们自己的handler就接收到了这个handleMessage。</p>
<p>##问题回顾</p>
<p>###子线程可以更新UI么，为什么？<br>
子线程更新UI要分两种情况，一种是在onCreate里面，一种是在onResume里面。onCreate里面调用没事（如果不sleep()的话），在onResume里面调用就会发生异常：&quot;Only the original thread that created a view hierarchy can touch its views.&quot;，根本原因是在Activity初始化的时候，使用WindowManagerGlobal的addView方法，构造出ViewRootImpl，然后使用ViewRootImpl来判断是否在子线程中，而它的创建是在onResume方法里面进行回调的。</p>
<p>###一个Thread可以有几个Looper？几个Handler？<br>
一个Looper，因为调用Looper.prepare()会得到一个looper，多次调用会报错。一个Thread里面可以有多个Handler，通过msg.target进行关联。</p>
<p>###可以在子线程直接new一个Handler吗？该怎么做？<br>
我们正常是不会调用Looper.prepare()方法的，是主线程帮我们调用的。但是假如我们在Thread里面创建了一个Handler的时候，你会发现这个Handler直接在构造函数的时候就会报错。所以解决办法是：在new Handler之前，手动给它创建一个looper，也就是Looper.prepare()；</p>
<p>###Message的创建方法有几种？哪种效果更好，为什么？<br>
三种，new Message(), Message.obtain(), mHandler.obtainMessage()<br>
第一种就是直接创建，后两种是从消息链表里面取Message，使用了享元模式。</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>###主线程中Looper的轮询死循环为何没有阻塞主线程？<br>
android的UI线程本质上就是一个轮训机制，你可以理解如果没有这个循环，那么将无法监听用户的时间，无法响应UI。</p>
<p>###使用Hanlder的postDealy()后消息队列会发生什么变化？假如这个时候再来一条延迟消息Handler应该怎么处理？</p>
<p>MessageQueue里面调用nativePollOnce方法来停止阻塞线程，阻塞的时间根据msg.when与now的差值来计算应该阻塞多长时间，如果再来一条非延迟消息，会将当前时间清空，直接执行，如果再来一条延迟消息，会计算当前时间与上一个时间比较，然后执行短的那个。</p>
<pre><code>int nextPollTimeoutMillis = 0;
for(;;) {
    if (nextPollTimeoutMillis != 0) {
        Binder.flushPendingCommands();
    }
 
    nativePollOnce(ptr, nextPollTimeoutMillis);
 
    synchronized (this) {
        // Try to retrieve the next message.  Return if found.
        final long now = SystemClock.uptimeMillis();
        Message prevMsg = null;
        Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            // Stalled by a barrier.  Find the next asynchronous message in the queue.
            do {
                prevMsg = msg;
                msg = msg.next;
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        if (msg != null) {
            if (now &lt; msg.when) {
                // Next message is not ready.  Set a timeout to wake up when it is ready.
                nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
            } else {
                // Got a message.
                mBlocked = false;
                if (prevMsg != null) {
                    prevMsg.next = msg.next;
                } else {
                    mMessages = msg.next;
                }
                msg.next = null;
                if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                msg.markInUse();
                return msg;
            }
        } else {
            // No more messages.
            nextPollTimeoutMillis = -1;
        }
        ...
    }
    nextPollTimeoutMillis = 0;
</code></pre>
<p>###点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>###Handler是如何完成子线程和主线程通信的？<br>
见消息的处理</p>
<p>###关于ThreadLocal，谈谈你的理解？</p>
<p>static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();</p>
<p>Thread相当于是简单了实现了一个HashMap，key对应的是每一个线程，value对应它的looper。为啥不用HashMap？因为HashMap里面有很多功能是不需要的，所以单独实现了一个。</p>
<p>###生产者-消费者设计模式？<br>
一个用于生产，一个用于消费，生产者将事件丢进缓冲区，缓冲区满则不继续生产，消费者去消费缓冲区的事件，如果缓冲区空就不消费，并且会通知生产者去生产，同时，生产者生产完成后，要通知消费者去消费。</p>
<p>###Thread两次调用start()方法会发生问题么？</p>
<p>线程首先会运行一次，然后抛出java.lang.IllegalThreadStateException<br>
异常。</p>
<pre><code>if (threadStatus != 0 || started)
            throw new IllegalThreadStateException();
</code></pre>
<p>###使用三个线程顺序打印1到100<br>
使用wait和notifyAll，然后利用同步锁volatile将loackNum加锁，利用synchronized对object加锁，实现同步。</p>
<pre><code>static volatile int loackNum = 1;
static Object object = new Object();
public static void main(String args[]){
    final Thread thread1 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 1) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        }
    });
    Thread thread2 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 2) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    Thread thread3 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 0) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    thread1.start();
    thread2.start();
    thread3.start();
}
</code></pre>
<p>#总结<br>
Handler负责发送消息和处理消息，Message就是那个消息，通过obtain方法获取消息队列，使用sendMessage将消息入队列。最终通过Looper.loop()方法中的无限循环去dispatchMessage回调到Handler里面。</p>
<p>参考：</p>
<p>https://juejin.im/entry/5708b3c38ac247004c1deef7</p>
<p>https://blog.csdn.net/songzi1228/article/details/82835982</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GifView在android的应用指南]]></title>
        <id>https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan</id>
        <link href="https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan">
        </link>
        <updated>2019-11-22T00:48:04.000Z</updated>
        <content type="html"><![CDATA[<p>##背景<br>
目前，大部分市场应用在展示产品的时候都会选择图片配文字的形式，显得更加直观。随着人们手机设备性能的提高与Wifi以及4G网络的提速，为了能让用户的体验更加立体，很多APP在”秀“自己的产品的时候都会直接展示视频。然而图片和视频之间还是有一定的流量差距，为了让用户可以更好的过渡这一差距，图片展示gifview，点击gifview观看视频这样的用户行为正在慢慢的被接受。</p>
<p>##部落来袭<br>
58部落目前是非常大的用户群体，他们也会经常发表一些自己的作品，看法，目前也是列表页展示图片，点击进入后展示详情。那么如果需要有这个过渡，就需要在列表页上增加gifview来达到更好的曝光率。</p>
<p>##大众点评&amp;马蜂窝</p>
<p>###点评 &amp; 马蜂窝 效果展示</p>
<!--todo-->
<p>###效果分析<br>
我们先来自己想想，如果要是我们自己来实现这个效果应该如何来做：</p>
<p>两种方法：</p>
<p><em><strong>方案一：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义GifView，包含展示静态图和gif图的功能；</p>
<p>3.进入页面，请求首页，获取json得到gif；</p>
<p>4.解析gif的第一帧，得到Image的比特流，让GifView展示图片；</p>
<p>5.图片展示完成后，自定义GifView播放GifView；</p>
<hr>
<p>优点：</p>
<p>简化json输出，json里面的返回值返回一套gif就可以，自己解析gif的第一帧用于展示图片；</p>
<p>缺点：</p>
<p>速度慢，本来列表页快速滑动展示大图片都考虑加载时间，如果再去自己解析，成本太高，内存要求大；</p>
<hr>
<p><em><strong>方案二：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义ImageView，展示Image；</p>
<p>3.自定义GifView，展示gif图；</p>
<p>4.进入页面，请求首页，获取json得到image和gif；</p>
<p>5.自定义ImageView展示imageview占位，然后紧接着加载gif；</p>
<p>优点：</p>
<p>1.速度快；</p>
<p>2.解耦，一旦出现问题，可以快速降级；</p>
<hr>
<p>另外，从版本的迭代的上来考虑，我个人更倾向于方案二：</p>
<p>###点评效果深入研究<br>
接下来，先上常规操作让我们看一下大众点评是不是酱样婶的吧：</p>
<p>####dump一下，你不知道<br>
Running activities (most recent first):<br>
Run #1: ActivityRecord{1b8520 u0 com.dianping.v1/.NovaMainActivity t15792}<br>
Run #0: ActivityRecord{2a47964 u0 com.tencent.mm/.ui.LauncherUI t15793}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{945d44 u0 com.miui.home/.launcher.Launcher t1}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{52d96ba u0 com.android.systemui/.recents.RecentsActivity t15788}<br>
ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)<br>
User #0: state=RUNNING_UNLOCKED</p>
<p>首先，我们来看一下dump信息，NovaMainActivity，是它的首页，但是显然根据这个我们没有任何头绪。正向查一个控件我们要知道哪个布局，哪个控件，哪个View。所以，我想能不能看看Log，结果还真的让我找到了蛛丝马迹。</p>
<p>####logcat<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been started:</p>
<p>在我快速滑动的时候，我发现居然有这么些可爱的代码在控制台打印出来。于是，我就看到了新的曙光。</p>
<p>万幸的是，我还在logcat里面额外看到了webp格式的图片和动图的日志：</p>
<pre><code>//动图
https://img.xxx.net/coverpic/2d348f2ea08616ab1e8c652800373740.webp
//非动图
https://img.xxx.net/coverpic/4cf4cfa5469f95444986f83f194f6acb35706.jpg%40320w_426h_1e_1c_1l%7Cwatermark%3D0.webp
</code></pre>
<p>这个日志初步印证了我的想法，我决定看一下&quot;GifImageVIew&quot;都干了啥。点评是有混淆和做了加壳的，常规的jd-gui查看的代码看不到。通过脱壳，获取其相关代码，为了更好地理解，里面的关键代码做了注释：</p>
<pre><code>public class GifImageView extends FrameLayout {

    public GifImageView(Context context) {
        super(context);
    }
    public static final String TAG = &quot;GifImageView&quot;;
    public PicassoImageView gifImageView; //Picasso 
    private String gifIvGroup;
    private double gifPriority; //gif的优先级
    private String gifUrl; //gif的url
    public PicassoImageView imageView;  //又来一个Picasso

	 //构造函数
    public GifImageView(Context context) {
        this(context, null);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet) {
        this(context, attributeSet, 0);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
        init(context);
    }
    
    //初始化 *关键*
    private void init(Context context) {
        LayoutParams layoutParams = new FrameLayout.LayoutParams(-1, -1);
        this.imageView = new PicassoImageView(context);
        this.gifImageView = new PicassoImageView(context);
        this.gifImageView.setFadeInDisplayEnabled(false);
        addView(this.gifImageView, layoutParams);
        addView(this.imageView, layoutParams);
        //开始进行gif加载的设置
        this.gifImageView.setOnLoadChangeListener(new u() {

            //gif加载开始
            public void onImageLoadStart() {
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
  
            //gif加载完成
            public void onImageLoadSuccess(Bitmap bitmap) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif success : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.GONE);
            }
  
            //加载失败如何处理
            public void onImageLoadFailed() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif failed : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
        });
    }
    
    //设置布局
    public void setLayoutParams(LayoutParams layoutParams) {
        super.setLayoutParams(layoutParams);
        setViewParams(this.imageView, layoutParams);
        setViewParams(this.gifImageView, layoutParams);
    }


    //设置布局
    private void setViewParams(View view, LayoutParams layoutParams) {
        LayoutParams layoutParams2 = view.getLayoutParams();
        if (layoutParams2 instanceof FrameLayout.LayoutParams) {
            layoutParams2.width = layoutParams.width;
            layoutParams2.height = layoutParams.height;
            view.setLayoutParams(layoutParams2);
        }
    }


    //开始执行gif播放
    public void startGif() {
        if (this.gifImageView.isImageAnimating()) {
            Log.d(TAG, &quot;gifIv has already been started: &quot;);
        } else {
            this.gifImageView.setAnimatedImageLooping(-1);
            this.gifImageView.startImageAnimation();
            Log.d(TAG, &quot;gifIv has been started: &quot;);
        }
    }

    //停止执行gif播放
    public void stopGif() {
        if (this.gifImageView.isImageAnimating()) {
            this.gifImageView.setAnimatedImageLooping(0);
            this.gifImageView.stopImageAnimation();
            Log.d(TAG, &quot;gifIv has been stoped: &quot;);
        } else {
            Log.d(TAG, &quot;gifIv has already been stoped: &quot;);
        }
    }

    //设置image和gif图像地址
    public void setGifImage(String str, String str2) {

        this.imageView.setImage(str);
        this.gifImageView.setAnimatedImageLooping(0);
        this.gifImageView.setImage(str2);
        this.imageView.setVisibility(0);
        this.gifUrl = str2;
        if (TextUtils.isEmpty(str2)) {
            GifImageViewManager.getInstance().addGifIv(this);
        } else {
            GifImageViewManager.getInstance().removeGifIv(this);
        }
    }

    public void setAnimatedImageLooping(int i) {
        this.imageView.setAnimatedImageLooping(i);
    }

    public void setScaleType(ImageView.ScaleType scaleType) {
        this.imageView.setScaleType(scaleType);
        this.gifImageView.setScaleType(scaleType);
    }

    //支持直接设置drawable
    public void setImageDrawable(Drawable drawable) {
        this.imageView.setVisibility(0);
        this.imageView.setImageDrawable(drawable);
    }
   
   .....此处省略1000字
}
</code></pre>
<p>另外，还发现它的自定义图片PicassoImageView（好像跟git上面的Picasso没什么关系）。</p>
<pre><code>import com.dianping.imagemanager.DPImageView;
public class PicassoImageView extends DPImageView implements Clippable {
}


public class DPImageView extends ImageView implements OnClickListener {
}
</code></pre>
<p>还有。。。。咳咳，让我们点到为止吧。</p>
<p>###点评效果总结<br>
所以，点评的基本逻辑跟我之前说的第二种方案几乎无差，我们再来回顾一下：</p>
<p>1.自定义View命名为PicassoImageView，可以展示Gif图也可以展示ImageView；</p>
<p>2.封装GifImageView，里面包含两个PicassoImageView；</p>
<p>3.其中一个PicassoImageView展示imageview占位，同时另外一个PicassoImageView进行gif的加载，加载完成后，把第一个PicassoImageView消失；</p>
<p>so，感谢点评为我们提供宝贵的思路，接下来让我们去看看马蜂窝是怎么实现的吧。</p>
<p>###马蜂窝效果深入研究<br>
####dump之后依然没有有用信息<br>
也不是完全没有用，至少你知道了程序的入口在哪里。<br>
####看看logcat</p>
<pre><code>2019-09-18 16:53:11.786 25404-25919/? D/SoLoader: About to load: libgifimage.so
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so not found on /data/data/com.mfw.roadbook/lib-main
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so found on /data/app/com.mfw.roadbook-U4eSwGYqvGPqtvkBe8R4gw==/lib/arm
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: Not resolving dependencies for libgifimage.so
2019-09-18 16:53:11.795 25404-25919/? D/SoLoader: Loaded: libgifimage.so
</code></pre>
<p>嗯，果然，看看还是有收获的。又Get到一个新知识，可以通过加载so（libgifimage.so）的方式，提升GifView加载速度。</p>
<p>###马蜂窝效果总结</p>
<p>在实际体验的过程中，我发现滑动到没有加载的图片时，马蜂窝会用一个加载的灰色占位图占位，然后去下载gif，它旁边的图片都展示出来了，gif还没有下载完，体验不是很好。这点可以借鉴一下大众点评的。</p>
<p>由于马蜂窝也加壳了，脱壳其实是很开(fei)心(shen)的，有了点评的思路，我就没有特别深入的研究马蜂窝的内部实现，其实直接看效果也能看出个大概。</p>
<p>##有没有开源的库呢？<br>
我们并不想把点评或者马蜂窝的代码直接拷过来，毕竟人家没有开源，而且也不一定契合我们的风格。在git上找一个demo实现以下？<br>
于是，我看到了这个android-gif-drawable，这个看起来还不错，7K的赞，Fork了1.6K，正合我意，来吧，研究一波。</p>
<p>###API解读<br>
android-gif-drawable是通过JNI来渲染帧的，比使用WebView或者Movie性能要好一些。</p>
<p><strong>依赖</strong></p>
<pre><code>dependencies {
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'
}

repositories {
	mavenCentral()
	maven { 
		url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; }
	}
	dependencies {
    i	mplementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.+'
	}

&lt;dependency&gt;
    &lt;groupId&gt;pl.droidsonroids.gif&lt;/groupId&gt;
    &lt;artifactId&gt;android-gif-drawable&lt;/artifactId&gt;
    &lt;version&gt;insert latest version here&lt;/version&gt;
    &lt;type&gt;aar&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
<p>基本使用：</p>
<pre><code>//1. asset文件
GifDrawable gifFromAssets = new GifDrawable( getAssets(), &quot;anim.gif&quot; );

//2. resource (drawable or raw)
GifDrawable gifFromResource = new GifDrawable( getResources(), R.drawable.anim );

//3. byte array
byte[] rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//4. FileDescriptor
FileDescriptor fd = new RandomAccessFile( &quot;/path/anim.gif&quot;, &quot;r&quot; ).getFD();
GifDrawable gifFromFd = new GifDrawable( fd );

//5. file path
GifDrawable gifFromPath = new GifDrawable( &quot;/path/anim.gif&quot; );

//6. file
File gifFile = new File(getFilesDir(),&quot;anim.gif&quot;);
GifDrawable gifFromFile = new GifDrawable(gifFile);

//7. AssetFileDescriptor
AssetFileDescriptor afd = getAssets().openFd( &quot;anim.gif&quot; );
GifDrawable gifFromAfd = new GifDrawable( afd );

//8. InputStream (it must support marking)
InputStream sourceIs = ...
BufferedInputStream bis = new BufferedInputStream( sourceIs, GIF_LENGTH );
GifDrawable gifFromStream = new GifDrawable( bis );

//9. direct ByteBuffer
ByteBuffer rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//10.加载网络图片其实本质上也离不开上面这些内容，推荐RxJava；
</code></pre>
<p>额外的API：</p>
<pre><code>- 停止GIF动画
·stop() 

- 开始GIF动画
·start() 

- GIf动画是否在执行
isRunning() 

- 重置GIF动画
reset() 

- 控制执行动画的速度
setSpeed(float factor) 

- 从该动画的执行位置开始执行
seekTo(int position) 

- 动画的持续时间
getDuration() 

- 当前动画的播放时间
getCurrentPosition() 
</code></pre>
<p>调用方法也是非常简单：</p>
<pre><code>&lt;pl.droidsonroids.gif.GifImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:src=&quot;@drawable/src_anim&quot;
android:background=&quot;@drawable/bg_anim&quot;
/&gt;

try {
            GifDrawable gifFromResDrawable = new GifDrawable( mContext.getResources(), getIntGifRes(imageData.gifUrl));
            viewHolder.gifImageView.setImageDrawable(gifFromResDrawable);
            viewHolder.gifImageView.setVisibility(View.VISIBLE);
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>
<p>所以，我们看到，本质上还是这个GifDrawable在起作用，因为GifImageView继承的是ImageView。</p>
<p>###效果如下</p>
<!--todo-->
<p>##撸一个Demo<br>
我们看完了大众点评、马蜂窝、github上的实现效果。它们有自己的优点，结合58自己的技术特点，我打算采用的技术架构：FRESCO + RecyclerView的StaggeredGridLayoutManager，具体实现思路如下：</p>
<p>###使用StaggeredGridLayoutManager实现瀑布布局；</p>
<pre><code>RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);
    StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2,
            StaggeredGridLayoutManager.VERTICAL);
    recyclerView.setLayoutManager(layoutManager);

    FrescoAdapter adapter = new FrescoAdapter(this, DataUtils.getFrescoImageData());
    recyclerView.setAdapter(adapter);
</code></pre>
<p>###自定义Adapter继承自RecyclerView.Adapter，用于加载图片和GIF：</p>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

    SimpleDraweeView draweeImage;
    SimpleDraweeView draweeGif;
    TextView textView;
    public ViewHolder(@NonNull View itemView) {
        super(itemView);
        draweeImage = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview);
        draweeGif = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview_gif);
        textView = (TextView) itemView.findViewById(R.id.item_draweeview_text);
    }
}
</code></pre>
<p>###加载图片和GIF</p>
<pre><code>/**
     * Fresco 加载webp图片
     * @param draweeView
     * @param imageUrl
     */
    public static void loadWebpImage(final Context context, final SimpleDraweeView draweeView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()
                .setUri(Uri.parse(imageUrl))
                .setAutoPlayAnimations(true)
                .setOldController(draweeView.getController())
                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }

                        if(imageData.getScale() == 0){
                            int width = imageInfo.getWidth();
                            int height = imageInfo.getHeight();
                            float scale = (float) width/ (float) height;
                            imageData.setScale(scale);
                        }
                        final ViewGroup.LayoutParams layoutParams = draweeView.getLayoutParams();
                        layoutParams.width = DisplayUtils.getScreenWidth((Activity) context) / 2 - DisplayUtils.dp2px(context,10);
                        layoutParams.height = (int) (layoutParams.width/ imageData.getScale());

                        imageData.setWidth(layoutParams.width);
                        imageData.setHeight(layoutParams.height);

                        imageData.setPosition(position);

                        draweeView.setLayoutParams(layoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        draweeView.setController(controller);

    }

    /**
     * Fresco 加载webpGID
     * @param imageView
     * @param imageUrl
     */
    public static void loadWebpGif(final Context context, final SimpleDraweeView imageView,final SimpleDraweeView gifView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()

                .setUri(Uri.parse(imageUrl))

                .setAutoPlayAnimations(true)

                .setOldController(gifView.getController())

                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }
                        final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
                        final ViewGroup.LayoutParams gifLayoutParams = gifView.getLayoutParams();
                        gifLayoutParams.width = layoutParams.width;
                        gifLayoutParams.height = layoutParams.height;

                        gifView.setLayoutParams(gifLayoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        gifView.setController(controller);
    }
</code></pre>
<p>###效果如下：</p>
<!--todo-->
<p>###缺点与不足<br>
Demo里面还有很多的异常边界情况没有考虑，比如各类的容错判断，性能问题监控，等等</p>
<p>传送门：<a href="https://github.com/Mozziehh/GifView">github.com/mozzie</a></p>
<p>##参考文章</p>
<ol>
<li>
<p>https://www.jianshu.com/p/057f48df855b</p>
</li>
<li>
<p>https://github.com/koral--/android-gif-drawable</p>
</li>
<li>
<p>https://www.dev2qa.com/how-to-play-gif-file-use-android-graphics-movie-class/</p>
</li>
<li>
<p>https://blog.csdn.net/feather_wch/article/details/79558240</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过NDK实现Zxing二维码扫描放大功能]]></title>
        <id>https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng</id>
        <link href="https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng">
        </link>
        <updated>2019-11-22T00:43:25.000Z</updated>
        <content type="html"><![CDATA[<p> 在各个APP中几乎都能看见它的身影。二维码扫描虽然是一个普通的功能，但是在APP中占依然都放在很抢眼的位置。比如像淘宝、58这类APP主要解决PC端扫码登录，微信、支付宝这类主要使用支付，摩拜小蓝这类APP主要是用于扫码骑车。所以，能更快捷更方便的使用二维码，可以极大的提升用户体验。</p>
<p>##快捷与方便<br>
 曾经或许会有那么一个寒冷的夜晚，你骑着刚共享单车飞驰在回家的路上，突然，街边飘来哈尔滨烤冷面的香气让你不知不觉的来到那个小摊面前，迟疑了很久，你说了一句：“老板，来一份。。。再。。。加个肠。”昏暗的灯光下、其他的食客中，老板熟练的抄起手中的家伙，你熟练掏出手机，打开扫一扫，老板的二维码在你的手里一次次对焦、一次次放大，“滴”的一声，付钱，取餐，嗝~。<br>
 你有没有想过，为什么在扫描的过程中，被扫描的二维码会在扫描框里从模糊到清晰，然后再从清晰到模糊，周而复始？<br>
 你有没有想过，为什么在稍远的距离，二维码扫描就会慢慢放大？<br>
 是的，在这个寒冷的夜，为了能让你的手机更快速的识别出对方的二维码，我们做了很多。</p>
<p>##二维码解读</p>
<p>我们来看一下二维码扫描主要展示信息，主要分为功能图形和编码区格式。其中功能图形的位置探测图形、定位图形、矫正图形在定位的过程中起着举足轻重的地位。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/Mozziehh/mypapers/blob/master/images/qrcode_structure.png?raw=true" alt=""></figure>
<p>##二维码扫描的源码解读<br>
 从你拿出手机对准二维码直到扫描结束，整个过程都发生了什么？为了能让你生动的了解整个过程，我打算用下面的方式讲：<br>
打开相机执行扫描-&gt;获取Byte流-&gt;灰度-&gt;二值化-&gt;霍夫变换-&gt;找到二维码定位点-&gt;识别-&gt;返回结果。</p>
<p>###打开相机执行扫描</p>
<pre><code>private void initCamera(SurfaceHolder surfaceHolder) {
        if (surfaceHolder == null) {
            throw new IllegalStateException(&quot;No SurfaceHolder provided&quot;);
        }
        if (cameraManager.isOpen()) {
            Log.w(TAG, &quot;initCamera() while already open -- late SurfaceView callback?&quot;);
            return;
        }
        try {
            cameraManager.openDriver(surfaceHolder);
            // Creating the handler starts the preview, which can also throw a
            // RuntimeException.
            if (handler == null) {
                handler = new CaptureActivityHandler(this, cameraManager, DecodeThread.ALL_MODE);
            }

            initCrop();
        } catch (IOException ioe) {
            Log.w(TAG, ioe);
            displayFrameworkBugMessageAndExit();
        } catch (RuntimeException e) {
            // Barcode Scanner has seen crashes in the wild of this variety:
            // java.?lang.?RuntimeException: Fail to connect to camera service
            Log.w(TAG, &quot;Unexpected error initializing camera&quot;, e);
            displayFrameworkBugMessageAndExit();
        }
    }
</code></pre>
<p>###设置支持的二维码类型</p>
<p>目前二维码支持如下类型：<br>
<img src="https://i.loli.net/2019/06/17/5d0734bfd44a794589.png" alt="support-zxing-pic.png"><br>
代码在这里配置：</p>
<pre><code>// The prefs can't change while the thread is running, so pick them up once here.
    if (decodeFormats == null || decodeFormats.isEmpty()) {
      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
      decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) {
        decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) {
        decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) {
        decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) {
        decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) {
        decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) {
        decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
      }
    }
    hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
</code></pre>
<p>###获取相机预览的Byte流</p>
<pre><code>public class PreviewCallback implements Camera.PreviewCallback {

	private static final String TAG = PreviewCallback.class.getSimpleName();

	private final CameraConfigurationManager configManager;
	private Handler previewHandler;
	private int previewMessage;

	public PreviewCallback(CameraConfigurationManager configManager) {
		this.configManager = configManager;
	}

	public void setHandler(Handler previewHandler, int previewMessage) {
		this.previewHandler = previewHandler;
		this.previewMessage = previewMessage;
	}

	@Override
	public void onPreviewFrame(byte[] data, Camera camera) {
		Point cameraResolution = configManager.getCameraResolution();
		Handler thePreviewHandler = previewHandler;
		if (cameraResolution != null &amp;&amp; thePreviewHandler != null) {
			Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x, cameraResolution.y, data);
			message.sendToTarget();
			previewHandler = null;
		} else {
			Log.d(TAG, &quot;Got preview callback, but no handler or resolution available&quot;);
		}
	}

}

//在这里通过相机框获取bitmap的byte流
PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);

BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

</code></pre>
<p>###对bitmap的byte流解码</p>
<pre><code>if (formats != null) {
  boolean addOneDReader =
	  formats.contains(BarcodeFormat.UPC_A) ||
	  formats.contains(BarcodeFormat.UPC_E) ||
	  formats.contains(BarcodeFormat.EAN_13) ||
	  formats.contains(BarcodeFormat.EAN_8) ||
	  formats.contains(BarcodeFormat.CODABAR) ||
	  formats.contains(BarcodeFormat.CODE_39) ||
	  formats.contains(BarcodeFormat.CODE_93) ||
	  formats.contains(BarcodeFormat.CODE_128) ||
	  formats.contains(BarcodeFormat.ITF) ||
	  formats.contains(BarcodeFormat.RSS_14) ||
	  formats.contains(BarcodeFormat.RSS_EXPANDED);
  // Put 1D readers upfront in &quot;normal&quot; mode
  readers.add(new MultiFormatOneDReader(hints));
  if (formats.contains(BarcodeFormat.QR_CODE)) {
	readers.add(new QRCodeReader(mActivity));
  }
  if (formats.contains(BarcodeFormat.DATA_MATRIX)) {
	readers.add(new DataMatrixReader());
  }
  if (formats.contains(BarcodeFormat.AZTEC)) {
	readers.add(new AztecReader());
  }
  if (formats.contains(BarcodeFormat.PDF_417)) {
	 readers.add(new PDF417Reader());
  }
  if (formats.contains(BarcodeFormat.MAXICODE)) {
	 readers.add(new MaxiCodeReader());
  }
  // At end in &quot;try harder&quot; mode
  readers.add(new MultiFormatOneDReader(hints));

</code></pre>
<h3 id="解码调用接口的实现类">解码，调用接口的实现类</h3>
<pre><code>private Result decodeInternal(BinaryBitmap image) throws NotFoundException {
    if (readers != null) {
      for (Reader reader : readers) {
        try {
          return reader.decode(image, hints);
        } catch (ReaderException re) {
          // continue
        }
      }
    }
    throw NotFoundException.getNotFoundInstance();
  }
// QRCodeReader.java
	@Override
	  public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)
		  throws NotFoundException, ChecksumException, FormatException {
		DecoderResult decoderResult; //解析结果
		ResultPoint[] points; //解析的点
		if (hints != null &amp;&amp; hints.containsKey(DecodeHintType.PURE_BARCODE)) {
		  //二值化：image.getBlackMatrix()
		  BitMatrix bits = extractPureBits(image.getBlackMatrix());
		  decoderResult = decoder.decode(bits, hints);
		  points = NO_POINTS;
		} else {
		  //二值化：image.getBlackMatrix()
		  DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);
		  decoderResult = decoder.decode(detectorResult.getBits(), hints);
		  points = detectorResult.getPoints();
		}

		// If the code was mirrored: swap the bottom-left and the top-right points.
		if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
		  ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);
		}

		Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);
		List&lt;byte[]&gt; byteSegments = decoderResult.getByteSegments();
		if (byteSegments != null) {
		  result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);
		}
		String ecLevel = decoderResult.getECLevel();
		if (ecLevel != null) {
		  result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);
		}
		if (decoderResult.hasStructuredAppend()) {
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,
							 decoderResult.getStructuredAppendSequenceNumber());
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,
							 decoderResult.getStructuredAppendParity());
		}
		return result;
	  }


	/**
	   * &lt;p&gt;Detects a QR Code in an image.&lt;/p&gt;
	   *
	   * @param hints optional hints to detector
	   * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	   * @throws NotFoundException if QR Code cannot be found
	   * @throws FormatException if a QR Code cannot be decoded
	   */
	  public final DetectorResult detect(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException, FormatException {

		resultPointCallback = hints == null ? null :
			(ResultPointCallback) hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);

		FinderPatternFinder finder = new FinderPatternFinder(image, resultPointCallback);
		FinderPatternInfo info = finder.find(hints);

		return processFinderPatternInfo(info);
	  }

</code></pre>
<p>###定位特征点</p>
<pre><code>	final FinderPatternInfo find(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException {
		boolean tryHarder = hints != null &amp;&amp; hints.containsKey(DecodeHintType.TRY_HARDER);
		int maxI = image.getHeight();
		int maxJ = image.getWidth();
		int iSkip = (3 * maxI) / (4 * MAX_MODULES);
		if (iSkip &lt; MIN_SKIP || tryHarder) {
		  iSkip = MIN_SKIP;
		}

		boolean done = false;
		int[] stateCount = new int[5];
		for (int i = iSkip - 1; i &lt; maxI &amp;&amp; !done; i += iSkip) {
		  // Get a row of black/white values
		  clearCounts(stateCount);
		  int currentState = 0;
		  for (int j = 0; j &lt; maxJ; j++) {
			if (image.get(j, i)) {
			  // Black pixel
			  if ((currentState &amp; 1) == 1) { // Counting white pixels
				currentState++;
			  }
			  stateCount[currentState]++;
			} else { // White pixel
			  if ((currentState &amp; 1) == 0) { // Counting black pixels
				if (currentState == 4) { // A winner?
				  if (foundPatternCross(stateCount)) { // Yes
					boolean confirmed = handlePossibleCenter(stateCount, i, j);
					if (confirmed) {
					  iSkip = 2;
					  if (hasSkipped) {
						done = haveMultiplyConfirmedCenters();
					  } else {
						int rowSkip = findRowSkip();
						if (rowSkip &gt; stateCount[2]) {
						  i += rowSkip - stateCount[2] - iSkip;
						  j = maxJ - 1;
						}
					  }
					} else {
					  shiftCounts2(stateCount);
					  currentState = 3;
					  continue;
					}
					// Clear state to start looking again
					currentState = 0;
					clearCounts(stateCount);
				  } else { // No, shift counts back by two
					shiftCounts2(stateCount);
					currentState = 3;
				  }
				} else {
				  stateCount[++currentState]++;
				}
			  } else { // Counting white pixels
				stateCount[currentState]++;
			  }
			}
		  }
		  if (foundPatternCross(stateCount)) {
			boolean confirmed = handlePossibleCenter(stateCount, i, maxJ);
			if (confirmed) {
			  iSkip = stateCount[0];
			  if (hasSkipped) {
				// Found a third one
				done = haveMultiplyConfirmedCenters();
			  }
			}
		  }
		}
	//找到定位点
		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
	  }
</code></pre>
<p>###返回结果</p>
<pre><code>	protected final DetectorResult processFinderPatternInfo(FinderPatternInfo info)
		  throws NotFoundException, FormatException {

		FinderPattern topLeft = info.getTopLeft();
		FinderPattern topRight = info.getTopRight();
		FinderPattern bottomLeft = info.getBottomLeft();

		float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
		if (moduleSize &lt; 1.0f) {
		  throw NotFoundException.getNotFoundInstance();
		}
		int dimension = computeDimension(topLeft, topRight, bottomLeft, moduleSize);
		Version provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
		int modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;

		AlignmentPattern alignmentPattern = null;
		// Anything above version 1 has an alignment pattern
		if (provisionalVersion.getAlignmentPatternCenters().length &gt; 0) {

		  // Guess where a &quot;bottom right&quot; finder pattern would have been
		  float bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
		  float bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();

		  // Estimate that alignment pattern is closer by 3 modules
		  // from &quot;bottom right&quot; to known top left location
		  float correctionToTopLeft = 1.0f - 3.0f / modulesBetweenFPCenters;
		  int estAlignmentX = (int) (topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
		  int estAlignmentY = (int) (topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));

		  // Kind of arbitrary -- expand search radius before giving up
		  for (int i = 4; i &lt;= 16; i &lt;&lt;= 1) {
			try {
			  alignmentPattern = findAlignmentInRegion(moduleSize,
				  estAlignmentX,
				  estAlignmentY,
				  i);
			  break;
			} catch (NotFoundException re) {
			  // try next round
			}
		  }
		}

		PerspectiveTransform transform =
			createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);

		BitMatrix bits = sampleGrid(image, transform, dimension);

		ResultPoint[] points;
		if (alignmentPattern == null) {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight};
		} else {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight, alignmentPattern};
		}
		return new DetectorResult(bits, points);
	  }
</code></pre>
<p>##问题来了<br>
在阅读源码之后，我们发现这里面并没有解读放大相关的功能，这是为什么呢？<br>
是的，因为Zxing库本来就没有提供放大的功能，那么我们想实现放大功能应该怎么做？<br>
对，答案就是利用相机的放大功能setZoom来放大相机即可。<br>
那么，什么时机放大呢？</p>
<p>###相机放大功能和二维码建立关系<br>
为了解决这个放大时机的问题，我们再来回顾一下源码。<br>
有这样一段源码，它的作用是找到定位点：</p>
<pre><code>		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
</code></pre>
<p>那么，我们是不是利用这个定位点，就可以和相机扫描框的间距搞一些事情就可以了？<br>
事实上，网上也有很多例子是这么做的。<br>
行，既然已经有了，那我们直接拿来用就可以了吧？<br>
NONONO，事情并不是那么简单：<br>
<img src="https://i.loli.net/2019/06/17/5d0758dd0179c16484.png" alt="bucunzai.png"></p>
<p>##58APP二维码扫描的应用<br>
因为58APP，用的不是Java实现的。核心解码流程使用的是C++，通过JNI编译生成的so，然后再打入到58APP里的。<br>
兵来将挡水来土掩，行，既然java实现的思路已经有了，我们就用C++再写一遍怎么了，谁让咱也是科班出身。</p>
<p>###找到核心C++实现<br>
我们发现，是在这里执行的decode，然后也是调用了decodeWithState，然后将得到的结果返回给java。<br>
仔细跟进去，发现逻辑差不多，只不过一个是用java，一个是用C++。</p>
<pre><code>jbyte *yuvData = env-&gt;GetByteArrayElements(yuvData_, NULL);

    std::string codeResult = &quot;&quot;;
    try {
        ......
		省略部分代码
        // Perform the decoding.
        MultiFormatReader reader;
        reader.setHints(hints);
        Ref&lt;Result&gt; result(reader.decodeWithState(image));

        // Output the result.
        codeResult = result-&gt;getText()-&gt;getText();
        cout &lt;&lt; result-&gt;getText()-&gt;getText() &lt;&lt; endl;
    } catch (zxing::Exception&amp; e) {
        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;
    }

    env-&gt;ReleaseByteArrayElements(yuvData_, yuvData, 0);

    return env-&gt;NewStringUTF(codeResult.c_str());
</code></pre>
<p>###QRCodeReader.cpp核心实现</p>
<p>下面就是decode使用c++的核心实现，因为前面已经讲过了Java的实现，所以这里找到C++的代码也是非常容易的<br>
这里我们看到，有一句</p>
<pre><code>	Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
</code></pre>
<p>它的意思就是通过detect得到了detectorResult，然后通过下面的，</p>
<pre><code>	ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
</code></pre>
<p>得到了points，即定位点；<br>
一开始我想着把这个定位点独立出一个方法，然后再通过回调的形式传递给Java层，这样做的好处就是我们可以通过Java来实现放大功能。但是因为我们相机预览的速度是特别快的，所以这样做其实并不合适。于是，把相机的参数传递进去，然后在C++里面完成对于相机的放大。</p>
<pre><code>QRCodeReader::QRCodeReader() :decoder_() {
		}
		//TODO: see if any of the other files in the qrcode tree need tryHarder
		Ref&lt;Result&gt; QRCodeReader::decode(Ref&lt;BinaryBitmap&gt; image, DecodeHints hints) {
			Detector detector(image-&gt;getBlackMatrix());
			Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
			ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
			Ref&lt;DecoderResult&gt; decoderResult(decoder_.decode(detectorResult-&gt;getBits()));
			Ref&lt;Result&gt; result(
							   new Result(decoderResult-&gt;getText(), decoderResult-&gt;getRawBytes(), points, BarcodeFormat::QR_CODE));
			return result;
		}
</code></pre>
<p>###传递Java的Camera对象<br>
主要是在原来的基础上多传递了扫描框的位置和Camera这个对象：</p>
<pre><code>	xxx_QbarNative_decode(JNIEnv *env, jobject instance, jbyteArray bytes_, jint width,
										  jint height, jint cropLeft, jint cropRight, jint cropTop,
										  jint cropWidth, jint cropHeight, jboolean reverseHorizontal,
										  jobject camera, jobject parameters)
</code></pre>
<p>###放大代码使用C++实现<br>
最后，根据参数进行实现：简单的说就是判断二维码定位点的距离，然后用这个距离和相框之间的距离做个比对，小于一半，我们递增。</p>
<pre><code>	//执行检测逻辑，检测得到执行放大照相机逻辑，否则执行解析逻辑
	if(NULL != resultPoints &amp;&amp; !(resultPoints-&gt;empty())){
		//省去部分核心代码

		if(isZoomSupported){
		//这里做了简化，主要解决放大倍数过多，使得二维码突然不在扫描框里。
			if (len &lt;= frameWidth / 2){
				if(zoom &lt; maxZoom){
					zoom = zoom + 8;
				}else{
					zoom = maxZoom;
				}
				jmethodID setZoomMth = env-&gt;GetMethodID(parametersCls, &quot;setZoom&quot;, &quot;(I)V&quot;);
				env-&gt;CallVoidMethod(parameters, setZoomMth, zoom);

				jmethodID setParametersMth = env-&gt;GetMethodID(camearCls, &quot;setParameters&quot;, &quot;(Landroid/hardware/Camera$Parameters;)V&quot;);
				env-&gt;CallVoidMethod(camera, setParametersMth, parameters);

				env-&gt;ReleaseByteArrayElements(bytes_, yuvData, 0);
				string ss = strStream.str();
			}
		}
	}
</code></pre>
<p>###导出so，打入58APP<br>
最后，在demo中运行一下，看看效果。<br>
<img src="https://i.loli.net/2019/06/17/5d077e8e60ec060459.gif" alt="1557793019816360 (1).gif"></p>
<p>##心得<br>
其实最终解决这个问题不难，重点在于发现问题，解决问题的过程学到了什么。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手把手教你如何不刷机Hook代码]]></title>
        <id>https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma</id>
        <link href="https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma">
        </link>
        <updated>2019-11-22T00:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>##1. 背景</p>
<blockquote>
<p>前几个月，我们同TEG的同学一起排查一个问题：B端用户使用黑产提供的软件来Hook我们的API，达到在发送IM消息时发送自定义消息的目的，比如：在tips里面弹出，“淘宝客服，日结300，加V xxxxxxx”</p>
</blockquote>
<blockquote>
<p>带着一颗强烈的好奇心，我走进了Xposed的世界，发现原来Android的世界还可以如此精彩。</p>
</blockquote>
<p>##2. Xposed-从入门到放弃<br>
提起Xposed，可能很多人都听过它的名字，知道它是什么。</p>
<p>但是具体再深挖一下，它的原理是什么，可能大家就会回答的很模糊。</p>
<p>如果再深挖一下，const u2* insns是干什么用的？</p>
<p>如何再涉及到实践，如何Hook一个私有方法？</p>
<p>相信大家心里就会说：“这跟我有什么关系~~”</p>
<p>对的，一开始我也是这样的。但是一步步走下来，你会发现这个东西根本没那么难。那么，就跟我一起来学习下这块的相关知识吧。</p>
<p>###2.1 什么是Xpose？<br>
Xposed 框架是一款可以在不修改 APK 的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作，在这个框架下，我们可以加载很多插件 App ，这些插件 App 可以直接或间接劫持、篡改、伪造一些信息。</p>
<p>###2.2 它的原理是什么？</p>
<p>####2.2.1 Xposed资源<br>
·XposedBridge.jar：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。</p>
<p>·Xposed：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p>·XposedInstaller：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。</p>
<p>·XposedMods：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<p>####2.2.2 Zygote<br>
在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。</p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<p>####2.2.3 Hook<br>
在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
<p>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。在hookMethodNative的实现中，会调用XposedBridge中的handleHookedMethod这个方法来传递参数。handleHookedMethod这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是xposedCallHandler。而handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数，并调用他们的before, after函数。</p>
<p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：</p>
<p>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
<p>###2.3 为什么后来又放弃了？<br>
研究了一段时间之后，寻思就开始上手吧。<br>
####2.3.1 刷机成本<br>
Xposed是需要root手机的，于是就开始研究刷机，我手里有两个锤子手机，其中一个呢，已经被我彻底刷成了“锤子”，平时砸个核桃啥的用起来还算是顺手。另外一个，刷完之后，我手机里面的东西还都需要重新安装，有些APK是市场上已经找不到了。而且，我们目前使用的手机，主流的小米、OPPO、VIVI、华为，这些手机的刷机方式已经不再像原来那样简单，下载一个安装包，同时按住电源键+ Home + 音量“+”等一会那么简单了。而且刷完之后，不是NFC不好用，就是WIFI坏了。要是没有一款可要可不要的闲置手机，真的不建议刷。<br>
####2.3.2 脱壳也是一件麻烦事<br>
接下来再想，我们突破了种种困难，完成了刷机。但是当我们需要Hook方法的时候又会犯难，因为现在加壳的APK，反编译之后外面就一两个类，根本无从下手，还需要再研究脱壳。</p>
<p>渐渐地，我就发现原本我的目标：想看看如何模拟黑产去Hook一个API，但是这样的路让我越走越远。方向没错，但是不禁觉得这是在浪费时间。难道就真的没有办法了么？</p>
<p>接下来就来介绍一下，今天的猪脚，Virtual Xposed~~<br>
##3. Virutal Xposed<br>
对于我这样的“刚需”，它是一款神器。为什么，首先它不需要刷机，它的脱壳也是非常的简单。就这么简单的两点，完全解决了我的痛点。<br>
###3.1 它与Xposed从原理上的区别<br>
VirtualXposed 并未对系统底层进行任何修改，也没有利用什么神奇的漏洞。它的工作原理有点像那些双开软件。</p>
<p>VirtualXposed 是通过在你的手机里创建一个「虚拟环境」，然后在此虚拟环境中启用 Xposed。</p>
<p>###3.2 FDex2</p>
<p>###3.3 Demo<br>
##偷偷搞一波58试试</p>
<p>参考文章：<br>
http://yx.bsh.me/23278.html<br>
https://mp.weixin.qq.com/s/PG7ykzTWkw4tARjp0yKeAQ<br>
https://mp.weixin.qq.com/s/AlZMhMZ-SFOxRMtXfcev1g<br>
https://blog.csdn.net/ascii2/article/details/47974217<br>
https://blog.csdn.net/wxyyxc1992/article/details/17320911</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter接入第三方SDK]]></title>
        <id>https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk</id>
        <link href="https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk">
        </link>
        <updated>2019-11-22T00:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>#Flutter接入第三方SDK<br>
最近开始使用Flutter，发现我们可以写出原生的页面，使用Dart语言完成逻辑的编程。但是假如我们需要接入一个第三方SDK，这个时候应该怎么办呢？<br>
##接入第三方SDK-登录SDK<br>
登录SDK是58出的一款适用于全公司的一套登录体系。登录SDK是以一个AAR的形式提供的。该aar包含classes.jar、资源文件、assets文件、AndroidManifest.xml以及R.txt文件。</p>
<p>##Java的接入方式<br>
首先这是一个全新的挑战，接到手之后完全不知道该怎么弄。<br>
这里我们先回顾一下，在使用Java开发的时候，我们是如何引入AAR的：</p>
<blockquote>
<p>1.配置build.gradle文件，添加implementation 'xxx:xxxx:'</p>
<p>2.编译</p>
<p>3.调用</p>
</blockquote>
<p>##Flutter的接入方式<br>
那么Flutter的接入方式与Java的方式有什么不同呢？我们也试着按照上面的三种方式来做一次:</p>
<p>###配置AAR &amp; 编译<br>
这个配置AAR的方式有点诡异，需要在File -&gt; new -&gt; new Module -&gt; Import .AAR package，添加依赖之后，它会自动编译，然后你就会发现可以打开了。</p>
<p>然鹅，这种方式，是错误的。因为你把这个AAR引入到Flutter的工程里面，但是并没有引入到android的项目中来，因为我发现调用的时候依然调用不了。</p>
<p>另外，我发现在android目录下有一个MainActivity.java文件，大概率就是在这里添加跟Flutter页面的交互了。<br>
可是我发现这个类编辑之后没有任何代码提示，直觉告诉我这里缺一些东西，缺的是android的编译环境：</p>
<p>答案就是：双开</p>
<p>通过File -&gt; Open的形式，用android studio再打开一个目录引入android工程。</p>
<p>接下来的依赖关系也就变得顺其自然，双开固然麻烦，但是当你用flutter运行的那一刻，你就发现，一切都是值得的。</p>
<h3 id="模块设计">模块设计</h3>
<p>将登录SDK的模块引入，使得Flutter内部可以通过MethodChannel来调用Android的方法</p>
<p>登录SDK的特点：</p>
<p>1.无需实现UI界面；</p>
<p>2.需要设置页面监听；</p>
<p>3.接收回调之后可以及时展示到用户界面上</p>
<h3 id="登录sdk的引入">登录SDK的引入</h3>
<p>由于Flutter默认不支持<code>armeabi</code>的CPU架构，并且由于我们是并行开发，所以改动太多配置文件也会增加同学们的学习成本。所以，这里我们直接让登录SDK提供了支持了64位CPU架构测试AAR。<br>
同时，我们在android目录下修改了如下配置：</p>
<p>android目录下,修改了build.gradle文件：</p>
<pre><code>
buildscript {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
        mavenLocal()
        maven {
            url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
        }
        google()
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
    }
}

</code></pre>
<p>app目录下，修改了build.gradle添加了如下依赖<code>这些依赖都是必须的</code>：</p>
<pre><code>implementation 'com.wuba.wuxian.sdk:login:2.1.6.4.1-test'
    implementation 'com.wuba.wuxian.third:weichatsoter:1.3.10'
    implementation 'com.wuba.certify:deviceid:2.2.11'
    implementation 'com.wuba.xxzl:fastlogin:2.0.2.0'
    implementation 'io.reactivex:rxjava:1.3.8'
    implementation 'io.reactivex:rxandroid:1.2.1'
</code></pre>
<h3 id="flutter添加调用">Flutter添加调用</h3>
<p>在flutter的页面上，开发者可以随便使用UI元素，通过MethodChannel建立回调通道，在UI控件上设置点击事件调起登录并监听登录结果、<br>
通过platform.invokeMethod调起对应的登录方式、setState来设置结果、flutter监听变化后，会刷新并展示；</p>
<h4 id="flutter的调用">Flutter的调用</h4>
<p>主要是在<code>WubaLoginClientTestComponent</code>类里面；</p>
<pre><code>///定义一个MethodChannel
static const platform = const MethodChannel('com.wuba.flutter.flutter_hades/login');

///具体的调用方法
child: GestureDetector(
              child: new Row(
                children: &lt;Widget&gt;[
                  new Text(
                    '调起58登录: ' + _loginResult,
                    style: new TextStyle(
                        color: const Color(0xff353535), fontSize: 16.0),
                  ),
                ],
              ),
              onTap: _startWubaLogin,
            ),
            
///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

</code></pre>
<h4 id="接收回调刷新ui">接收回调刷新UI</h4>
<pre><code>///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

  String _loginResult = '';
  Future&lt;Null&gt; _startWubaLogin() async {
    String loginResult;
    try{
      loginResult = await platform.invokeMethod('wubaLogin');
    } on PlatformException catch (e){
      loginResult = &quot;error&quot;;
    }

    setState(() {
      _loginResult = loginResult;
    });
  }
</code></pre>
<h3 id="android接收调用">Android接收调用</h3>
<h4 id="初始化">初始化</h4>
<p>登录SDK的初始化可以按需要选取构建项，通过构建者模式来构建（由于第三方登录微信登录需要正式签名，所以引入目前也无法调用，所以暂时先不引入）：</p>
<pre><code>        LoginSdk.LoginConfig loginConfig = new LoginSdk.LoginConfig()
                //根据统一开关，上线后关闭log
                .setLogLevel(ILogger.STANDARD_LOG)
                //必选，设置product id, 由产品统一约定
                .setProductId(&quot;58app&quot;)
                .setLogoResId(R.drawable.wb_new_icon)
                //可选，如果集成三方登录，则设置相应的开放平台key
//                .setThirdLoginConfig(WubaSettingCommon.QQ_API_KEY, WubaSettingCommon.CONSUMER_KEY_WEIXIN, WubaSettingCommon.CONSUMER_KEY_SINA, WubaSettingCommon.REDIRECT_URL_SINA)
                .setNeedInitFaceVerify(true, &quot;Xenh6dVg&quot;)
                .setIsLoginRelyOnUserInfo(true)
                .setGatewayLoginAppId(&quot;ef2b526cdb4948b1bf7556f23d0a15da&quot;);
        //初始化
        LoginSdk.register(this, loginConfig);
</code></pre>
<h4 id="设置回调">设置回调</h4>
<p>设置通道：</p>
<pre><code>  private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
</code></pre>
<p>接收Flutter发送过来的调用，并调用登录SDK：</p>
<pre><code>LoginClient.register(mLoginCallback);
    new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
                if(call.method.equals(&quot;wubaLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaPhoneLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.PHONE_LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaRegister&quot;)){
                  LoginClient.launch(MainActivity.this, Request.REGISTER);
                  mResult = result;
                } else if(call.method.equals(&quot;getUserID&quot;)){
                  result.success(LoginClient.getUserID(MainActivity.this));
                } else if(call.method.equals(&quot;getUserPPU&quot;)){
                  result.success(LoginClient.getTicket(MainActivity.this, &quot;.58.com&quot;, &quot;PPU&quot;));
                } else if(call.method.equals(&quot;getUserName&quot;)){
                  result.success(LoginClient.getUserName(MainActivity.this));
                } else {
                  result.notImplemented();
                }
              }
            });
</code></pre>
<p>页面可以销毁后，给出去回调：</p>
<pre><code>LoginCallback mLoginCallback = new SimpleLoginCallback(){
    @Override
    public void onLogin58Finished(boolean isSuccess, String msg, LoginSDKBean loginSDKBean) {
      super.onLogin58Finished(isSuccess, msg, loginSDKBean);
        if(mResult != null){
          if(isSuccess){
            mResult.success(msg);
          }
        }
    }
  };
</code></pre>
<h2 id="细说methodchannel">细说MethodChannel</h2>
<h3 id="什么是methodchannel">什么是MethodChannel？</h3>
<p>《Flutter中文网》上面描述的标题是：插件开发：Android端API实现，也就是说，MethodChannel是Flutter实现与Android通过API交互的插件。通过上面的例子，我们也可以清楚的回顾它的一些特点，Flutter即时调用，Android得到反馈，Flutter进行UI展示，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="flutter_api.png" alt="flutter_api.png"></figure>
<h3 id="它的主要流程是什么">它的主要流程是什么？</h3>
<blockquote>
<p>1.在flutter端：设置一个MethodChannel：static const platform = const MethodChannel('samples.flutter.io/battery');</p>
<p>2.在flutter端：通过invoke方法调用：await platform.invokeMethod('getBatteryLevel');</p>
<p>3.在flutter端：写UI来接收回调<br>
children: [<br>
new RaisedButton(<br>
child: new Text('Get Battery Level'),<br>
onPressed: _getBatteryLevel,<br>
),<br>
new Text(_batteryLevel),<br>
],</p>
<p>4.在android端：调用setMethodCallHandler方法：</p>
<p>new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(<br>
new MethodCallHandler() {<br>
@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
// TODO<br>
}<br>
});</p>
<p>5.在android端：实现onMethodCall回调：</p>
<p>@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
if (call.method.equals(&quot;getBatteryLevel&quot;)) {<br>
int batteryLevel = getBatteryLevel();<br>
if (batteryLevel != -1) {<br>
result.success(batteryLevel);<br>
} else {<br>
result.error(&quot;UNAVAILABLE&quot;, &quot;Battery level not available.&quot;, null);<br>
}<br>
} else {<br>
result.notImplemented();<br>
}<br>
}</p>
</blockquote>
<h3 id="它的原理是什么">它的原理是什么？</h3>
<p>针对上面的流程我们有两个疑问：</p>
<ol>
<li>
<p>platform.invokeMethod怎么把对应的method调起来的？</p>
</li>
<li>
<p>result.success是如何回调到</p>
</li>
</ol>
<h3 id="源码阅读">源码阅读</h3>
<p>上源码之前，我们先来看个图：</p>
<p>官方说明：</p>
<blockquote>
<p>A named channel for communicating with platform plugins using asynchronous method calls.Method calls are encoded into binary before &gt;being sent, and binary results received are decoded into Dart values. The [MethodCodec] used must be compatible with the one used by the platform plugin. This can be achieved by creating a method channel counterpart of this channel on the platform side. The Dart type of arguments and results is <code>dynamic</code>, but only values supported by the specified [MethodCodec] can be used. The use of unsupported values should be considered programming errors, and will result in exceptions being thrown. The null value is supported for all codecs. The logical identity of the channel is given by its name. Identically named channels will interfere with each other's communication.</p>
</blockquote>
<blockquote>
<p>大概的意思：定义一个管道，利用异步方法跟平台插件进行交互。方法里面的参数必须是一个特定独一无二的，不能是特殊字符或者已经定义好的有含义的标识符。</p>
</blockquote>
<p>MethodChannel一共有三个参数，它们分别是：String name、StandardMethodCodec codec、binaryMessenger；</p>
<p>其中name是必选参数、后面两个是可选参数；</p>
<p>name:格式通常是：包名/方法名，例如：'com.wuba.flutter.flutter_hades/login'；</p>
<p>StandardMethodCodec codec：标准方法编码，有点类似于Java的序列化，里面有两个方法：ByteData encodeMessage(T message);和T decodeMessage(ByteData message);</p>
<p>BinaryMessenger ：这个类就是用来追踪管道的message的，分发并记录每一个注册了管道的handler并回调；</p>
<h4 id="platforminvokemethod">platform.invokeMethod</h4>
<p>MethodHandler提供了一个方法invokeMethod，这个方法就是调用的入口函数：</p>
<pre><code>@optionalTypeArgs
  Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [ dynamic arguments ]) async {
    assert(method != null);
    final ByteData result = await binaryMessenger.send(
      name,
      codec.encodeMethodCall(MethodCall(method, arguments)),
    );
    if (result == null) {
      throw MissingPluginException('No implementation found for method $method on channel $name');
    }
    final T typedResult = codec.decodeEnvelope(result);
    return typedResult;
  }
</code></pre>
<p>我们主要是看这个binaryMessenger.send的方法：</p>
<pre><code>@override
  Future&lt;ByteData&gt; send(String channel, ByteData message) {
    final MessageHandler handler = _mockHandlers[channel];
    if (handler != null)
      return handler(message);
    return _sendPlatformMessage(channel, message);
  }
</code></pre>
<p>通过Map存储到key-value，key代表的是channel，就是我们刚才设置的MethodChannel中的name，value是handler，这个就相当于track。</p>
<p>接下来调用Flutter的UI顶层的实现方式：</p>
<pre><code>ui.window.sendPlatformMessage(channel, message, (ByteData reply) {
      try {
        completer.complete(reply);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: ErrorDescription('during a platform message response callback'),
        ));
      }
    });
</code></pre>
<p>ui.window类似于android里面的window？</p>
<pre><code>void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) {
    final String error =
        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);
    if (error != null)
      throw Exception(error);
  }
</code></pre>
<p>跟到这里，我们发现调用的Native的方法：</p>
<pre><code>String _sendPlatformMessage(String name,
                              PlatformMessageResponseCallback callback,
                              ByteData data) native 'Window_sendPlatformMessage';
</code></pre>
<p>接下来，我们看c++是怎么写的：</p>
<pre><code>Dart_Handle SendPlatformMessage(Dart_Handle window,
                                const std::string&amp; name,
                                Dart_Handle callback,
                                const tonic::DartByteData&amp; data) {
  UIDartState* dart_state = UIDartState::Current();

  ...

  fml::RefPtr&lt;PlatformMessageResponse&gt; response;
  if (!Dart_IsNull(callback)) {
    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(
        tonic::DartPersistentValue(dart_state, callback),
        dart_state-&gt;GetTaskRunners().GetUITaskRunner());
  }
  if (Dart_IsNull(data.dart_handle())) {
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));
  } else {
    const uint8_t* buffer = static_cast&lt;const uint8_t*&gt;(data.data());

    // data数据部位null，会走下面这块代码
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(
            name, std::vector&lt;uint8_t&gt;(buffer, buffer + data.length_in_bytes()),
            response));
  }

  return Dart_Null();
}
</code></pre>
<p>我们看这里有一段代码，叫做HandlePlatformMessage，这段代码在<code>../engine/shell/common/engine.cc</code></p>
<pre><code>void Engine::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  if (message-&gt;channel() == kAssetChannel) {
    HandleAssetPlatformMessage(std::move(message));
  } else {
    delegate_.OnEngineHandlePlatformMessage(std::move(message));
  }
}

void Shell::OnEngineHandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
    
  ...
  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(
      [view = platform_view_-&gt;GetWeakPtr(), message = std::move(message)]() {
        if (view) {
          view-&gt;HandlePlatformMessage(std::move(message));
        }
      });
}
</code></pre>
<p>platform_view_是一个继承了PlatformView类的PlatformViewAndroid对象，该对象在创建AndroidShellHolder对象时被创建。view-&gt;HandlePlatformMessage执行以下方法，<code>../engine/shell/platform/android/platform_view_android.cc</code></p>
<pre><code>void PlatformViewAndroid::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  JNIEnv* env = fml::jni::AttachCurrentThread();
  fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.get(env);
  if (view.is_null())
    return;

  int response_id = 0;
  if (auto response = message-&gt;response()) {
    response_id = next_response_id_++;
    pending_responses_[response_id] = response;
  }
  auto java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());
  if (message-&gt;hasData()) {
    fml::jni::ScopedJavaLocalRef&lt;jbyteArray&gt; message_array(
        env, env-&gt;NewByteArray(message-&gt;data().size()));
    env-&gt;SetByteArrayRegion(
        message_array.obj(), 0, message-&gt;data().size(),
        reinterpret_cast&lt;const jbyte*&gt;(message-&gt;data().data()));
    message = nullptr;

    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.
    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),
                                     message_array.obj(), response_id);
  } else {
    ...
  }
}
</code></pre>
<p>于是，我们最终跟到了JNI的最终方法，它调用的是<code>FlutterJNI.java</code>中的handlePlatformMessage：</p>
<pre><code>static jmethodID g_handle_platform_message_method = nullptr;
void FlutterViewHandlePlatformMessage(JNIEnv* env,
                                      jobject obj,
                                      jstring channel,
                                      jobject message,
                                      jint responseId) {
  env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,
                      responseId);
  FML_CHECK(CheckException(env));
}

private void handlePlatformMessage(String channel, byte[] message, int replyId) {
    if (this.platformMessageHandler != null) {
        this.platformMessageHandler.handleMessageFromDart(channel, message, replyId);
    }
}

public void handleMessageFromDart(final String channel, byte[] message, final int replyId) {
    FlutterNativeView.this.assertAttached();
    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);
    if (handler != null) {
        try {
            ByteBuffer buffer = message == null ? null : ByteBuffer.wrap(message);
            handler.onMessage(buffer, new BinaryReply() {
                private final AtomicBoolean done = new AtomicBoolean(false);

                public void reply(ByteBuffer reply) {
                    if (!FlutterNativeView.this.isAttached()) {
                        Log.d(&quot;FlutterNativeView&quot;, &quot;handleMessageFromDart replying ot a detached view, channel=&quot; + channel);
                    } else if (this.done.getAndSet(true)) {
                        throw new IllegalStateException(&quot;Reply already submitted&quot;);
                    } else {
                        if (reply == null) {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
                        } else {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());
                        }

                    }
                }
            });
        } catch (Exception var6) {
            Log.e(&quot;FlutterNativeView&quot;, &quot;Uncaught exception in binary message listener&quot;, var6);
            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
        }

    } else {
        FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
    }
}
</code></pre>
<p>这里面我们看到这样一段代码，    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);<br>
那这个handler是如何根据channel跟踪到的呢？我们已经到Java方法了啊可。</p>
<p>所以，我们试着回想一下，当时是不是在MainActivity里面也设置了个同名的String， 这个字符串有点似曾相识呢。由此猜想，这个handler可能是当时我们自己设进去的，我们来看看如下代码<code>setMethodCallHandler</code>：</p>
<pre><code>private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
              }
            });
            
            public void setMethodCallHandler(@Nullable MethodChannel.MethodCallHandler handler) {
    this.messenger.setMessageHandler(this.name, handler == null ? null : new MethodChannel.IncomingMethodCallHandler(handler));
}

public void setMessageHandler(String channel, BinaryMessageHandler handler) {
    this.mNativeView.setMessageHandler(channel, handler);
}
</code></pre>
<p>接下来我们继续看这个<code>handler.onMessage()</code>方法：</p>
<pre><code>public void onMessage(ByteBuffer message, final BinaryReply reply) {
    MethodCall call = MethodChannel.this.codec.decodeMethodCall(message);

    try {
        this.handler.onMethodCall(call, new MethodChannel.Result() {
            public void success(Object result) {
                reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));
            }

            public void error(String errorCode, String errorMessage, Object errorDetails) {
                reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));
            }

            public void notImplemented() {
                reply.reply((ByteBuffer)null);
            }
        });
    } catch (RuntimeException var5) {
        Log.e(&quot;MethodChannel#&quot; + MethodChannel.this.name, &quot;Failed to handle method call&quot;, var5);
        reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(&quot;error&quot;, var5.getMessage(), (Object)null));
    }

}
</code></pre>
<p>方法中首先将从c++层传递过来的消息通过codec解码为MethodCall对象，然后调用MainActivity中实现的MethodHandler的onMethodCall方法，改方法实现中会执行android的API调用，然后调用result.success()方法，通过reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));将结果数据编码后进行返回。reply方法中会调用FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());方法将响应结果返回。</p>
<p>然后回调给C++层。</p>
<p>最终回调给UI层，调用setState完成整个更新。</p>
<h3 id="总结">总结</h3>
<p>1.Flutter调用invokeMethod方法，将code转码和并建立跟踪对应的Messagehandle；</p>
<p>2.在c++层对其进行封装，通过sendPlatformMessage调用JNI方法；</p>
<p>3.根据调用方法找到最终调用已经注册好的Java对象的对应方法；</p>
<p>4.获取回调结果并将结果返回给C++层；</p>
<p>5.C++层获取结果后最终返回给Flutter的setState方法，刷新UI；</p>
<h3 id="预览效果图">预览效果图</h3>
<figure data-type="image" tabindex="2"><img src="flutter_loginsdk.png" alt="flutter_loginsdk.png"></figure>
<h3 id="接入报错">接入报错</h3>
<p>1.A problem occurred configuring project ':sqflite'.</p>
<p>Could not download groovy-all.jar</p>
<p>如果出现资源找不到，一般都是gradle的配置文件出现了问题，我们可以通过引入配置来解决：在工程-&gt;android-&gt;build.gradle下，对于buildscript和allprojects中的repositories进行修改，添加如下代码：</p>
<pre><code>maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
</code></pre>
<p>2.注册跳转页面需要添加路由</p>
<p>注册一个页面，虽然不需要像android原生一样在androidmanifest.xml文件中注册activity，但是在flutter里面，需要注册路由。路由分为静态路由和动态路由，只有注册后，才能完成跳转；</p>
<p>3.This Overlay widget cannot be marked as needing to build because the framework is already in the<br>
process of building widgets</p>
<p>我通过A页面添加了一个GestureDetector的onTap事件跳转进入B页面，但是当我用同样的方法在B页面再添加GestureDetector的时候，在onTap里面添加之后就会报错；</p>
<pre><code>onTap: _onWubaLoginClick(), 
看见没，上面代码，原来是多加了一个()，Java里调用方法就是有括号的啊，再说你这个报错可真的是让我好找啊~
</code></pre>
<p>4.flutter工程下，无法编译android下的MainActivity.java</p>
<p>新开一个工程，开发flutter的android工程即可</p>
<p>5.善于利用工具</p>
<p>在进行flutter开发的时候，我们难免会遇到各种各样的问题，其实大部分我们都可以在官方文档里面得到解决。</p>
<p>所以有事没事，看看官网：<br>
https://flutterchina.club/platform-channels/</p>
<p>6.引入58的第三方找不到库</p>
<p>其实是没有配置maven仓库，需要</p>
<pre><code>mavenLocal()
maven {
   url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
}
</code></pre>
<p>7.java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; is 32-bit instead of 64-bit</p>
<p>58APP接入的是32位的，那么为啥在这个flutter的工程里面，它需要引入的是64位的呢？</p>
<p>8.libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0</p>
<pre><code>java.lang.UnsatisfiedLinkError: dlopen failed: file offset for the library &quot;/data/user/0/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0
        at java.lang.Runtime.load0(Runtime.java:928)
        at java.lang.System.load(System.java:1621)
        at com.wuba.uc.RsaCryptService.b(RsaCryptService.java:43)
        at com.wuba.uc.RsaCryptService.a(RsaCryptService.java:24)
        at com.wuba.loginsdk.internal.b.process(InitCommon.java:24)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:144)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:60)
        at com.wuba.flutter.flutter_hades.WubaApplication.registeWubaLogin(WubaApplication.java:31)
        at com.wuba.flutter.flutter_hades.WubaApplication.onCreate(WubaApplication.java:15)
        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1119)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5881)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
</code></pre>
<p>9.support-v4</p>
<pre><code>java.lang.RuntimeException: Unable to get provider com.wuba.loginsdk.provider.PassportFileProvider: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at android.app.ActivityThread.installProvider(ActivityThread.java:6447)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        at android.app.ActivityThread.installProvider(ActivityThread.java:6423)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950) 
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862) 
        at android.app.ActivityThread.-wrap1(Unknown Source:0) 
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690) 
        at android.os.Handler.dispatchMessage(Handler.java:105) 
        at android.os.Looper.loop(Looper.java:176) 
        at android.app.ActivityThread.main(ActivityThread.java:6701) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783) 
    	Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Landroid/support/v4/content/FileProvider;
        at java.lang.VMClassLoader.findLoadedClass(Native Method)
        at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:363)
        		... 12 more
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;android.support.v4.content.FileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        		... 15 more
</code></pre>
<p>10.wlog&amp;soter&amp;两个图片资源找不到</p>
<h3 id="参考文章">参考文章</h3>
<p>https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html<br>
https://www.jianshu.com/p/185c42fe002b</p>
]]></content>
    </entry>
</feed>