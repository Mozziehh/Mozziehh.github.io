<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Mozziehh.github.io</id>
    <title>差不多胡先生</title>
    <updated>2019-11-22T02:13:31.194Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Mozziehh.github.io"/>
    <link rel="self" href="https://Mozziehh.github.io/atom.xml"/>
    <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
    <logo>https://Mozziehh.github.io/images/avatar.png</logo>
    <icon>https://Mozziehh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 差不多胡先生</rights>
    <entry>
        <title type="html"><![CDATA[GifView在android的应用指南]]></title>
        <id>https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan</id>
        <link href="https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan">
        </link>
        <updated>2019-11-22T00:48:04.000Z</updated>
        <content type="html"><![CDATA[<p>##背景<br>
目前，大部分市场应用在展示产品的时候都会选择图片配文字的形式，显得更加直观。随着人们手机设备性能的提高与Wifi以及4G网络的提速，为了能让用户的体验更加立体，很多APP在”秀“自己的产品的时候都会直接展示视频。然而图片和视频之间还是有一定的流量差距，为了让用户可以更好的过渡这一差距，图片展示gifview，点击gifview观看视频这样的用户行为正在慢慢的被接受。</p>
<p>##部落来袭<br>
58部落目前是非常大的用户群体，他们也会经常发表一些自己的作品，看法，目前也是列表页展示图片，点击进入后展示详情。那么如果需要有这个过渡，就需要在列表页上增加gifview来达到更好的曝光率。</p>
<p>##大众点评&amp;马蜂窝</p>
<p>###点评 &amp; 马蜂窝 效果展示</p>
<!--todo-->
<p>###效果分析<br>
我们先来自己想想，如果要是我们自己来实现这个效果应该如何来做：</p>
<p>两种方法：</p>
<p><em><strong>方案一：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义GifView，包含展示静态图和gif图的功能；</p>
<p>3.进入页面，请求首页，获取json得到gif；</p>
<p>4.解析gif的第一帧，得到Image的比特流，让GifView展示图片；</p>
<p>5.图片展示完成后，自定义GifView播放GifView；</p>
<hr>
<p>优点：</p>
<p>简化json输出，json里面的返回值返回一套gif就可以，自己解析gif的第一帧用于展示图片；</p>
<p>缺点：</p>
<p>速度慢，本来列表页快速滑动展示大图片都考虑加载时间，如果再去自己解析，成本太高，内存要求大；</p>
<hr>
<p><em><strong>方案二：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义ImageView，展示Image；</p>
<p>3.自定义GifView，展示gif图；</p>
<p>4.进入页面，请求首页，获取json得到image和gif；</p>
<p>5.自定义ImageView展示imageview占位，然后紧接着加载gif；</p>
<p>优点：</p>
<p>1.速度快；</p>
<p>2.解耦，一旦出现问题，可以快速降级；</p>
<hr>
<p>另外，从版本的迭代的上来考虑，我个人更倾向于方案二：</p>
<p>###点评效果深入研究<br>
接下来，先上常规操作让我们看一下大众点评是不是酱样婶的吧：</p>
<p>####dump一下，你不知道<br>
Running activities (most recent first):<br>
Run #1: ActivityRecord{1b8520 u0 com.dianping.v1/.NovaMainActivity t15792}<br>
Run #0: ActivityRecord{2a47964 u0 com.tencent.mm/.ui.LauncherUI t15793}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{945d44 u0 com.miui.home/.launcher.Launcher t1}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{52d96ba u0 com.android.systemui/.recents.RecentsActivity t15788}<br>
ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)<br>
User #0: state=RUNNING_UNLOCKED</p>
<p>首先，我们来看一下dump信息，NovaMainActivity，是它的首页，但是显然根据这个我们没有任何头绪。正向查一个控件我们要知道哪个布局，哪个控件，哪个View。所以，我想能不能看看Log，结果还真的让我找到了蛛丝马迹。</p>
<p>####logcat<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been started:</p>
<p>在我快速滑动的时候，我发现居然有这么些可爱的代码在控制台打印出来。于是，我就看到了新的曙光。</p>
<p>万幸的是，我还在logcat里面额外看到了webp格式的图片和动图的日志：</p>
<pre><code>//动图
https://img.xxx.net/coverpic/2d348f2ea08616ab1e8c652800373740.webp
//非动图
https://img.xxx.net/coverpic/4cf4cfa5469f95444986f83f194f6acb35706.jpg%40320w_426h_1e_1c_1l%7Cwatermark%3D0.webp
</code></pre>
<p>这个日志初步印证了我的想法，我决定看一下&quot;GifImageVIew&quot;都干了啥。点评是有混淆和做了加壳的，常规的jd-gui查看的代码看不到。通过脱壳，获取其相关代码，为了更好地理解，里面的关键代码做了注释：</p>
<pre><code>public class GifImageView extends FrameLayout {

    public GifImageView(Context context) {
        super(context);
    }
    public static final String TAG = &quot;GifImageView&quot;;
    public PicassoImageView gifImageView; //Picasso 
    private String gifIvGroup;
    private double gifPriority; //gif的优先级
    private String gifUrl; //gif的url
    public PicassoImageView imageView;  //又来一个Picasso

	 //构造函数
    public GifImageView(Context context) {
        this(context, null);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet) {
        this(context, attributeSet, 0);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
        init(context);
    }
    
    //初始化 *关键*
    private void init(Context context) {
        LayoutParams layoutParams = new FrameLayout.LayoutParams(-1, -1);
        this.imageView = new PicassoImageView(context);
        this.gifImageView = new PicassoImageView(context);
        this.gifImageView.setFadeInDisplayEnabled(false);
        addView(this.gifImageView, layoutParams);
        addView(this.imageView, layoutParams);
        //开始进行gif加载的设置
        this.gifImageView.setOnLoadChangeListener(new u() {

            //gif加载开始
            public void onImageLoadStart() {
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
  
            //gif加载完成
            public void onImageLoadSuccess(Bitmap bitmap) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif success : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.GONE);
            }
  
            //加载失败如何处理
            public void onImageLoadFailed() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif failed : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
        });
    }
    
    //设置布局
    public void setLayoutParams(LayoutParams layoutParams) {
        super.setLayoutParams(layoutParams);
        setViewParams(this.imageView, layoutParams);
        setViewParams(this.gifImageView, layoutParams);
    }


    //设置布局
    private void setViewParams(View view, LayoutParams layoutParams) {
        LayoutParams layoutParams2 = view.getLayoutParams();
        if (layoutParams2 instanceof FrameLayout.LayoutParams) {
            layoutParams2.width = layoutParams.width;
            layoutParams2.height = layoutParams.height;
            view.setLayoutParams(layoutParams2);
        }
    }


    //开始执行gif播放
    public void startGif() {
        if (this.gifImageView.isImageAnimating()) {
            Log.d(TAG, &quot;gifIv has already been started: &quot;);
        } else {
            this.gifImageView.setAnimatedImageLooping(-1);
            this.gifImageView.startImageAnimation();
            Log.d(TAG, &quot;gifIv has been started: &quot;);
        }
    }

    //停止执行gif播放
    public void stopGif() {
        if (this.gifImageView.isImageAnimating()) {
            this.gifImageView.setAnimatedImageLooping(0);
            this.gifImageView.stopImageAnimation();
            Log.d(TAG, &quot;gifIv has been stoped: &quot;);
        } else {
            Log.d(TAG, &quot;gifIv has already been stoped: &quot;);
        }
    }

    //设置image和gif图像地址
    public void setGifImage(String str, String str2) {

        this.imageView.setImage(str);
        this.gifImageView.setAnimatedImageLooping(0);
        this.gifImageView.setImage(str2);
        this.imageView.setVisibility(0);
        this.gifUrl = str2;
        if (TextUtils.isEmpty(str2)) {
            GifImageViewManager.getInstance().addGifIv(this);
        } else {
            GifImageViewManager.getInstance().removeGifIv(this);
        }
    }

    public void setAnimatedImageLooping(int i) {
        this.imageView.setAnimatedImageLooping(i);
    }

    public void setScaleType(ImageView.ScaleType scaleType) {
        this.imageView.setScaleType(scaleType);
        this.gifImageView.setScaleType(scaleType);
    }

    //支持直接设置drawable
    public void setImageDrawable(Drawable drawable) {
        this.imageView.setVisibility(0);
        this.imageView.setImageDrawable(drawable);
    }
   
   .....此处省略1000字
}
</code></pre>
<p>另外，还发现它的自定义图片PicassoImageView（好像跟git上面的Picasso没什么关系）。</p>
<pre><code>import com.dianping.imagemanager.DPImageView;
public class PicassoImageView extends DPImageView implements Clippable {
}


public class DPImageView extends ImageView implements OnClickListener {
}
</code></pre>
<p>还有。。。。咳咳，让我们点到为止吧。</p>
<p>###点评效果总结<br>
所以，点评的基本逻辑跟我之前说的第二种方案几乎无差，我们再来回顾一下：</p>
<p>1.自定义View命名为PicassoImageView，可以展示Gif图也可以展示ImageView；</p>
<p>2.封装GifImageView，里面包含两个PicassoImageView；</p>
<p>3.其中一个PicassoImageView展示imageview占位，同时另外一个PicassoImageView进行gif的加载，加载完成后，把第一个PicassoImageView消失；</p>
<p>so，感谢点评为我们提供宝贵的思路，接下来让我们去看看马蜂窝是怎么实现的吧。</p>
<p>###马蜂窝效果深入研究<br>
####dump之后依然没有有用信息<br>
也不是完全没有用，至少你知道了程序的入口在哪里。<br>
####看看logcat</p>
<pre><code>2019-09-18 16:53:11.786 25404-25919/? D/SoLoader: About to load: libgifimage.so
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so not found on /data/data/com.mfw.roadbook/lib-main
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so found on /data/app/com.mfw.roadbook-U4eSwGYqvGPqtvkBe8R4gw==/lib/arm
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: Not resolving dependencies for libgifimage.so
2019-09-18 16:53:11.795 25404-25919/? D/SoLoader: Loaded: libgifimage.so
</code></pre>
<p>嗯，果然，看看还是有收获的。又Get到一个新知识，可以通过加载so（libgifimage.so）的方式，提升GifView加载速度。</p>
<p>###马蜂窝效果总结</p>
<p>在实际体验的过程中，我发现滑动到没有加载的图片时，马蜂窝会用一个加载的灰色占位图占位，然后去下载gif，它旁边的图片都展示出来了，gif还没有下载完，体验不是很好。这点可以借鉴一下大众点评的。</p>
<p>由于马蜂窝也加壳了，脱壳其实是很开(fei)心(shen)的，有了点评的思路，我就没有特别深入的研究马蜂窝的内部实现，其实直接看效果也能看出个大概。</p>
<p>##有没有开源的库呢？<br>
我们并不想把点评或者马蜂窝的代码直接拷过来，毕竟人家没有开源，而且也不一定契合我们的风格。在git上找一个demo实现以下？<br>
于是，我看到了这个android-gif-drawable，这个看起来还不错，7K的赞，Fork了1.6K，正合我意，来吧，研究一波。</p>
<p>###API解读<br>
android-gif-drawable是通过JNI来渲染帧的，比使用WebView或者Movie性能要好一些。</p>
<p><strong>依赖</strong></p>
<pre><code>dependencies {
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'
}

repositories {
	mavenCentral()
	maven { 
		url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; }
	}
	dependencies {
    i	mplementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.+'
	}

&lt;dependency&gt;
    &lt;groupId&gt;pl.droidsonroids.gif&lt;/groupId&gt;
    &lt;artifactId&gt;android-gif-drawable&lt;/artifactId&gt;
    &lt;version&gt;insert latest version here&lt;/version&gt;
    &lt;type&gt;aar&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
<p>基本使用：</p>
<pre><code>//1. asset文件
GifDrawable gifFromAssets = new GifDrawable( getAssets(), &quot;anim.gif&quot; );

//2. resource (drawable or raw)
GifDrawable gifFromResource = new GifDrawable( getResources(), R.drawable.anim );

//3. byte array
byte[] rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//4. FileDescriptor
FileDescriptor fd = new RandomAccessFile( &quot;/path/anim.gif&quot;, &quot;r&quot; ).getFD();
GifDrawable gifFromFd = new GifDrawable( fd );

//5. file path
GifDrawable gifFromPath = new GifDrawable( &quot;/path/anim.gif&quot; );

//6. file
File gifFile = new File(getFilesDir(),&quot;anim.gif&quot;);
GifDrawable gifFromFile = new GifDrawable(gifFile);

//7. AssetFileDescriptor
AssetFileDescriptor afd = getAssets().openFd( &quot;anim.gif&quot; );
GifDrawable gifFromAfd = new GifDrawable( afd );

//8. InputStream (it must support marking)
InputStream sourceIs = ...
BufferedInputStream bis = new BufferedInputStream( sourceIs, GIF_LENGTH );
GifDrawable gifFromStream = new GifDrawable( bis );

//9. direct ByteBuffer
ByteBuffer rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//10.加载网络图片其实本质上也离不开上面这些内容，推荐RxJava；
</code></pre>
<p>额外的API：</p>
<pre><code>- 停止GIF动画
·stop() 

- 开始GIF动画
·start() 

- GIf动画是否在执行
isRunning() 

- 重置GIF动画
reset() 

- 控制执行动画的速度
setSpeed(float factor) 

- 从该动画的执行位置开始执行
seekTo(int position) 

- 动画的持续时间
getDuration() 

- 当前动画的播放时间
getCurrentPosition() 
</code></pre>
<p>调用方法也是非常简单：</p>
<pre><code>&lt;pl.droidsonroids.gif.GifImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:src=&quot;@drawable/src_anim&quot;
android:background=&quot;@drawable/bg_anim&quot;
/&gt;

try {
            GifDrawable gifFromResDrawable = new GifDrawable( mContext.getResources(), getIntGifRes(imageData.gifUrl));
            viewHolder.gifImageView.setImageDrawable(gifFromResDrawable);
            viewHolder.gifImageView.setVisibility(View.VISIBLE);
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>
<p>所以，我们看到，本质上还是这个GifDrawable在起作用，因为GifImageView继承的是ImageView。</p>
<p>###效果如下</p>
<!--todo-->
<p>##撸一个Demo<br>
我们看完了大众点评、马蜂窝、github上的实现效果。它们有自己的优点，结合58自己的技术特点，我打算采用的技术架构：FRESCO + RecyclerView的StaggeredGridLayoutManager，具体实现思路如下：</p>
<p>###使用StaggeredGridLayoutManager实现瀑布布局；</p>
<pre><code>RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);
    StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2,
            StaggeredGridLayoutManager.VERTICAL);
    recyclerView.setLayoutManager(layoutManager);

    FrescoAdapter adapter = new FrescoAdapter(this, DataUtils.getFrescoImageData());
    recyclerView.setAdapter(adapter);
</code></pre>
<p>###自定义Adapter继承自RecyclerView.Adapter，用于加载图片和GIF：</p>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

    SimpleDraweeView draweeImage;
    SimpleDraweeView draweeGif;
    TextView textView;
    public ViewHolder(@NonNull View itemView) {
        super(itemView);
        draweeImage = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview);
        draweeGif = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview_gif);
        textView = (TextView) itemView.findViewById(R.id.item_draweeview_text);
    }
}
</code></pre>
<p>###加载图片和GIF</p>
<pre><code>/**
     * Fresco 加载webp图片
     * @param draweeView
     * @param imageUrl
     */
    public static void loadWebpImage(final Context context, final SimpleDraweeView draweeView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()
                .setUri(Uri.parse(imageUrl))
                .setAutoPlayAnimations(true)
                .setOldController(draweeView.getController())
                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }

                        if(imageData.getScale() == 0){
                            int width = imageInfo.getWidth();
                            int height = imageInfo.getHeight();
                            float scale = (float) width/ (float) height;
                            imageData.setScale(scale);
                        }
                        final ViewGroup.LayoutParams layoutParams = draweeView.getLayoutParams();
                        layoutParams.width = DisplayUtils.getScreenWidth((Activity) context) / 2 - DisplayUtils.dp2px(context,10);
                        layoutParams.height = (int) (layoutParams.width/ imageData.getScale());

                        imageData.setWidth(layoutParams.width);
                        imageData.setHeight(layoutParams.height);

                        imageData.setPosition(position);

                        draweeView.setLayoutParams(layoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        draweeView.setController(controller);

    }

    /**
     * Fresco 加载webpGID
     * @param imageView
     * @param imageUrl
     */
    public static void loadWebpGif(final Context context, final SimpleDraweeView imageView,final SimpleDraweeView gifView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()

                .setUri(Uri.parse(imageUrl))

                .setAutoPlayAnimations(true)

                .setOldController(gifView.getController())

                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }
                        final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
                        final ViewGroup.LayoutParams gifLayoutParams = gifView.getLayoutParams();
                        gifLayoutParams.width = layoutParams.width;
                        gifLayoutParams.height = layoutParams.height;

                        gifView.setLayoutParams(gifLayoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        gifView.setController(controller);
    }
</code></pre>
<p>###效果如下：</p>
<!--todo-->
<p>###缺点与不足<br>
Demo里面还有很多的异常边界情况没有考虑，比如各类的容错判断，性能问题监控，等等</p>
<p>传送门：<a href="https://github.com/Mozziehh/GifView">github.com/mozzie</a></p>
<p>##参考文章</p>
<ol>
<li>
<p>https://www.jianshu.com/p/057f48df855b</p>
</li>
<li>
<p>https://github.com/koral--/android-gif-drawable</p>
</li>
<li>
<p>https://www.dev2qa.com/how-to-play-gif-file-use-android-graphics-movie-class/</p>
</li>
<li>
<p>https://blog.csdn.net/feather_wch/article/details/79558240</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过NDK实现Zxing二维码扫描放大功能]]></title>
        <id>https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng</id>
        <link href="https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng">
        </link>
        <updated>2019-11-22T00:43:25.000Z</updated>
        <content type="html"><![CDATA[<p> 在各个APP中几乎都能看见它的身影。二维码扫描虽然是一个普通的功能，但是在APP中占依然都放在很抢眼的位置。比如像淘宝、58这类APP主要解决PC端扫码登录，微信、支付宝这类主要使用支付，摩拜小蓝这类APP主要是用于扫码骑车。所以，能更快捷更方便的使用二维码，可以极大的提升用户体验。</p>
<p>##快捷与方便<br>
 曾经或许会有那么一个寒冷的夜晚，你骑着刚共享单车飞驰在回家的路上，突然，街边飘来哈尔滨烤冷面的香气让你不知不觉的来到那个小摊面前，迟疑了很久，你说了一句：“老板，来一份。。。再。。。加个肠。”昏暗的灯光下、其他的食客中，老板熟练的抄起手中的家伙，你熟练掏出手机，打开扫一扫，老板的二维码在你的手里一次次对焦、一次次放大，“滴”的一声，付钱，取餐，嗝~。<br>
 你有没有想过，为什么在扫描的过程中，被扫描的二维码会在扫描框里从模糊到清晰，然后再从清晰到模糊，周而复始？<br>
 你有没有想过，为什么在稍远的距离，二维码扫描就会慢慢放大？<br>
 是的，在这个寒冷的夜，为了能让你的手机更快速的识别出对方的二维码，我们做了很多。</p>
<p>##二维码解读</p>
<p>我们来看一下二维码扫描主要展示信息，主要分为功能图形和编码区格式。其中功能图形的位置探测图形、定位图形、矫正图形在定位的过程中起着举足轻重的地位。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/Mozziehh/mypapers/blob/master/images/qrcode_structure.png?raw=true" alt=""></figure>
<p>##二维码扫描的源码解读<br>
 从你拿出手机对准二维码直到扫描结束，整个过程都发生了什么？为了能让你生动的了解整个过程，我打算用下面的方式讲：<br>
打开相机执行扫描-&gt;获取Byte流-&gt;灰度-&gt;二值化-&gt;霍夫变换-&gt;找到二维码定位点-&gt;识别-&gt;返回结果。</p>
<p>###打开相机执行扫描</p>
<pre><code>private void initCamera(SurfaceHolder surfaceHolder) {
        if (surfaceHolder == null) {
            throw new IllegalStateException(&quot;No SurfaceHolder provided&quot;);
        }
        if (cameraManager.isOpen()) {
            Log.w(TAG, &quot;initCamera() while already open -- late SurfaceView callback?&quot;);
            return;
        }
        try {
            cameraManager.openDriver(surfaceHolder);
            // Creating the handler starts the preview, which can also throw a
            // RuntimeException.
            if (handler == null) {
                handler = new CaptureActivityHandler(this, cameraManager, DecodeThread.ALL_MODE);
            }

            initCrop();
        } catch (IOException ioe) {
            Log.w(TAG, ioe);
            displayFrameworkBugMessageAndExit();
        } catch (RuntimeException e) {
            // Barcode Scanner has seen crashes in the wild of this variety:
            // java.?lang.?RuntimeException: Fail to connect to camera service
            Log.w(TAG, &quot;Unexpected error initializing camera&quot;, e);
            displayFrameworkBugMessageAndExit();
        }
    }
</code></pre>
<p>###设置支持的二维码类型</p>
<p>目前二维码支持如下类型：<br>
<img src="https://i.loli.net/2019/06/17/5d0734bfd44a794589.png" alt="support-zxing-pic.png"><br>
代码在这里配置：</p>
<pre><code>// The prefs can't change while the thread is running, so pick them up once here.
    if (decodeFormats == null || decodeFormats.isEmpty()) {
      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
      decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) {
        decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) {
        decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) {
        decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) {
        decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) {
        decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) {
        decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
      }
    }
    hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
</code></pre>
<p>###获取相机预览的Byte流</p>
<pre><code>public class PreviewCallback implements Camera.PreviewCallback {

	private static final String TAG = PreviewCallback.class.getSimpleName();

	private final CameraConfigurationManager configManager;
	private Handler previewHandler;
	private int previewMessage;

	public PreviewCallback(CameraConfigurationManager configManager) {
		this.configManager = configManager;
	}

	public void setHandler(Handler previewHandler, int previewMessage) {
		this.previewHandler = previewHandler;
		this.previewMessage = previewMessage;
	}

	@Override
	public void onPreviewFrame(byte[] data, Camera camera) {
		Point cameraResolution = configManager.getCameraResolution();
		Handler thePreviewHandler = previewHandler;
		if (cameraResolution != null &amp;&amp; thePreviewHandler != null) {
			Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x, cameraResolution.y, data);
			message.sendToTarget();
			previewHandler = null;
		} else {
			Log.d(TAG, &quot;Got preview callback, but no handler or resolution available&quot;);
		}
	}

}

//在这里通过相机框获取bitmap的byte流
PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);

BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

</code></pre>
<p>###对bitmap的byte流解码</p>
<pre><code>if (formats != null) {
  boolean addOneDReader =
	  formats.contains(BarcodeFormat.UPC_A) ||
	  formats.contains(BarcodeFormat.UPC_E) ||
	  formats.contains(BarcodeFormat.EAN_13) ||
	  formats.contains(BarcodeFormat.EAN_8) ||
	  formats.contains(BarcodeFormat.CODABAR) ||
	  formats.contains(BarcodeFormat.CODE_39) ||
	  formats.contains(BarcodeFormat.CODE_93) ||
	  formats.contains(BarcodeFormat.CODE_128) ||
	  formats.contains(BarcodeFormat.ITF) ||
	  formats.contains(BarcodeFormat.RSS_14) ||
	  formats.contains(BarcodeFormat.RSS_EXPANDED);
  // Put 1D readers upfront in &quot;normal&quot; mode
  readers.add(new MultiFormatOneDReader(hints));
  if (formats.contains(BarcodeFormat.QR_CODE)) {
	readers.add(new QRCodeReader(mActivity));
  }
  if (formats.contains(BarcodeFormat.DATA_MATRIX)) {
	readers.add(new DataMatrixReader());
  }
  if (formats.contains(BarcodeFormat.AZTEC)) {
	readers.add(new AztecReader());
  }
  if (formats.contains(BarcodeFormat.PDF_417)) {
	 readers.add(new PDF417Reader());
  }
  if (formats.contains(BarcodeFormat.MAXICODE)) {
	 readers.add(new MaxiCodeReader());
  }
  // At end in &quot;try harder&quot; mode
  readers.add(new MultiFormatOneDReader(hints));

</code></pre>
<h3 id="解码调用接口的实现类">解码，调用接口的实现类</h3>
<pre><code>private Result decodeInternal(BinaryBitmap image) throws NotFoundException {
    if (readers != null) {
      for (Reader reader : readers) {
        try {
          return reader.decode(image, hints);
        } catch (ReaderException re) {
          // continue
        }
      }
    }
    throw NotFoundException.getNotFoundInstance();
  }
// QRCodeReader.java
	@Override
	  public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)
		  throws NotFoundException, ChecksumException, FormatException {
		DecoderResult decoderResult; //解析结果
		ResultPoint[] points; //解析的点
		if (hints != null &amp;&amp; hints.containsKey(DecodeHintType.PURE_BARCODE)) {
		  //二值化：image.getBlackMatrix()
		  BitMatrix bits = extractPureBits(image.getBlackMatrix());
		  decoderResult = decoder.decode(bits, hints);
		  points = NO_POINTS;
		} else {
		  //二值化：image.getBlackMatrix()
		  DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);
		  decoderResult = decoder.decode(detectorResult.getBits(), hints);
		  points = detectorResult.getPoints();
		}

		// If the code was mirrored: swap the bottom-left and the top-right points.
		if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
		  ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);
		}

		Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);
		List&lt;byte[]&gt; byteSegments = decoderResult.getByteSegments();
		if (byteSegments != null) {
		  result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);
		}
		String ecLevel = decoderResult.getECLevel();
		if (ecLevel != null) {
		  result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);
		}
		if (decoderResult.hasStructuredAppend()) {
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,
							 decoderResult.getStructuredAppendSequenceNumber());
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,
							 decoderResult.getStructuredAppendParity());
		}
		return result;
	  }


	/**
	   * &lt;p&gt;Detects a QR Code in an image.&lt;/p&gt;
	   *
	   * @param hints optional hints to detector
	   * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	   * @throws NotFoundException if QR Code cannot be found
	   * @throws FormatException if a QR Code cannot be decoded
	   */
	  public final DetectorResult detect(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException, FormatException {

		resultPointCallback = hints == null ? null :
			(ResultPointCallback) hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);

		FinderPatternFinder finder = new FinderPatternFinder(image, resultPointCallback);
		FinderPatternInfo info = finder.find(hints);

		return processFinderPatternInfo(info);
	  }

</code></pre>
<p>###定位特征点</p>
<pre><code>	final FinderPatternInfo find(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException {
		boolean tryHarder = hints != null &amp;&amp; hints.containsKey(DecodeHintType.TRY_HARDER);
		int maxI = image.getHeight();
		int maxJ = image.getWidth();
		int iSkip = (3 * maxI) / (4 * MAX_MODULES);
		if (iSkip &lt; MIN_SKIP || tryHarder) {
		  iSkip = MIN_SKIP;
		}

		boolean done = false;
		int[] stateCount = new int[5];
		for (int i = iSkip - 1; i &lt; maxI &amp;&amp; !done; i += iSkip) {
		  // Get a row of black/white values
		  clearCounts(stateCount);
		  int currentState = 0;
		  for (int j = 0; j &lt; maxJ; j++) {
			if (image.get(j, i)) {
			  // Black pixel
			  if ((currentState &amp; 1) == 1) { // Counting white pixels
				currentState++;
			  }
			  stateCount[currentState]++;
			} else { // White pixel
			  if ((currentState &amp; 1) == 0) { // Counting black pixels
				if (currentState == 4) { // A winner?
				  if (foundPatternCross(stateCount)) { // Yes
					boolean confirmed = handlePossibleCenter(stateCount, i, j);
					if (confirmed) {
					  iSkip = 2;
					  if (hasSkipped) {
						done = haveMultiplyConfirmedCenters();
					  } else {
						int rowSkip = findRowSkip();
						if (rowSkip &gt; stateCount[2]) {
						  i += rowSkip - stateCount[2] - iSkip;
						  j = maxJ - 1;
						}
					  }
					} else {
					  shiftCounts2(stateCount);
					  currentState = 3;
					  continue;
					}
					// Clear state to start looking again
					currentState = 0;
					clearCounts(stateCount);
				  } else { // No, shift counts back by two
					shiftCounts2(stateCount);
					currentState = 3;
				  }
				} else {
				  stateCount[++currentState]++;
				}
			  } else { // Counting white pixels
				stateCount[currentState]++;
			  }
			}
		  }
		  if (foundPatternCross(stateCount)) {
			boolean confirmed = handlePossibleCenter(stateCount, i, maxJ);
			if (confirmed) {
			  iSkip = stateCount[0];
			  if (hasSkipped) {
				// Found a third one
				done = haveMultiplyConfirmedCenters();
			  }
			}
		  }
		}
	//找到定位点
		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
	  }
</code></pre>
<p>###返回结果</p>
<pre><code>	protected final DetectorResult processFinderPatternInfo(FinderPatternInfo info)
		  throws NotFoundException, FormatException {

		FinderPattern topLeft = info.getTopLeft();
		FinderPattern topRight = info.getTopRight();
		FinderPattern bottomLeft = info.getBottomLeft();

		float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
		if (moduleSize &lt; 1.0f) {
		  throw NotFoundException.getNotFoundInstance();
		}
		int dimension = computeDimension(topLeft, topRight, bottomLeft, moduleSize);
		Version provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
		int modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;

		AlignmentPattern alignmentPattern = null;
		// Anything above version 1 has an alignment pattern
		if (provisionalVersion.getAlignmentPatternCenters().length &gt; 0) {

		  // Guess where a &quot;bottom right&quot; finder pattern would have been
		  float bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
		  float bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();

		  // Estimate that alignment pattern is closer by 3 modules
		  // from &quot;bottom right&quot; to known top left location
		  float correctionToTopLeft = 1.0f - 3.0f / modulesBetweenFPCenters;
		  int estAlignmentX = (int) (topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
		  int estAlignmentY = (int) (topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));

		  // Kind of arbitrary -- expand search radius before giving up
		  for (int i = 4; i &lt;= 16; i &lt;&lt;= 1) {
			try {
			  alignmentPattern = findAlignmentInRegion(moduleSize,
				  estAlignmentX,
				  estAlignmentY,
				  i);
			  break;
			} catch (NotFoundException re) {
			  // try next round
			}
		  }
		}

		PerspectiveTransform transform =
			createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);

		BitMatrix bits = sampleGrid(image, transform, dimension);

		ResultPoint[] points;
		if (alignmentPattern == null) {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight};
		} else {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight, alignmentPattern};
		}
		return new DetectorResult(bits, points);
	  }
</code></pre>
<p>##问题来了<br>
在阅读源码之后，我们发现这里面并没有解读放大相关的功能，这是为什么呢？<br>
是的，因为Zxing库本来就没有提供放大的功能，那么我们想实现放大功能应该怎么做？<br>
对，答案就是利用相机的放大功能setZoom来放大相机即可。<br>
那么，什么时机放大呢？</p>
<p>###相机放大功能和二维码建立关系<br>
为了解决这个放大时机的问题，我们再来回顾一下源码。<br>
有这样一段源码，它的作用是找到定位点：</p>
<pre><code>		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
</code></pre>
<p>那么，我们是不是利用这个定位点，就可以和相机扫描框的间距搞一些事情就可以了？<br>
事实上，网上也有很多例子是这么做的。<br>
行，既然已经有了，那我们直接拿来用就可以了吧？<br>
NONONO，事情并不是那么简单：<br>
<img src="https://i.loli.net/2019/06/17/5d0758dd0179c16484.png" alt="bucunzai.png"></p>
<p>##58APP二维码扫描的应用<br>
因为58APP，用的不是Java实现的。核心解码流程使用的是C++，通过JNI编译生成的so，然后再打入到58APP里的。<br>
兵来将挡水来土掩，行，既然java实现的思路已经有了，我们就用C++再写一遍怎么了，谁让咱也是科班出身。</p>
<p>###找到核心C++实现<br>
我们发现，是在这里执行的decode，然后也是调用了decodeWithState，然后将得到的结果返回给java。<br>
仔细跟进去，发现逻辑差不多，只不过一个是用java，一个是用C++。</p>
<pre><code>jbyte *yuvData = env-&gt;GetByteArrayElements(yuvData_, NULL);

    std::string codeResult = &quot;&quot;;
    try {
        ......
		省略部分代码
        // Perform the decoding.
        MultiFormatReader reader;
        reader.setHints(hints);
        Ref&lt;Result&gt; result(reader.decodeWithState(image));

        // Output the result.
        codeResult = result-&gt;getText()-&gt;getText();
        cout &lt;&lt; result-&gt;getText()-&gt;getText() &lt;&lt; endl;
    } catch (zxing::Exception&amp; e) {
        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;
    }

    env-&gt;ReleaseByteArrayElements(yuvData_, yuvData, 0);

    return env-&gt;NewStringUTF(codeResult.c_str());
</code></pre>
<p>###QRCodeReader.cpp核心实现</p>
<p>下面就是decode使用c++的核心实现，因为前面已经讲过了Java的实现，所以这里找到C++的代码也是非常容易的<br>
这里我们看到，有一句</p>
<pre><code>	Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
</code></pre>
<p>它的意思就是通过detect得到了detectorResult，然后通过下面的，</p>
<pre><code>	ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
</code></pre>
<p>得到了points，即定位点；<br>
一开始我想着把这个定位点独立出一个方法，然后再通过回调的形式传递给Java层，这样做的好处就是我们可以通过Java来实现放大功能。但是因为我们相机预览的速度是特别快的，所以这样做其实并不合适。于是，把相机的参数传递进去，然后在C++里面完成对于相机的放大。</p>
<pre><code>QRCodeReader::QRCodeReader() :decoder_() {
		}
		//TODO: see if any of the other files in the qrcode tree need tryHarder
		Ref&lt;Result&gt; QRCodeReader::decode(Ref&lt;BinaryBitmap&gt; image, DecodeHints hints) {
			Detector detector(image-&gt;getBlackMatrix());
			Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
			ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
			Ref&lt;DecoderResult&gt; decoderResult(decoder_.decode(detectorResult-&gt;getBits()));
			Ref&lt;Result&gt; result(
							   new Result(decoderResult-&gt;getText(), decoderResult-&gt;getRawBytes(), points, BarcodeFormat::QR_CODE));
			return result;
		}
</code></pre>
<p>###传递Java的Camera对象<br>
主要是在原来的基础上多传递了扫描框的位置和Camera这个对象：</p>
<pre><code>	xxx_QbarNative_decode(JNIEnv *env, jobject instance, jbyteArray bytes_, jint width,
										  jint height, jint cropLeft, jint cropRight, jint cropTop,
										  jint cropWidth, jint cropHeight, jboolean reverseHorizontal,
										  jobject camera, jobject parameters)
</code></pre>
<p>###放大代码使用C++实现<br>
最后，根据参数进行实现：简单的说就是判断二维码定位点的距离，然后用这个距离和相框之间的距离做个比对，小于一半，我们递增。</p>
<pre><code>	//执行检测逻辑，检测得到执行放大照相机逻辑，否则执行解析逻辑
	if(NULL != resultPoints &amp;&amp; !(resultPoints-&gt;empty())){
		//省去部分核心代码

		if(isZoomSupported){
		//这里做了简化，主要解决放大倍数过多，使得二维码突然不在扫描框里。
			if (len &lt;= frameWidth / 2){
				if(zoom &lt; maxZoom){
					zoom = zoom + 8;
				}else{
					zoom = maxZoom;
				}
				jmethodID setZoomMth = env-&gt;GetMethodID(parametersCls, &quot;setZoom&quot;, &quot;(I)V&quot;);
				env-&gt;CallVoidMethod(parameters, setZoomMth, zoom);

				jmethodID setParametersMth = env-&gt;GetMethodID(camearCls, &quot;setParameters&quot;, &quot;(Landroid/hardware/Camera$Parameters;)V&quot;);
				env-&gt;CallVoidMethod(camera, setParametersMth, parameters);

				env-&gt;ReleaseByteArrayElements(bytes_, yuvData, 0);
				string ss = strStream.str();
			}
		}
	}
</code></pre>
<p>###导出so，打入58APP<br>
最后，在demo中运行一下，看看效果。<br>
<img src="https://i.loli.net/2019/06/17/5d077e8e60ec060459.gif" alt="1557793019816360 (1).gif"></p>
<p>##心得<br>
其实最终解决这个问题不难，重点在于发现问题，解决问题的过程学到了什么。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手把手教你如何不刷机Hook代码]]></title>
        <id>https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma</id>
        <link href="https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma">
        </link>
        <updated>2019-11-22T00:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>##1. 背景</p>
<blockquote>
<p>前几个月，我们同TEG的同学一起排查一个问题：B端用户使用黑产提供的软件来Hook我们的API，达到在发送IM消息时发送自定义消息的目的，比如：在tips里面弹出，“淘宝客服，日结300，加V xxxxxxx”</p>
</blockquote>
<blockquote>
<p>带着一颗强烈的好奇心，我走进了Xposed的世界，发现原来Android的世界还可以如此精彩。</p>
</blockquote>
<p>##2. Xposed-从入门到放弃<br>
提起Xposed，可能很多人都听过它的名字，知道它是什么。</p>
<p>但是具体再深挖一下，它的原理是什么，可能大家就会回答的很模糊。</p>
<p>如果再深挖一下，const u2* insns是干什么用的？</p>
<p>如何再涉及到实践，如何Hook一个私有方法？</p>
<p>相信大家心里就会说：“这跟我有什么关系~~”</p>
<p>对的，一开始我也是这样的。但是一步步走下来，你会发现这个东西根本没那么难。那么，就跟我一起来学习下这块的相关知识吧。</p>
<p>###2.1 什么是Xpose？<br>
Xposed 框架是一款可以在不修改 APK 的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作，在这个框架下，我们可以加载很多插件 App ，这些插件 App 可以直接或间接劫持、篡改、伪造一些信息。</p>
<p>###2.2 它的原理是什么？</p>
<p>####2.2.1 Xposed资源<br>
·XposedBridge.jar：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。</p>
<p>·Xposed：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p>·XposedInstaller：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。</p>
<p>·XposedMods：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<p>####2.2.2 Zygote<br>
在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。</p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<p>####2.2.3 Hook<br>
在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
<p>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。在hookMethodNative的实现中，会调用XposedBridge中的handleHookedMethod这个方法来传递参数。handleHookedMethod这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是xposedCallHandler。而handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数，并调用他们的before, after函数。</p>
<p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：</p>
<p>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
<p>###2.3 为什么后来又放弃了？<br>
研究了一段时间之后，寻思就开始上手吧。<br>
####2.3.1 刷机成本<br>
Xposed是需要root手机的，于是就开始研究刷机，我手里有两个锤子手机，其中一个呢，已经被我彻底刷成了“锤子”，平时砸个核桃啥的用起来还算是顺手。另外一个，刷完之后，我手机里面的东西还都需要重新安装，有些APK是市场上已经找不到了。而且，我们目前使用的手机，主流的小米、OPPO、VIVI、华为，这些手机的刷机方式已经不再像原来那样简单，下载一个安装包，同时按住电源键+ Home + 音量“+”等一会那么简单了。而且刷完之后，不是NFC不好用，就是WIFI坏了。要是没有一款可要可不要的闲置手机，真的不建议刷。<br>
####2.3.2 脱壳也是一件麻烦事<br>
接下来再想，我们突破了种种困难，完成了刷机。但是当我们需要Hook方法的时候又会犯难，因为现在加壳的APK，反编译之后外面就一两个类，根本无从下手，还需要再研究脱壳。</p>
<p>渐渐地，我就发现原本我的目标：想看看如何模拟黑产去Hook一个API，但是这样的路让我越走越远。方向没错，但是不禁觉得这是在浪费时间。难道就真的没有办法了么？</p>
<p>接下来就来介绍一下，今天的猪脚，Virtual Xposed~~<br>
##3. Virutal Xposed<br>
对于我这样的“刚需”，它是一款神器。为什么，首先它不需要刷机，它的脱壳也是非常的简单。就这么简单的两点，完全解决了我的痛点。<br>
###3.1 它与Xposed从原理上的区别<br>
VirtualXposed 并未对系统底层进行任何修改，也没有利用什么神奇的漏洞。它的工作原理有点像那些双开软件。</p>
<p>VirtualXposed 是通过在你的手机里创建一个「虚拟环境」，然后在此虚拟环境中启用 Xposed。</p>
<p>###3.2 FDex2</p>
<p>###3.3 Demo<br>
##偷偷搞一波58试试</p>
<p>参考文章：<br>
http://yx.bsh.me/23278.html<br>
https://mp.weixin.qq.com/s/PG7ykzTWkw4tARjp0yKeAQ<br>
https://mp.weixin.qq.com/s/AlZMhMZ-SFOxRMtXfcev1g<br>
https://blog.csdn.net/ascii2/article/details/47974217<br>
https://blog.csdn.net/wxyyxc1992/article/details/17320911</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter接入第三方SDK]]></title>
        <id>https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk</id>
        <link href="https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk">
        </link>
        <updated>2019-11-22T00:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>#Flutter接入第三方SDK<br>
最近开始使用Flutter，发现我们可以写出原生的页面，使用Dart语言完成逻辑的编程。但是假如我们需要接入一个第三方SDK，这个时候应该怎么办呢？<br>
##接入第三方SDK-登录SDK<br>
登录SDK是58出的一款适用于全公司的一套登录体系。登录SDK是以一个AAR的形式提供的。该aar包含classes.jar、资源文件、assets文件、AndroidManifest.xml以及R.txt文件。</p>
<p>##Java的接入方式<br>
首先这是一个全新的挑战，接到手之后完全不知道该怎么弄。<br>
这里我们先回顾一下，在使用Java开发的时候，我们是如何引入AAR的：</p>
<blockquote>
<p>1.配置build.gradle文件，添加implementation 'xxx:xxxx:'</p>
<p>2.编译</p>
<p>3.调用</p>
</blockquote>
<p>##Flutter的接入方式<br>
那么Flutter的接入方式与Java的方式有什么不同呢？我们也试着按照上面的三种方式来做一次:</p>
<p>###配置AAR &amp; 编译<br>
这个配置AAR的方式有点诡异，需要在File -&gt; new -&gt; new Module -&gt; Import .AAR package，添加依赖之后，它会自动编译，然后你就会发现可以打开了。</p>
<p>然鹅，这种方式，是错误的。因为你把这个AAR引入到Flutter的工程里面，但是并没有引入到android的项目中来，因为我发现调用的时候依然调用不了。</p>
<p>另外，我发现在android目录下有一个MainActivity.java文件，大概率就是在这里添加跟Flutter页面的交互了。<br>
可是我发现这个类编辑之后没有任何代码提示，直觉告诉我这里缺一些东西，缺的是android的编译环境：</p>
<p>答案就是：双开</p>
<p>通过File -&gt; Open的形式，用android studio再打开一个目录引入android工程。</p>
<p>接下来的依赖关系也就变得顺其自然，双开固然麻烦，但是当你用flutter运行的那一刻，你就发现，一切都是值得的。</p>
<h3 id="模块设计">模块设计</h3>
<p>将登录SDK的模块引入，使得Flutter内部可以通过MethodChannel来调用Android的方法</p>
<p>登录SDK的特点：</p>
<p>1.无需实现UI界面；</p>
<p>2.需要设置页面监听；</p>
<p>3.接收回调之后可以及时展示到用户界面上</p>
<h3 id="登录sdk的引入">登录SDK的引入</h3>
<p>由于Flutter默认不支持<code>armeabi</code>的CPU架构，并且由于我们是并行开发，所以改动太多配置文件也会增加同学们的学习成本。所以，这里我们直接让登录SDK提供了支持了64位CPU架构测试AAR。<br>
同时，我们在android目录下修改了如下配置：</p>
<p>android目录下,修改了build.gradle文件：</p>
<pre><code>
buildscript {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
        mavenLocal()
        maven {
            url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
        }
        google()
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
    }
}

</code></pre>
<p>app目录下，修改了build.gradle添加了如下依赖<code>这些依赖都是必须的</code>：</p>
<pre><code>implementation 'com.wuba.wuxian.sdk:login:2.1.6.4.1-test'
    implementation 'com.wuba.wuxian.third:weichatsoter:1.3.10'
    implementation 'com.wuba.certify:deviceid:2.2.11'
    implementation 'com.wuba.xxzl:fastlogin:2.0.2.0'
    implementation 'io.reactivex:rxjava:1.3.8'
    implementation 'io.reactivex:rxandroid:1.2.1'
</code></pre>
<h3 id="flutter添加调用">Flutter添加调用</h3>
<p>在flutter的页面上，开发者可以随便使用UI元素，通过MethodChannel建立回调通道，在UI控件上设置点击事件调起登录并监听登录结果、<br>
通过platform.invokeMethod调起对应的登录方式、setState来设置结果、flutter监听变化后，会刷新并展示；</p>
<h4 id="flutter的调用">Flutter的调用</h4>
<p>主要是在<code>WubaLoginClientTestComponent</code>类里面；</p>
<pre><code>///定义一个MethodChannel
static const platform = const MethodChannel('com.wuba.flutter.flutter_hades/login');

///具体的调用方法
child: GestureDetector(
              child: new Row(
                children: &lt;Widget&gt;[
                  new Text(
                    '调起58登录: ' + _loginResult,
                    style: new TextStyle(
                        color: const Color(0xff353535), fontSize: 16.0),
                  ),
                ],
              ),
              onTap: _startWubaLogin,
            ),
            
///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

</code></pre>
<h4 id="接收回调刷新ui">接收回调刷新UI</h4>
<pre><code>///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

  String _loginResult = '';
  Future&lt;Null&gt; _startWubaLogin() async {
    String loginResult;
    try{
      loginResult = await platform.invokeMethod('wubaLogin');
    } on PlatformException catch (e){
      loginResult = &quot;error&quot;;
    }

    setState(() {
      _loginResult = loginResult;
    });
  }
</code></pre>
<h3 id="android接收调用">Android接收调用</h3>
<h4 id="初始化">初始化</h4>
<p>登录SDK的初始化可以按需要选取构建项，通过构建者模式来构建（由于第三方登录微信登录需要正式签名，所以引入目前也无法调用，所以暂时先不引入）：</p>
<pre><code>        LoginSdk.LoginConfig loginConfig = new LoginSdk.LoginConfig()
                //根据统一开关，上线后关闭log
                .setLogLevel(ILogger.STANDARD_LOG)
                //必选，设置product id, 由产品统一约定
                .setProductId(&quot;58app&quot;)
                .setLogoResId(R.drawable.wb_new_icon)
                //可选，如果集成三方登录，则设置相应的开放平台key
//                .setThirdLoginConfig(WubaSettingCommon.QQ_API_KEY, WubaSettingCommon.CONSUMER_KEY_WEIXIN, WubaSettingCommon.CONSUMER_KEY_SINA, WubaSettingCommon.REDIRECT_URL_SINA)
                .setNeedInitFaceVerify(true, &quot;Xenh6dVg&quot;)
                .setIsLoginRelyOnUserInfo(true)
                .setGatewayLoginAppId(&quot;ef2b526cdb4948b1bf7556f23d0a15da&quot;);
        //初始化
        LoginSdk.register(this, loginConfig);
</code></pre>
<h4 id="设置回调">设置回调</h4>
<p>设置通道：</p>
<pre><code>  private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
</code></pre>
<p>接收Flutter发送过来的调用，并调用登录SDK：</p>
<pre><code>LoginClient.register(mLoginCallback);
    new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
                if(call.method.equals(&quot;wubaLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaPhoneLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.PHONE_LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaRegister&quot;)){
                  LoginClient.launch(MainActivity.this, Request.REGISTER);
                  mResult = result;
                } else if(call.method.equals(&quot;getUserID&quot;)){
                  result.success(LoginClient.getUserID(MainActivity.this));
                } else if(call.method.equals(&quot;getUserPPU&quot;)){
                  result.success(LoginClient.getTicket(MainActivity.this, &quot;.58.com&quot;, &quot;PPU&quot;));
                } else if(call.method.equals(&quot;getUserName&quot;)){
                  result.success(LoginClient.getUserName(MainActivity.this));
                } else {
                  result.notImplemented();
                }
              }
            });
</code></pre>
<p>页面可以销毁后，给出去回调：</p>
<pre><code>LoginCallback mLoginCallback = new SimpleLoginCallback(){
    @Override
    public void onLogin58Finished(boolean isSuccess, String msg, LoginSDKBean loginSDKBean) {
      super.onLogin58Finished(isSuccess, msg, loginSDKBean);
        if(mResult != null){
          if(isSuccess){
            mResult.success(msg);
          }
        }
    }
  };
</code></pre>
<h2 id="细说methodchannel">细说MethodChannel</h2>
<h3 id="什么是methodchannel">什么是MethodChannel？</h3>
<p>《Flutter中文网》上面描述的标题是：插件开发：Android端API实现，也就是说，MethodChannel是Flutter实现与Android通过API交互的插件。通过上面的例子，我们也可以清楚的回顾它的一些特点，Flutter即时调用，Android得到反馈，Flutter进行UI展示，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="flutter_api.png" alt="flutter_api.png"></figure>
<h3 id="它的主要流程是什么">它的主要流程是什么？</h3>
<blockquote>
<p>1.在flutter端：设置一个MethodChannel：static const platform = const MethodChannel('samples.flutter.io/battery');</p>
<p>2.在flutter端：通过invoke方法调用：await platform.invokeMethod('getBatteryLevel');</p>
<p>3.在flutter端：写UI来接收回调<br>
children: [<br>
new RaisedButton(<br>
child: new Text('Get Battery Level'),<br>
onPressed: _getBatteryLevel,<br>
),<br>
new Text(_batteryLevel),<br>
],</p>
<p>4.在android端：调用setMethodCallHandler方法：</p>
<p>new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(<br>
new MethodCallHandler() {<br>
@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
// TODO<br>
}<br>
});</p>
<p>5.在android端：实现onMethodCall回调：</p>
<p>@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
if (call.method.equals(&quot;getBatteryLevel&quot;)) {<br>
int batteryLevel = getBatteryLevel();<br>
if (batteryLevel != -1) {<br>
result.success(batteryLevel);<br>
} else {<br>
result.error(&quot;UNAVAILABLE&quot;, &quot;Battery level not available.&quot;, null);<br>
}<br>
} else {<br>
result.notImplemented();<br>
}<br>
}</p>
</blockquote>
<h3 id="它的原理是什么">它的原理是什么？</h3>
<p>针对上面的流程我们有两个疑问：</p>
<ol>
<li>
<p>platform.invokeMethod怎么把对应的method调起来的？</p>
</li>
<li>
<p>result.success是如何回调到</p>
</li>
</ol>
<h3 id="源码阅读">源码阅读</h3>
<p>上源码之前，我们先来看个图：</p>
<p>官方说明：</p>
<blockquote>
<p>A named channel for communicating with platform plugins using asynchronous method calls.Method calls are encoded into binary before &gt;being sent, and binary results received are decoded into Dart values. The [MethodCodec] used must be compatible with the one used by the platform plugin. This can be achieved by creating a method channel counterpart of this channel on the platform side. The Dart type of arguments and results is <code>dynamic</code>, but only values supported by the specified [MethodCodec] can be used. The use of unsupported values should be considered programming errors, and will result in exceptions being thrown. The null value is supported for all codecs. The logical identity of the channel is given by its name. Identically named channels will interfere with each other's communication.</p>
</blockquote>
<blockquote>
<p>大概的意思：定义一个管道，利用异步方法跟平台插件进行交互。方法里面的参数必须是一个特定独一无二的，不能是特殊字符或者已经定义好的有含义的标识符。</p>
</blockquote>
<p>MethodChannel一共有三个参数，它们分别是：String name、StandardMethodCodec codec、binaryMessenger；</p>
<p>其中name是必选参数、后面两个是可选参数；</p>
<p>name:格式通常是：包名/方法名，例如：'com.wuba.flutter.flutter_hades/login'；</p>
<p>StandardMethodCodec codec：标准方法编码，有点类似于Java的序列化，里面有两个方法：ByteData encodeMessage(T message);和T decodeMessage(ByteData message);</p>
<p>BinaryMessenger ：这个类就是用来追踪管道的message的，分发并记录每一个注册了管道的handler并回调；</p>
<h4 id="platforminvokemethod">platform.invokeMethod</h4>
<p>MethodHandler提供了一个方法invokeMethod，这个方法就是调用的入口函数：</p>
<pre><code>@optionalTypeArgs
  Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [ dynamic arguments ]) async {
    assert(method != null);
    final ByteData result = await binaryMessenger.send(
      name,
      codec.encodeMethodCall(MethodCall(method, arguments)),
    );
    if (result == null) {
      throw MissingPluginException('No implementation found for method $method on channel $name');
    }
    final T typedResult = codec.decodeEnvelope(result);
    return typedResult;
  }
</code></pre>
<p>我们主要是看这个binaryMessenger.send的方法：</p>
<pre><code>@override
  Future&lt;ByteData&gt; send(String channel, ByteData message) {
    final MessageHandler handler = _mockHandlers[channel];
    if (handler != null)
      return handler(message);
    return _sendPlatformMessage(channel, message);
  }
</code></pre>
<p>通过Map存储到key-value，key代表的是channel，就是我们刚才设置的MethodChannel中的name，value是handler，这个就相当于track。</p>
<p>接下来调用Flutter的UI顶层的实现方式：</p>
<pre><code>ui.window.sendPlatformMessage(channel, message, (ByteData reply) {
      try {
        completer.complete(reply);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: ErrorDescription('during a platform message response callback'),
        ));
      }
    });
</code></pre>
<p>ui.window类似于android里面的window？</p>
<pre><code>void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) {
    final String error =
        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);
    if (error != null)
      throw Exception(error);
  }
</code></pre>
<p>跟到这里，我们发现调用的Native的方法：</p>
<pre><code>String _sendPlatformMessage(String name,
                              PlatformMessageResponseCallback callback,
                              ByteData data) native 'Window_sendPlatformMessage';
</code></pre>
<p>接下来，我们看c++是怎么写的：</p>
<pre><code>Dart_Handle SendPlatformMessage(Dart_Handle window,
                                const std::string&amp; name,
                                Dart_Handle callback,
                                const tonic::DartByteData&amp; data) {
  UIDartState* dart_state = UIDartState::Current();

  ...

  fml::RefPtr&lt;PlatformMessageResponse&gt; response;
  if (!Dart_IsNull(callback)) {
    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(
        tonic::DartPersistentValue(dart_state, callback),
        dart_state-&gt;GetTaskRunners().GetUITaskRunner());
  }
  if (Dart_IsNull(data.dart_handle())) {
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));
  } else {
    const uint8_t* buffer = static_cast&lt;const uint8_t*&gt;(data.data());

    // data数据部位null，会走下面这块代码
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(
            name, std::vector&lt;uint8_t&gt;(buffer, buffer + data.length_in_bytes()),
            response));
  }

  return Dart_Null();
}
</code></pre>
<p>我们看这里有一段代码，叫做HandlePlatformMessage，这段代码在<code>../engine/shell/common/engine.cc</code></p>
<pre><code>void Engine::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  if (message-&gt;channel() == kAssetChannel) {
    HandleAssetPlatformMessage(std::move(message));
  } else {
    delegate_.OnEngineHandlePlatformMessage(std::move(message));
  }
}

void Shell::OnEngineHandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
    
  ...
  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(
      [view = platform_view_-&gt;GetWeakPtr(), message = std::move(message)]() {
        if (view) {
          view-&gt;HandlePlatformMessage(std::move(message));
        }
      });
}
</code></pre>
<p>platform_view_是一个继承了PlatformView类的PlatformViewAndroid对象，该对象在创建AndroidShellHolder对象时被创建。view-&gt;HandlePlatformMessage执行以下方法，<code>../engine/shell/platform/android/platform_view_android.cc</code></p>
<pre><code>void PlatformViewAndroid::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  JNIEnv* env = fml::jni::AttachCurrentThread();
  fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.get(env);
  if (view.is_null())
    return;

  int response_id = 0;
  if (auto response = message-&gt;response()) {
    response_id = next_response_id_++;
    pending_responses_[response_id] = response;
  }
  auto java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());
  if (message-&gt;hasData()) {
    fml::jni::ScopedJavaLocalRef&lt;jbyteArray&gt; message_array(
        env, env-&gt;NewByteArray(message-&gt;data().size()));
    env-&gt;SetByteArrayRegion(
        message_array.obj(), 0, message-&gt;data().size(),
        reinterpret_cast&lt;const jbyte*&gt;(message-&gt;data().data()));
    message = nullptr;

    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.
    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),
                                     message_array.obj(), response_id);
  } else {
    ...
  }
}
</code></pre>
<p>于是，我们最终跟到了JNI的最终方法，它调用的是<code>FlutterJNI.java</code>中的handlePlatformMessage：</p>
<pre><code>static jmethodID g_handle_platform_message_method = nullptr;
void FlutterViewHandlePlatformMessage(JNIEnv* env,
                                      jobject obj,
                                      jstring channel,
                                      jobject message,
                                      jint responseId) {
  env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,
                      responseId);
  FML_CHECK(CheckException(env));
}

private void handlePlatformMessage(String channel, byte[] message, int replyId) {
    if (this.platformMessageHandler != null) {
        this.platformMessageHandler.handleMessageFromDart(channel, message, replyId);
    }
}

public void handleMessageFromDart(final String channel, byte[] message, final int replyId) {
    FlutterNativeView.this.assertAttached();
    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);
    if (handler != null) {
        try {
            ByteBuffer buffer = message == null ? null : ByteBuffer.wrap(message);
            handler.onMessage(buffer, new BinaryReply() {
                private final AtomicBoolean done = new AtomicBoolean(false);

                public void reply(ByteBuffer reply) {
                    if (!FlutterNativeView.this.isAttached()) {
                        Log.d(&quot;FlutterNativeView&quot;, &quot;handleMessageFromDart replying ot a detached view, channel=&quot; + channel);
                    } else if (this.done.getAndSet(true)) {
                        throw new IllegalStateException(&quot;Reply already submitted&quot;);
                    } else {
                        if (reply == null) {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
                        } else {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());
                        }

                    }
                }
            });
        } catch (Exception var6) {
            Log.e(&quot;FlutterNativeView&quot;, &quot;Uncaught exception in binary message listener&quot;, var6);
            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
        }

    } else {
        FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
    }
}
</code></pre>
<p>这里面我们看到这样一段代码，    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);<br>
那这个handler是如何根据channel跟踪到的呢？我们已经到Java方法了啊可。</p>
<p>所以，我们试着回想一下，当时是不是在MainActivity里面也设置了个同名的String， 这个字符串有点似曾相识呢。由此猜想，这个handler可能是当时我们自己设进去的，我们来看看如下代码<code>setMethodCallHandler</code>：</p>
<pre><code>private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
              }
            });
            
            public void setMethodCallHandler(@Nullable MethodChannel.MethodCallHandler handler) {
    this.messenger.setMessageHandler(this.name, handler == null ? null : new MethodChannel.IncomingMethodCallHandler(handler));
}

public void setMessageHandler(String channel, BinaryMessageHandler handler) {
    this.mNativeView.setMessageHandler(channel, handler);
}
</code></pre>
<p>接下来我们继续看这个<code>handler.onMessage()</code>方法：</p>
<pre><code>public void onMessage(ByteBuffer message, final BinaryReply reply) {
    MethodCall call = MethodChannel.this.codec.decodeMethodCall(message);

    try {
        this.handler.onMethodCall(call, new MethodChannel.Result() {
            public void success(Object result) {
                reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));
            }

            public void error(String errorCode, String errorMessage, Object errorDetails) {
                reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));
            }

            public void notImplemented() {
                reply.reply((ByteBuffer)null);
            }
        });
    } catch (RuntimeException var5) {
        Log.e(&quot;MethodChannel#&quot; + MethodChannel.this.name, &quot;Failed to handle method call&quot;, var5);
        reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(&quot;error&quot;, var5.getMessage(), (Object)null));
    }

}
</code></pre>
<p>方法中首先将从c++层传递过来的消息通过codec解码为MethodCall对象，然后调用MainActivity中实现的MethodHandler的onMethodCall方法，改方法实现中会执行android的API调用，然后调用result.success()方法，通过reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));将结果数据编码后进行返回。reply方法中会调用FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());方法将响应结果返回。</p>
<p>然后回调给C++层。</p>
<p>最终回调给UI层，调用setState完成整个更新。</p>
<h3 id="总结">总结</h3>
<p>1.Flutter调用invokeMethod方法，将code转码和并建立跟踪对应的Messagehandle；</p>
<p>2.在c++层对其进行封装，通过sendPlatformMessage调用JNI方法；</p>
<p>3.根据调用方法找到最终调用已经注册好的Java对象的对应方法；</p>
<p>4.获取回调结果并将结果返回给C++层；</p>
<p>5.C++层获取结果后最终返回给Flutter的setState方法，刷新UI；</p>
<h3 id="预览效果图">预览效果图</h3>
<figure data-type="image" tabindex="2"><img src="flutter_loginsdk.png" alt="flutter_loginsdk.png"></figure>
<h3 id="接入报错">接入报错</h3>
<p>1.A problem occurred configuring project ':sqflite'.</p>
<p>Could not download groovy-all.jar</p>
<p>如果出现资源找不到，一般都是gradle的配置文件出现了问题，我们可以通过引入配置来解决：在工程-&gt;android-&gt;build.gradle下，对于buildscript和allprojects中的repositories进行修改，添加如下代码：</p>
<pre><code>maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
</code></pre>
<p>2.注册跳转页面需要添加路由</p>
<p>注册一个页面，虽然不需要像android原生一样在androidmanifest.xml文件中注册activity，但是在flutter里面，需要注册路由。路由分为静态路由和动态路由，只有注册后，才能完成跳转；</p>
<p>3.This Overlay widget cannot be marked as needing to build because the framework is already in the<br>
process of building widgets</p>
<p>我通过A页面添加了一个GestureDetector的onTap事件跳转进入B页面，但是当我用同样的方法在B页面再添加GestureDetector的时候，在onTap里面添加之后就会报错；</p>
<pre><code>onTap: _onWubaLoginClick(), 
看见没，上面代码，原来是多加了一个()，Java里调用方法就是有括号的啊，再说你这个报错可真的是让我好找啊~
</code></pre>
<p>4.flutter工程下，无法编译android下的MainActivity.java</p>
<p>新开一个工程，开发flutter的android工程即可</p>
<p>5.善于利用工具</p>
<p>在进行flutter开发的时候，我们难免会遇到各种各样的问题，其实大部分我们都可以在官方文档里面得到解决。</p>
<p>所以有事没事，看看官网：<br>
https://flutterchina.club/platform-channels/</p>
<p>6.引入58的第三方找不到库</p>
<p>其实是没有配置maven仓库，需要</p>
<pre><code>mavenLocal()
maven {
   url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
}
</code></pre>
<p>7.java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; is 32-bit instead of 64-bit</p>
<p>58APP接入的是32位的，那么为啥在这个flutter的工程里面，它需要引入的是64位的呢？</p>
<p>8.libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0</p>
<pre><code>java.lang.UnsatisfiedLinkError: dlopen failed: file offset for the library &quot;/data/user/0/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0
        at java.lang.Runtime.load0(Runtime.java:928)
        at java.lang.System.load(System.java:1621)
        at com.wuba.uc.RsaCryptService.b(RsaCryptService.java:43)
        at com.wuba.uc.RsaCryptService.a(RsaCryptService.java:24)
        at com.wuba.loginsdk.internal.b.process(InitCommon.java:24)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:144)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:60)
        at com.wuba.flutter.flutter_hades.WubaApplication.registeWubaLogin(WubaApplication.java:31)
        at com.wuba.flutter.flutter_hades.WubaApplication.onCreate(WubaApplication.java:15)
        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1119)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5881)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
</code></pre>
<p>9.support-v4</p>
<pre><code>java.lang.RuntimeException: Unable to get provider com.wuba.loginsdk.provider.PassportFileProvider: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at android.app.ActivityThread.installProvider(ActivityThread.java:6447)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        at android.app.ActivityThread.installProvider(ActivityThread.java:6423)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950) 
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862) 
        at android.app.ActivityThread.-wrap1(Unknown Source:0) 
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690) 
        at android.os.Handler.dispatchMessage(Handler.java:105) 
        at android.os.Looper.loop(Looper.java:176) 
        at android.app.ActivityThread.main(ActivityThread.java:6701) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783) 
    	Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Landroid/support/v4/content/FileProvider;
        at java.lang.VMClassLoader.findLoadedClass(Native Method)
        at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:363)
        		... 12 more
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;android.support.v4.content.FileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        		... 15 more
</code></pre>
<p>10.wlog&amp;soter&amp;两个图片资源找不到</p>
<h3 id="参考文章">参考文章</h3>
<p>https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html<br>
https://www.jianshu.com/p/185c42fe002b</p>
]]></content>
    </entry>
</feed>