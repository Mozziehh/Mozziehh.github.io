<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Mozziehh.github.io</id>
    <title>差不多胡先生</title>
    <updated>2019-11-22T00:46:52.818Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Mozziehh.github.io"/>
    <link rel="self" href="https://Mozziehh.github.io/atom.xml"/>
    <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
    <logo>https://Mozziehh.github.io/images/avatar.png</logo>
    <icon>https://Mozziehh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 差不多胡先生</rights>
    <entry>
        <title type="html"><![CDATA[通过NDK实现Zxing二维码扫描放大功能]]></title>
        <id>https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng</id>
        <link href="https://Mozziehh.github.io/post/tong-guo-ndk-shi-xian-zxing-er-wei-ma-sao-miao-fang-da-gong-neng">
        </link>
        <updated>2019-11-22T00:43:25.000Z</updated>
        <content type="html"><![CDATA[<p> 在各个APP中几乎都能看见它的身影。二维码扫描虽然是一个普通的功能，但是在APP中占依然都放在很抢眼的位置。比如像淘宝、58这类APP主要解决PC端扫码登录，微信、支付宝这类主要使用支付，摩拜小蓝这类APP主要是用于扫码骑车。所以，能更快捷更方便的使用二维码，可以极大的提升用户体验。</p>
<p>##快捷与方便<br>
 曾经或许会有那么一个寒冷的夜晚，你骑着刚共享单车飞驰在回家的路上，突然，街边飘来哈尔滨烤冷面的香气让你不知不觉的来到那个小摊面前，迟疑了很久，你说了一句：“老板，来一份。。。再。。。加个肠。”昏暗的灯光下、其他的食客中，老板熟练的抄起手中的家伙，你熟练掏出手机，打开扫一扫，老板的二维码在你的手里一次次对焦、一次次放大，“滴”的一声，付钱，取餐，嗝~。<br>
 你有没有想过，为什么在扫描的过程中，被扫描的二维码会在扫描框里从模糊到清晰，然后再从清晰到模糊，周而复始？<br>
 你有没有想过，为什么在稍远的距离，二维码扫描就会慢慢放大？<br>
 是的，在这个寒冷的夜，为了能让你的手机更快速的识别出对方的二维码，我们做了很多。</p>
<p>##二维码解读</p>
<p>我们来看一下二维码扫描主要展示信息，主要分为功能图形和编码区格式。其中功能图形的位置探测图形、定位图形、矫正图形在定位的过程中起着举足轻重的地位。</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/Mozziehh/mypapers/blob/master/images/qrcode_structure.png?raw=true" alt=""></figure>
<p>##二维码扫描的源码解读<br>
 从你拿出手机对准二维码直到扫描结束，整个过程都发生了什么？为了能让你生动的了解整个过程，我打算用下面的方式讲：<br>
打开相机执行扫描-&gt;获取Byte流-&gt;灰度-&gt;二值化-&gt;霍夫变换-&gt;找到二维码定位点-&gt;识别-&gt;返回结果。</p>
<p>###打开相机执行扫描</p>
<pre><code>private void initCamera(SurfaceHolder surfaceHolder) {
        if (surfaceHolder == null) {
            throw new IllegalStateException(&quot;No SurfaceHolder provided&quot;);
        }
        if (cameraManager.isOpen()) {
            Log.w(TAG, &quot;initCamera() while already open -- late SurfaceView callback?&quot;);
            return;
        }
        try {
            cameraManager.openDriver(surfaceHolder);
            // Creating the handler starts the preview, which can also throw a
            // RuntimeException.
            if (handler == null) {
                handler = new CaptureActivityHandler(this, cameraManager, DecodeThread.ALL_MODE);
            }

            initCrop();
        } catch (IOException ioe) {
            Log.w(TAG, ioe);
            displayFrameworkBugMessageAndExit();
        } catch (RuntimeException e) {
            // Barcode Scanner has seen crashes in the wild of this variety:
            // java.?lang.?RuntimeException: Fail to connect to camera service
            Log.w(TAG, &quot;Unexpected error initializing camera&quot;, e);
            displayFrameworkBugMessageAndExit();
        }
    }
</code></pre>
<p>###设置支持的二维码类型</p>
<p>目前二维码支持如下类型：<br>
<img src="https://i.loli.net/2019/06/17/5d0734bfd44a794589.png" alt="support-zxing-pic.png"><br>
代码在这里配置：</p>
<pre><code>// The prefs can't change while the thread is running, so pick them up once here.
    if (decodeFormats == null || decodeFormats.isEmpty()) {
      SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
      decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) {
        decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) {
        decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) {
        decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) {
        decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) {
        decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
      }
      if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) {
        decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
      }
    }
    hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
</code></pre>
<p>###获取相机预览的Byte流</p>
<pre><code>public class PreviewCallback implements Camera.PreviewCallback {

	private static final String TAG = PreviewCallback.class.getSimpleName();

	private final CameraConfigurationManager configManager;
	private Handler previewHandler;
	private int previewMessage;

	public PreviewCallback(CameraConfigurationManager configManager) {
		this.configManager = configManager;
	}

	public void setHandler(Handler previewHandler, int previewMessage) {
		this.previewHandler = previewHandler;
		this.previewMessage = previewMessage;
	}

	@Override
	public void onPreviewFrame(byte[] data, Camera camera) {
		Point cameraResolution = configManager.getCameraResolution();
		Handler thePreviewHandler = previewHandler;
		if (cameraResolution != null &amp;&amp; thePreviewHandler != null) {
			Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x, cameraResolution.y, data);
			message.sendToTarget();
			previewHandler = null;
		} else {
			Log.d(TAG, &quot;Got preview callback, but no handler or resolution available&quot;);
		}
	}

}

//在这里通过相机框获取bitmap的byte流
PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);

BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

</code></pre>
<p>###对bitmap的byte流解码</p>
<pre><code>if (formats != null) {
  boolean addOneDReader =
	  formats.contains(BarcodeFormat.UPC_A) ||
	  formats.contains(BarcodeFormat.UPC_E) ||
	  formats.contains(BarcodeFormat.EAN_13) ||
	  formats.contains(BarcodeFormat.EAN_8) ||
	  formats.contains(BarcodeFormat.CODABAR) ||
	  formats.contains(BarcodeFormat.CODE_39) ||
	  formats.contains(BarcodeFormat.CODE_93) ||
	  formats.contains(BarcodeFormat.CODE_128) ||
	  formats.contains(BarcodeFormat.ITF) ||
	  formats.contains(BarcodeFormat.RSS_14) ||
	  formats.contains(BarcodeFormat.RSS_EXPANDED);
  // Put 1D readers upfront in &quot;normal&quot; mode
  readers.add(new MultiFormatOneDReader(hints));
  if (formats.contains(BarcodeFormat.QR_CODE)) {
	readers.add(new QRCodeReader(mActivity));
  }
  if (formats.contains(BarcodeFormat.DATA_MATRIX)) {
	readers.add(new DataMatrixReader());
  }
  if (formats.contains(BarcodeFormat.AZTEC)) {
	readers.add(new AztecReader());
  }
  if (formats.contains(BarcodeFormat.PDF_417)) {
	 readers.add(new PDF417Reader());
  }
  if (formats.contains(BarcodeFormat.MAXICODE)) {
	 readers.add(new MaxiCodeReader());
  }
  // At end in &quot;try harder&quot; mode
  readers.add(new MultiFormatOneDReader(hints));

</code></pre>
<h3 id="解码调用接口的实现类">解码，调用接口的实现类</h3>
<pre><code>private Result decodeInternal(BinaryBitmap image) throws NotFoundException {
    if (readers != null) {
      for (Reader reader : readers) {
        try {
          return reader.decode(image, hints);
        } catch (ReaderException re) {
          // continue
        }
      }
    }
    throw NotFoundException.getNotFoundInstance();
  }
// QRCodeReader.java
	@Override
	  public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)
		  throws NotFoundException, ChecksumException, FormatException {
		DecoderResult decoderResult; //解析结果
		ResultPoint[] points; //解析的点
		if (hints != null &amp;&amp; hints.containsKey(DecodeHintType.PURE_BARCODE)) {
		  //二值化：image.getBlackMatrix()
		  BitMatrix bits = extractPureBits(image.getBlackMatrix());
		  decoderResult = decoder.decode(bits, hints);
		  points = NO_POINTS;
		} else {
		  //二值化：image.getBlackMatrix()
		  DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);
		  decoderResult = decoder.decode(detectorResult.getBits(), hints);
		  points = detectorResult.getPoints();
		}

		// If the code was mirrored: swap the bottom-left and the top-right points.
		if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
		  ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);
		}

		Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);
		List&lt;byte[]&gt; byteSegments = decoderResult.getByteSegments();
		if (byteSegments != null) {
		  result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);
		}
		String ecLevel = decoderResult.getECLevel();
		if (ecLevel != null) {
		  result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);
		}
		if (decoderResult.hasStructuredAppend()) {
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,
							 decoderResult.getStructuredAppendSequenceNumber());
		  result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,
							 decoderResult.getStructuredAppendParity());
		}
		return result;
	  }


	/**
	   * &lt;p&gt;Detects a QR Code in an image.&lt;/p&gt;
	   *
	   * @param hints optional hints to detector
	   * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	   * @throws NotFoundException if QR Code cannot be found
	   * @throws FormatException if a QR Code cannot be decoded
	   */
	  public final DetectorResult detect(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException, FormatException {

		resultPointCallback = hints == null ? null :
			(ResultPointCallback) hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);

		FinderPatternFinder finder = new FinderPatternFinder(image, resultPointCallback);
		FinderPatternInfo info = finder.find(hints);

		return processFinderPatternInfo(info);
	  }

</code></pre>
<p>###定位特征点</p>
<pre><code>	final FinderPatternInfo find(Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException {
		boolean tryHarder = hints != null &amp;&amp; hints.containsKey(DecodeHintType.TRY_HARDER);
		int maxI = image.getHeight();
		int maxJ = image.getWidth();
		int iSkip = (3 * maxI) / (4 * MAX_MODULES);
		if (iSkip &lt; MIN_SKIP || tryHarder) {
		  iSkip = MIN_SKIP;
		}

		boolean done = false;
		int[] stateCount = new int[5];
		for (int i = iSkip - 1; i &lt; maxI &amp;&amp; !done; i += iSkip) {
		  // Get a row of black/white values
		  clearCounts(stateCount);
		  int currentState = 0;
		  for (int j = 0; j &lt; maxJ; j++) {
			if (image.get(j, i)) {
			  // Black pixel
			  if ((currentState &amp; 1) == 1) { // Counting white pixels
				currentState++;
			  }
			  stateCount[currentState]++;
			} else { // White pixel
			  if ((currentState &amp; 1) == 0) { // Counting black pixels
				if (currentState == 4) { // A winner?
				  if (foundPatternCross(stateCount)) { // Yes
					boolean confirmed = handlePossibleCenter(stateCount, i, j);
					if (confirmed) {
					  iSkip = 2;
					  if (hasSkipped) {
						done = haveMultiplyConfirmedCenters();
					  } else {
						int rowSkip = findRowSkip();
						if (rowSkip &gt; stateCount[2]) {
						  i += rowSkip - stateCount[2] - iSkip;
						  j = maxJ - 1;
						}
					  }
					} else {
					  shiftCounts2(stateCount);
					  currentState = 3;
					  continue;
					}
					// Clear state to start looking again
					currentState = 0;
					clearCounts(stateCount);
				  } else { // No, shift counts back by two
					shiftCounts2(stateCount);
					currentState = 3;
				  }
				} else {
				  stateCount[++currentState]++;
				}
			  } else { // Counting white pixels
				stateCount[currentState]++;
			  }
			}
		  }
		  if (foundPatternCross(stateCount)) {
			boolean confirmed = handlePossibleCenter(stateCount, i, maxJ);
			if (confirmed) {
			  iSkip = stateCount[0];
			  if (hasSkipped) {
				// Found a third one
				done = haveMultiplyConfirmedCenters();
			  }
			}
		  }
		}
	//找到定位点
		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
	  }
</code></pre>
<p>###返回结果</p>
<pre><code>	protected final DetectorResult processFinderPatternInfo(FinderPatternInfo info)
		  throws NotFoundException, FormatException {

		FinderPattern topLeft = info.getTopLeft();
		FinderPattern topRight = info.getTopRight();
		FinderPattern bottomLeft = info.getBottomLeft();

		float moduleSize = calculateModuleSize(topLeft, topRight, bottomLeft);
		if (moduleSize &lt; 1.0f) {
		  throw NotFoundException.getNotFoundInstance();
		}
		int dimension = computeDimension(topLeft, topRight, bottomLeft, moduleSize);
		Version provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
		int modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;

		AlignmentPattern alignmentPattern = null;
		// Anything above version 1 has an alignment pattern
		if (provisionalVersion.getAlignmentPatternCenters().length &gt; 0) {

		  // Guess where a &quot;bottom right&quot; finder pattern would have been
		  float bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
		  float bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();

		  // Estimate that alignment pattern is closer by 3 modules
		  // from &quot;bottom right&quot; to known top left location
		  float correctionToTopLeft = 1.0f - 3.0f / modulesBetweenFPCenters;
		  int estAlignmentX = (int) (topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
		  int estAlignmentY = (int) (topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));

		  // Kind of arbitrary -- expand search radius before giving up
		  for (int i = 4; i &lt;= 16; i &lt;&lt;= 1) {
			try {
			  alignmentPattern = findAlignmentInRegion(moduleSize,
				  estAlignmentX,
				  estAlignmentY,
				  i);
			  break;
			} catch (NotFoundException re) {
			  // try next round
			}
		  }
		}

		PerspectiveTransform transform =
			createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);

		BitMatrix bits = sampleGrid(image, transform, dimension);

		ResultPoint[] points;
		if (alignmentPattern == null) {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight};
		} else {
		  points = new ResultPoint[]{bottomLeft, topLeft, topRight, alignmentPattern};
		}
		return new DetectorResult(bits, points);
	  }
</code></pre>
<p>##问题来了<br>
在阅读源码之后，我们发现这里面并没有解读放大相关的功能，这是为什么呢？<br>
是的，因为Zxing库本来就没有提供放大的功能，那么我们想实现放大功能应该怎么做？<br>
对，答案就是利用相机的放大功能setZoom来放大相机即可。<br>
那么，什么时机放大呢？</p>
<p>###相机放大功能和二维码建立关系<br>
为了解决这个放大时机的问题，我们再来回顾一下源码。<br>
有这样一段源码，它的作用是找到定位点：</p>
<pre><code>		FinderPattern[] patternInfo = selectBestPatterns();
		ResultPoint.orderBestPatterns(patternInfo);

		return new FinderPatternInfo(patternInfo);
	  }

	private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide) {
		float ratio = newSide / (2 * oldSide);
		float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
		float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
		float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
		float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;

		ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		dx = cornerPoints[1].getX() - cornerPoints[3].getX();
		dy = cornerPoints[1].getY() - cornerPoints[3].getY();
		centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
		centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
		ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
		ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);

		return new ResultPoint[]{result0, result1, result2, result3};
</code></pre>
<p>那么，我们是不是利用这个定位点，就可以和相机扫描框的间距搞一些事情就可以了？<br>
事实上，网上也有很多例子是这么做的。<br>
行，既然已经有了，那我们直接拿来用就可以了吧？<br>
NONONO，事情并不是那么简单：<br>
<img src="https://i.loli.net/2019/06/17/5d0758dd0179c16484.png" alt="bucunzai.png"></p>
<p>##58APP二维码扫描的应用<br>
因为58APP，用的不是Java实现的。核心解码流程使用的是C++，通过JNI编译生成的so，然后再打入到58APP里的。<br>
兵来将挡水来土掩，行，既然java实现的思路已经有了，我们就用C++再写一遍怎么了，谁让咱也是科班出身。</p>
<p>###找到核心C++实现<br>
我们发现，是在这里执行的decode，然后也是调用了decodeWithState，然后将得到的结果返回给java。<br>
仔细跟进去，发现逻辑差不多，只不过一个是用java，一个是用C++。</p>
<pre><code>jbyte *yuvData = env-&gt;GetByteArrayElements(yuvData_, NULL);

    std::string codeResult = &quot;&quot;;
    try {
        ......
		省略部分代码
        // Perform the decoding.
        MultiFormatReader reader;
        reader.setHints(hints);
        Ref&lt;Result&gt; result(reader.decodeWithState(image));

        // Output the result.
        codeResult = result-&gt;getText()-&gt;getText();
        cout &lt;&lt; result-&gt;getText()-&gt;getText() &lt;&lt; endl;
    } catch (zxing::Exception&amp; e) {
        cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; endl;
    }

    env-&gt;ReleaseByteArrayElements(yuvData_, yuvData, 0);

    return env-&gt;NewStringUTF(codeResult.c_str());
</code></pre>
<p>###QRCodeReader.cpp核心实现</p>
<p>下面就是decode使用c++的核心实现，因为前面已经讲过了Java的实现，所以这里找到C++的代码也是非常容易的<br>
这里我们看到，有一句</p>
<pre><code>	Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
</code></pre>
<p>它的意思就是通过detect得到了detectorResult，然后通过下面的，</p>
<pre><code>	ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
</code></pre>
<p>得到了points，即定位点；<br>
一开始我想着把这个定位点独立出一个方法，然后再通过回调的形式传递给Java层，这样做的好处就是我们可以通过Java来实现放大功能。但是因为我们相机预览的速度是特别快的，所以这样做其实并不合适。于是，把相机的参数传递进去，然后在C++里面完成对于相机的放大。</p>
<pre><code>QRCodeReader::QRCodeReader() :decoder_() {
		}
		//TODO: see if any of the other files in the qrcode tree need tryHarder
		Ref&lt;Result&gt; QRCodeReader::decode(Ref&lt;BinaryBitmap&gt; image, DecodeHints hints) {
			Detector detector(image-&gt;getBlackMatrix());
			Ref&lt;DetectorResult&gt; detectorResult(detector.detect(hints));
			ArrayRef&lt; Ref&lt;ResultPoint&gt; &gt; points (detectorResult-&gt;getPoints());
			Ref&lt;DecoderResult&gt; decoderResult(decoder_.decode(detectorResult-&gt;getBits()));
			Ref&lt;Result&gt; result(
							   new Result(decoderResult-&gt;getText(), decoderResult-&gt;getRawBytes(), points, BarcodeFormat::QR_CODE));
			return result;
		}
</code></pre>
<p>###传递Java的Camera对象<br>
主要是在原来的基础上多传递了扫描框的位置和Camera这个对象：</p>
<pre><code>	xxx_QbarNative_decode(JNIEnv *env, jobject instance, jbyteArray bytes_, jint width,
										  jint height, jint cropLeft, jint cropRight, jint cropTop,
										  jint cropWidth, jint cropHeight, jboolean reverseHorizontal,
										  jobject camera, jobject parameters)
</code></pre>
<p>###放大代码使用C++实现<br>
最后，根据参数进行实现：简单的说就是判断二维码定位点的距离，然后用这个距离和相框之间的距离做个比对，小于一半，我们递增。</p>
<pre><code>	//执行检测逻辑，检测得到执行放大照相机逻辑，否则执行解析逻辑
	if(NULL != resultPoints &amp;&amp; !(resultPoints-&gt;empty())){
		//省去部分核心代码

		if(isZoomSupported){
		//这里做了简化，主要解决放大倍数过多，使得二维码突然不在扫描框里。
			if (len &lt;= frameWidth / 2){
				if(zoom &lt; maxZoom){
					zoom = zoom + 8;
				}else{
					zoom = maxZoom;
				}
				jmethodID setZoomMth = env-&gt;GetMethodID(parametersCls, &quot;setZoom&quot;, &quot;(I)V&quot;);
				env-&gt;CallVoidMethod(parameters, setZoomMth, zoom);

				jmethodID setParametersMth = env-&gt;GetMethodID(camearCls, &quot;setParameters&quot;, &quot;(Landroid/hardware/Camera$Parameters;)V&quot;);
				env-&gt;CallVoidMethod(camera, setParametersMth, parameters);

				env-&gt;ReleaseByteArrayElements(bytes_, yuvData, 0);
				string ss = strStream.str();
			}
		}
	}
</code></pre>
<p>###导出so，打入58APP<br>
最后，在demo中运行一下，看看效果。<br>
<img src="https://i.loli.net/2019/06/17/5d077e8e60ec060459.gif" alt="1557793019816360 (1).gif"></p>
<p>##心得<br>
其实最终解决这个问题不难，重点在于发现问题，解决问题的过程学到了什么。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手把手教你如何不刷机Hook代码]]></title>
        <id>https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma</id>
        <link href="https://Mozziehh.github.io/post/shou-ba-shou-jiao-ni-ru-he-bu-shua-ji-hook-dai-ma">
        </link>
        <updated>2019-11-22T00:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>##1. 背景</p>
<blockquote>
<p>前几个月，我们同TEG的同学一起排查一个问题：B端用户使用黑产提供的软件来Hook我们的API，达到在发送IM消息时发送自定义消息的目的，比如：在tips里面弹出，“淘宝客服，日结300，加V xxxxxxx”</p>
</blockquote>
<blockquote>
<p>带着一颗强烈的好奇心，我走进了Xposed的世界，发现原来Android的世界还可以如此精彩。</p>
</blockquote>
<p>##2. Xposed-从入门到放弃<br>
提起Xposed，可能很多人都听过它的名字，知道它是什么。</p>
<p>但是具体再深挖一下，它的原理是什么，可能大家就会回答的很模糊。</p>
<p>如果再深挖一下，const u2* insns是干什么用的？</p>
<p>如何再涉及到实践，如何Hook一个私有方法？</p>
<p>相信大家心里就会说：“这跟我有什么关系~~”</p>
<p>对的，一开始我也是这样的。但是一步步走下来，你会发现这个东西根本没那么难。那么，就跟我一起来学习下这块的相关知识吧。</p>
<p>###2.1 什么是Xpose？<br>
Xposed 框架是一款可以在不修改 APK 的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作，在这个框架下，我们可以加载很多插件 App ，这些插件 App 可以直接或间接劫持、篡改、伪造一些信息。</p>
<p>###2.2 它的原理是什么？</p>
<p>####2.2.1 Xposed资源<br>
·XposedBridge.jar：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。</p>
<p>·Xposed：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p>·XposedInstaller：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。</p>
<p>·XposedMods：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<p>####2.2.2 Zygote<br>
在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。这也是Xposed选择替换app_process的原因。</p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<p>####2.2.3 Hook<br>
在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
<p>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。在hookMethodNative的实现中，会调用XposedBridge中的handleHookedMethod这个方法来传递参数。handleHookedMethod这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是xposedCallHandler。而handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数，并调用他们的before, after函数。</p>
<p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：</p>
<p>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
<p>###2.3 为什么后来又放弃了？<br>
研究了一段时间之后，寻思就开始上手吧。<br>
####2.3.1 刷机成本<br>
Xposed是需要root手机的，于是就开始研究刷机，我手里有两个锤子手机，其中一个呢，已经被我彻底刷成了“锤子”，平时砸个核桃啥的用起来还算是顺手。另外一个，刷完之后，我手机里面的东西还都需要重新安装，有些APK是市场上已经找不到了。而且，我们目前使用的手机，主流的小米、OPPO、VIVI、华为，这些手机的刷机方式已经不再像原来那样简单，下载一个安装包，同时按住电源键+ Home + 音量“+”等一会那么简单了。而且刷完之后，不是NFC不好用，就是WIFI坏了。要是没有一款可要可不要的闲置手机，真的不建议刷。<br>
####2.3.2 脱壳也是一件麻烦事<br>
接下来再想，我们突破了种种困难，完成了刷机。但是当我们需要Hook方法的时候又会犯难，因为现在加壳的APK，反编译之后外面就一两个类，根本无从下手，还需要再研究脱壳。</p>
<p>渐渐地，我就发现原本我的目标：想看看如何模拟黑产去Hook一个API，但是这样的路让我越走越远。方向没错，但是不禁觉得这是在浪费时间。难道就真的没有办法了么？</p>
<p>接下来就来介绍一下，今天的猪脚，Virtual Xposed~~<br>
##3. Virutal Xposed<br>
对于我这样的“刚需”，它是一款神器。为什么，首先它不需要刷机，它的脱壳也是非常的简单。就这么简单的两点，完全解决了我的痛点。<br>
###3.1 它与Xposed从原理上的区别<br>
VirtualXposed 并未对系统底层进行任何修改，也没有利用什么神奇的漏洞。它的工作原理有点像那些双开软件。</p>
<p>VirtualXposed 是通过在你的手机里创建一个「虚拟环境」，然后在此虚拟环境中启用 Xposed。</p>
<p>###3.2 FDex2</p>
<p>###3.3 Demo<br>
##偷偷搞一波58试试</p>
<p>参考文章：<br>
http://yx.bsh.me/23278.html<br>
https://mp.weixin.qq.com/s/PG7ykzTWkw4tARjp0yKeAQ<br>
https://mp.weixin.qq.com/s/AlZMhMZ-SFOxRMtXfcev1g<br>
https://blog.csdn.net/ascii2/article/details/47974217<br>
https://blog.csdn.net/wxyyxc1992/article/details/17320911</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter接入第三方SDK]]></title>
        <id>https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk</id>
        <link href="https://Mozziehh.github.io/post/flutter-jie-ru-di-san-fang-sdk">
        </link>
        <updated>2019-11-22T00:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>#Flutter接入第三方SDK<br>
最近开始使用Flutter，发现我们可以写出原生的页面，使用Dart语言完成逻辑的编程。但是假如我们需要接入一个第三方SDK，这个时候应该怎么办呢？<br>
##接入第三方SDK-登录SDK<br>
登录SDK是58出的一款适用于全公司的一套登录体系。登录SDK是以一个AAR的形式提供的。该aar包含classes.jar、资源文件、assets文件、AndroidManifest.xml以及R.txt文件。</p>
<p>##Java的接入方式<br>
首先这是一个全新的挑战，接到手之后完全不知道该怎么弄。<br>
这里我们先回顾一下，在使用Java开发的时候，我们是如何引入AAR的：</p>
<blockquote>
<p>1.配置build.gradle文件，添加implementation 'xxx:xxxx:'</p>
<p>2.编译</p>
<p>3.调用</p>
</blockquote>
<p>##Flutter的接入方式<br>
那么Flutter的接入方式与Java的方式有什么不同呢？我们也试着按照上面的三种方式来做一次:</p>
<p>###配置AAR &amp; 编译<br>
这个配置AAR的方式有点诡异，需要在File -&gt; new -&gt; new Module -&gt; Import .AAR package，添加依赖之后，它会自动编译，然后你就会发现可以打开了。</p>
<p>然鹅，这种方式，是错误的。因为你把这个AAR引入到Flutter的工程里面，但是并没有引入到android的项目中来，因为我发现调用的时候依然调用不了。</p>
<p>另外，我发现在android目录下有一个MainActivity.java文件，大概率就是在这里添加跟Flutter页面的交互了。<br>
可是我发现这个类编辑之后没有任何代码提示，直觉告诉我这里缺一些东西，缺的是android的编译环境：</p>
<p>答案就是：双开</p>
<p>通过File -&gt; Open的形式，用android studio再打开一个目录引入android工程。</p>
<p>接下来的依赖关系也就变得顺其自然，双开固然麻烦，但是当你用flutter运行的那一刻，你就发现，一切都是值得的。</p>
<h3 id="模块设计">模块设计</h3>
<p>将登录SDK的模块引入，使得Flutter内部可以通过MethodChannel来调用Android的方法</p>
<p>登录SDK的特点：</p>
<p>1.无需实现UI界面；</p>
<p>2.需要设置页面监听；</p>
<p>3.接收回调之后可以及时展示到用户界面上</p>
<h3 id="登录sdk的引入">登录SDK的引入</h3>
<p>由于Flutter默认不支持<code>armeabi</code>的CPU架构，并且由于我们是并行开发，所以改动太多配置文件也会增加同学们的学习成本。所以，这里我们直接让登录SDK提供了支持了64位CPU架构测试AAR。<br>
同时，我们在android目录下修改了如下配置：</p>
<p>android目录下,修改了build.gradle文件：</p>
<pre><code>
buildscript {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
        mavenLocal()
        maven {
            url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
        }
        google()
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
    }
}

</code></pre>
<p>app目录下，修改了build.gradle添加了如下依赖<code>这些依赖都是必须的</code>：</p>
<pre><code>implementation 'com.wuba.wuxian.sdk:login:2.1.6.4.1-test'
    implementation 'com.wuba.wuxian.third:weichatsoter:1.3.10'
    implementation 'com.wuba.certify:deviceid:2.2.11'
    implementation 'com.wuba.xxzl:fastlogin:2.0.2.0'
    implementation 'io.reactivex:rxjava:1.3.8'
    implementation 'io.reactivex:rxandroid:1.2.1'
</code></pre>
<h3 id="flutter添加调用">Flutter添加调用</h3>
<p>在flutter的页面上，开发者可以随便使用UI元素，通过MethodChannel建立回调通道，在UI控件上设置点击事件调起登录并监听登录结果、<br>
通过platform.invokeMethod调起对应的登录方式、setState来设置结果、flutter监听变化后，会刷新并展示；</p>
<h4 id="flutter的调用">Flutter的调用</h4>
<p>主要是在<code>WubaLoginClientTestComponent</code>类里面；</p>
<pre><code>///定义一个MethodChannel
static const platform = const MethodChannel('com.wuba.flutter.flutter_hades/login');

///具体的调用方法
child: GestureDetector(
              child: new Row(
                children: &lt;Widget&gt;[
                  new Text(
                    '调起58登录: ' + _loginResult,
                    style: new TextStyle(
                        color: const Color(0xff353535), fontSize: 16.0),
                  ),
                ],
              ),
              onTap: _startWubaLogin,
            ),
            
///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

</code></pre>
<h4 id="接收回调刷新ui">接收回调刷新UI</h4>
<pre><code>///_loginResult ：是登陆的结果；
///_startWubaLogin ：是调用的方法；

  String _loginResult = '';
  Future&lt;Null&gt; _startWubaLogin() async {
    String loginResult;
    try{
      loginResult = await platform.invokeMethod('wubaLogin');
    } on PlatformException catch (e){
      loginResult = &quot;error&quot;;
    }

    setState(() {
      _loginResult = loginResult;
    });
  }
</code></pre>
<h3 id="android接收调用">Android接收调用</h3>
<h4 id="初始化">初始化</h4>
<p>登录SDK的初始化可以按需要选取构建项，通过构建者模式来构建（由于第三方登录微信登录需要正式签名，所以引入目前也无法调用，所以暂时先不引入）：</p>
<pre><code>        LoginSdk.LoginConfig loginConfig = new LoginSdk.LoginConfig()
                //根据统一开关，上线后关闭log
                .setLogLevel(ILogger.STANDARD_LOG)
                //必选，设置product id, 由产品统一约定
                .setProductId(&quot;58app&quot;)
                .setLogoResId(R.drawable.wb_new_icon)
                //可选，如果集成三方登录，则设置相应的开放平台key
//                .setThirdLoginConfig(WubaSettingCommon.QQ_API_KEY, WubaSettingCommon.CONSUMER_KEY_WEIXIN, WubaSettingCommon.CONSUMER_KEY_SINA, WubaSettingCommon.REDIRECT_URL_SINA)
                .setNeedInitFaceVerify(true, &quot;Xenh6dVg&quot;)
                .setIsLoginRelyOnUserInfo(true)
                .setGatewayLoginAppId(&quot;ef2b526cdb4948b1bf7556f23d0a15da&quot;);
        //初始化
        LoginSdk.register(this, loginConfig);
</code></pre>
<h4 id="设置回调">设置回调</h4>
<p>设置通道：</p>
<pre><code>  private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
</code></pre>
<p>接收Flutter发送过来的调用，并调用登录SDK：</p>
<pre><code>LoginClient.register(mLoginCallback);
    new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
                if(call.method.equals(&quot;wubaLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaPhoneLogin&quot;)){
                  LoginClient.launch(MainActivity.this, Request.PHONE_LOGIN);
                  mResult = result;
                } else if(call.method.equals(&quot;wubaRegister&quot;)){
                  LoginClient.launch(MainActivity.this, Request.REGISTER);
                  mResult = result;
                } else if(call.method.equals(&quot;getUserID&quot;)){
                  result.success(LoginClient.getUserID(MainActivity.this));
                } else if(call.method.equals(&quot;getUserPPU&quot;)){
                  result.success(LoginClient.getTicket(MainActivity.this, &quot;.58.com&quot;, &quot;PPU&quot;));
                } else if(call.method.equals(&quot;getUserName&quot;)){
                  result.success(LoginClient.getUserName(MainActivity.this));
                } else {
                  result.notImplemented();
                }
              }
            });
</code></pre>
<p>页面可以销毁后，给出去回调：</p>
<pre><code>LoginCallback mLoginCallback = new SimpleLoginCallback(){
    @Override
    public void onLogin58Finished(boolean isSuccess, String msg, LoginSDKBean loginSDKBean) {
      super.onLogin58Finished(isSuccess, msg, loginSDKBean);
        if(mResult != null){
          if(isSuccess){
            mResult.success(msg);
          }
        }
    }
  };
</code></pre>
<h2 id="细说methodchannel">细说MethodChannel</h2>
<h3 id="什么是methodchannel">什么是MethodChannel？</h3>
<p>《Flutter中文网》上面描述的标题是：插件开发：Android端API实现，也就是说，MethodChannel是Flutter实现与Android通过API交互的插件。通过上面的例子，我们也可以清楚的回顾它的一些特点，Flutter即时调用，Android得到反馈，Flutter进行UI展示，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="flutter_api.png" alt="flutter_api.png"></figure>
<h3 id="它的主要流程是什么">它的主要流程是什么？</h3>
<blockquote>
<p>1.在flutter端：设置一个MethodChannel：static const platform = const MethodChannel('samples.flutter.io/battery');</p>
<p>2.在flutter端：通过invoke方法调用：await platform.invokeMethod('getBatteryLevel');</p>
<p>3.在flutter端：写UI来接收回调<br>
children: [<br>
new RaisedButton(<br>
child: new Text('Get Battery Level'),<br>
onPressed: _getBatteryLevel,<br>
),<br>
new Text(_batteryLevel),<br>
],</p>
<p>4.在android端：调用setMethodCallHandler方法：</p>
<p>new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(<br>
new MethodCallHandler() {<br>
@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
// TODO<br>
}<br>
});</p>
<p>5.在android端：实现onMethodCall回调：</p>
<p>@Override<br>
public void onMethodCall(MethodCall call, Result result) {<br>
if (call.method.equals(&quot;getBatteryLevel&quot;)) {<br>
int batteryLevel = getBatteryLevel();<br>
if (batteryLevel != -1) {<br>
result.success(batteryLevel);<br>
} else {<br>
result.error(&quot;UNAVAILABLE&quot;, &quot;Battery level not available.&quot;, null);<br>
}<br>
} else {<br>
result.notImplemented();<br>
}<br>
}</p>
</blockquote>
<h3 id="它的原理是什么">它的原理是什么？</h3>
<p>针对上面的流程我们有两个疑问：</p>
<ol>
<li>
<p>platform.invokeMethod怎么把对应的method调起来的？</p>
</li>
<li>
<p>result.success是如何回调到</p>
</li>
</ol>
<h3 id="源码阅读">源码阅读</h3>
<p>上源码之前，我们先来看个图：</p>
<p>官方说明：</p>
<blockquote>
<p>A named channel for communicating with platform plugins using asynchronous method calls.Method calls are encoded into binary before &gt;being sent, and binary results received are decoded into Dart values. The [MethodCodec] used must be compatible with the one used by the platform plugin. This can be achieved by creating a method channel counterpart of this channel on the platform side. The Dart type of arguments and results is <code>dynamic</code>, but only values supported by the specified [MethodCodec] can be used. The use of unsupported values should be considered programming errors, and will result in exceptions being thrown. The null value is supported for all codecs. The logical identity of the channel is given by its name. Identically named channels will interfere with each other's communication.</p>
</blockquote>
<blockquote>
<p>大概的意思：定义一个管道，利用异步方法跟平台插件进行交互。方法里面的参数必须是一个特定独一无二的，不能是特殊字符或者已经定义好的有含义的标识符。</p>
</blockquote>
<p>MethodChannel一共有三个参数，它们分别是：String name、StandardMethodCodec codec、binaryMessenger；</p>
<p>其中name是必选参数、后面两个是可选参数；</p>
<p>name:格式通常是：包名/方法名，例如：'com.wuba.flutter.flutter_hades/login'；</p>
<p>StandardMethodCodec codec：标准方法编码，有点类似于Java的序列化，里面有两个方法：ByteData encodeMessage(T message);和T decodeMessage(ByteData message);</p>
<p>BinaryMessenger ：这个类就是用来追踪管道的message的，分发并记录每一个注册了管道的handler并回调；</p>
<h4 id="platforminvokemethod">platform.invokeMethod</h4>
<p>MethodHandler提供了一个方法invokeMethod，这个方法就是调用的入口函数：</p>
<pre><code>@optionalTypeArgs
  Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [ dynamic arguments ]) async {
    assert(method != null);
    final ByteData result = await binaryMessenger.send(
      name,
      codec.encodeMethodCall(MethodCall(method, arguments)),
    );
    if (result == null) {
      throw MissingPluginException('No implementation found for method $method on channel $name');
    }
    final T typedResult = codec.decodeEnvelope(result);
    return typedResult;
  }
</code></pre>
<p>我们主要是看这个binaryMessenger.send的方法：</p>
<pre><code>@override
  Future&lt;ByteData&gt; send(String channel, ByteData message) {
    final MessageHandler handler = _mockHandlers[channel];
    if (handler != null)
      return handler(message);
    return _sendPlatformMessage(channel, message);
  }
</code></pre>
<p>通过Map存储到key-value，key代表的是channel，就是我们刚才设置的MethodChannel中的name，value是handler，这个就相当于track。</p>
<p>接下来调用Flutter的UI顶层的实现方式：</p>
<pre><code>ui.window.sendPlatformMessage(channel, message, (ByteData reply) {
      try {
        completer.complete(reply);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: ErrorDescription('during a platform message response callback'),
        ));
      }
    });
</code></pre>
<p>ui.window类似于android里面的window？</p>
<pre><code>void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) {
    final String error =
        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);
    if (error != null)
      throw Exception(error);
  }
</code></pre>
<p>跟到这里，我们发现调用的Native的方法：</p>
<pre><code>String _sendPlatformMessage(String name,
                              PlatformMessageResponseCallback callback,
                              ByteData data) native 'Window_sendPlatformMessage';
</code></pre>
<p>接下来，我们看c++是怎么写的：</p>
<pre><code>Dart_Handle SendPlatformMessage(Dart_Handle window,
                                const std::string&amp; name,
                                Dart_Handle callback,
                                const tonic::DartByteData&amp; data) {
  UIDartState* dart_state = UIDartState::Current();

  ...

  fml::RefPtr&lt;PlatformMessageResponse&gt; response;
  if (!Dart_IsNull(callback)) {
    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(
        tonic::DartPersistentValue(dart_state, callback),
        dart_state-&gt;GetTaskRunners().GetUITaskRunner());
  }
  if (Dart_IsNull(data.dart_handle())) {
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));
  } else {
    const uint8_t* buffer = static_cast&lt;const uint8_t*&gt;(data.data());

    // data数据部位null，会走下面这块代码
    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(
        fml::MakeRefCounted&lt;PlatformMessage&gt;(
            name, std::vector&lt;uint8_t&gt;(buffer, buffer + data.length_in_bytes()),
            response));
  }

  return Dart_Null();
}
</code></pre>
<p>我们看这里有一段代码，叫做HandlePlatformMessage，这段代码在<code>../engine/shell/common/engine.cc</code></p>
<pre><code>void Engine::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  if (message-&gt;channel() == kAssetChannel) {
    HandleAssetPlatformMessage(std::move(message));
  } else {
    delegate_.OnEngineHandlePlatformMessage(std::move(message));
  }
}

void Shell::OnEngineHandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
    
  ...
  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(
      [view = platform_view_-&gt;GetWeakPtr(), message = std::move(message)]() {
        if (view) {
          view-&gt;HandlePlatformMessage(std::move(message));
        }
      });
}
</code></pre>
<p>platform_view_是一个继承了PlatformView类的PlatformViewAndroid对象，该对象在创建AndroidShellHolder对象时被创建。view-&gt;HandlePlatformMessage执行以下方法，<code>../engine/shell/platform/android/platform_view_android.cc</code></p>
<pre><code>void PlatformViewAndroid::HandlePlatformMessage(
    fml::RefPtr&lt;blink::PlatformMessage&gt; message) {
  JNIEnv* env = fml::jni::AttachCurrentThread();
  fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.get(env);
  if (view.is_null())
    return;

  int response_id = 0;
  if (auto response = message-&gt;response()) {
    response_id = next_response_id_++;
    pending_responses_[response_id] = response;
  }
  auto java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());
  if (message-&gt;hasData()) {
    fml::jni::ScopedJavaLocalRef&lt;jbyteArray&gt; message_array(
        env, env-&gt;NewByteArray(message-&gt;data().size()));
    env-&gt;SetByteArrayRegion(
        message_array.obj(), 0, message-&gt;data().size(),
        reinterpret_cast&lt;const jbyte*&gt;(message-&gt;data().data()));
    message = nullptr;

    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.
    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),
                                     message_array.obj(), response_id);
  } else {
    ...
  }
}
</code></pre>
<p>于是，我们最终跟到了JNI的最终方法，它调用的是<code>FlutterJNI.java</code>中的handlePlatformMessage：</p>
<pre><code>static jmethodID g_handle_platform_message_method = nullptr;
void FlutterViewHandlePlatformMessage(JNIEnv* env,
                                      jobject obj,
                                      jstring channel,
                                      jobject message,
                                      jint responseId) {
  env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,
                      responseId);
  FML_CHECK(CheckException(env));
}

private void handlePlatformMessage(String channel, byte[] message, int replyId) {
    if (this.platformMessageHandler != null) {
        this.platformMessageHandler.handleMessageFromDart(channel, message, replyId);
    }
}

public void handleMessageFromDart(final String channel, byte[] message, final int replyId) {
    FlutterNativeView.this.assertAttached();
    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);
    if (handler != null) {
        try {
            ByteBuffer buffer = message == null ? null : ByteBuffer.wrap(message);
            handler.onMessage(buffer, new BinaryReply() {
                private final AtomicBoolean done = new AtomicBoolean(false);

                public void reply(ByteBuffer reply) {
                    if (!FlutterNativeView.this.isAttached()) {
                        Log.d(&quot;FlutterNativeView&quot;, &quot;handleMessageFromDart replying ot a detached view, channel=&quot; + channel);
                    } else if (this.done.getAndSet(true)) {
                        throw new IllegalStateException(&quot;Reply already submitted&quot;);
                    } else {
                        if (reply == null) {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
                        } else {
                            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());
                        }

                    }
                }
            });
        } catch (Exception var6) {
            Log.e(&quot;FlutterNativeView&quot;, &quot;Uncaught exception in binary message listener&quot;, var6);
            FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
        }

    } else {
        FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
    }
}
</code></pre>
<p>这里面我们看到这样一段代码，    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);<br>
那这个handler是如何根据channel跟踪到的呢？我们已经到Java方法了啊可。</p>
<p>所以，我们试着回想一下，当时是不是在MainActivity里面也设置了个同名的String， 这个字符串有点似曾相识呢。由此猜想，这个handler可能是当时我们自己设进去的，我们来看看如下代码<code>setMethodCallHandler</code>：</p>
<pre><code>private static final String CHANNEL = &quot;com.wuba.flutter.flutter_hades/login&quot;;
new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
            new MethodChannel.MethodCallHandler() {
              @Override
              public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                // Note: this method is invoked on the main thread.
              }
            });
            
            public void setMethodCallHandler(@Nullable MethodChannel.MethodCallHandler handler) {
    this.messenger.setMessageHandler(this.name, handler == null ? null : new MethodChannel.IncomingMethodCallHandler(handler));
}

public void setMessageHandler(String channel, BinaryMessageHandler handler) {
    this.mNativeView.setMessageHandler(channel, handler);
}
</code></pre>
<p>接下来我们继续看这个<code>handler.onMessage()</code>方法：</p>
<pre><code>public void onMessage(ByteBuffer message, final BinaryReply reply) {
    MethodCall call = MethodChannel.this.codec.decodeMethodCall(message);

    try {
        this.handler.onMethodCall(call, new MethodChannel.Result() {
            public void success(Object result) {
                reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));
            }

            public void error(String errorCode, String errorMessage, Object errorDetails) {
                reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));
            }

            public void notImplemented() {
                reply.reply((ByteBuffer)null);
            }
        });
    } catch (RuntimeException var5) {
        Log.e(&quot;MethodChannel#&quot; + MethodChannel.this.name, &quot;Failed to handle method call&quot;, var5);
        reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(&quot;error&quot;, var5.getMessage(), (Object)null));
    }

}
</code></pre>
<p>方法中首先将从c++层传递过来的消息通过codec解码为MethodCall对象，然后调用MainActivity中实现的MethodHandler的onMethodCall方法，改方法实现中会执行android的API调用，然后调用result.success()方法，通过reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));将结果数据编码后进行返回。reply方法中会调用FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());方法将响应结果返回。</p>
<p>然后回调给C++层。</p>
<p>最终回调给UI层，调用setState完成整个更新。</p>
<h3 id="总结">总结</h3>
<p>1.Flutter调用invokeMethod方法，将code转码和并建立跟踪对应的Messagehandle；</p>
<p>2.在c++层对其进行封装，通过sendPlatformMessage调用JNI方法；</p>
<p>3.根据调用方法找到最终调用已经注册好的Java对象的对应方法；</p>
<p>4.获取回调结果并将结果返回给C++层；</p>
<p>5.C++层获取结果后最终返回给Flutter的setState方法，刷新UI；</p>
<h3 id="预览效果图">预览效果图</h3>
<figure data-type="image" tabindex="2"><img src="flutter_loginsdk.png" alt="flutter_loginsdk.png"></figure>
<h3 id="接入报错">接入报错</h3>
<p>1.A problem occurred configuring project ':sqflite'.</p>
<p>Could not download groovy-all.jar</p>
<p>如果出现资源找不到，一般都是gradle的配置文件出现了问题，我们可以通过引入配置来解决：在工程-&gt;android-&gt;build.gradle下，对于buildscript和allprojects中的repositories进行修改，添加如下代码：</p>
<pre><code>maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
</code></pre>
<p>2.注册跳转页面需要添加路由</p>
<p>注册一个页面，虽然不需要像android原生一样在androidmanifest.xml文件中注册activity，但是在flutter里面，需要注册路由。路由分为静态路由和动态路由，只有注册后，才能完成跳转；</p>
<p>3.This Overlay widget cannot be marked as needing to build because the framework is already in the<br>
process of building widgets</p>
<p>我通过A页面添加了一个GestureDetector的onTap事件跳转进入B页面，但是当我用同样的方法在B页面再添加GestureDetector的时候，在onTap里面添加之后就会报错；</p>
<pre><code>onTap: _onWubaLoginClick(), 
看见没，上面代码，原来是多加了一个()，Java里调用方法就是有括号的啊，再说你这个报错可真的是让我好找啊~
</code></pre>
<p>4.flutter工程下，无法编译android下的MainActivity.java</p>
<p>新开一个工程，开发flutter的android工程即可</p>
<p>5.善于利用工具</p>
<p>在进行flutter开发的时候，我们难免会遇到各种各样的问题，其实大部分我们都可以在官方文档里面得到解决。</p>
<p>所以有事没事，看看官网：<br>
https://flutterchina.club/platform-channels/</p>
<p>6.引入58的第三方找不到库</p>
<p>其实是没有配置maven仓库，需要</p>
<pre><code>mavenLocal()
maven {
   url &quot;http://artifactory.58corp.com:8081/artifactory/android-public&quot;
}
</code></pre>
<p>7.java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; is 32-bit instead of 64-bit</p>
<p>58APP接入的是32位的，那么为啥在这个flutter的工程里面，它需要引入的是64位的呢？</p>
<p>8.libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0</p>
<pre><code>java.lang.UnsatisfiedLinkError: dlopen failed: file offset for the library &quot;/data/user/0/com.wuba.flutter.flutter_hades/files/lib/libcom_wuba_uc_rsa.so&quot; &gt;= file size: 0 &gt;= 0
        at java.lang.Runtime.load0(Runtime.java:928)
        at java.lang.System.load(System.java:1621)
        at com.wuba.uc.RsaCryptService.b(RsaCryptService.java:43)
        at com.wuba.uc.RsaCryptService.a(RsaCryptService.java:24)
        at com.wuba.loginsdk.internal.b.process(InitCommon.java:24)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:144)
        at com.wuba.loginsdk.external.LoginSdk.register(LoginSdk.java:60)
        at com.wuba.flutter.flutter_hades.WubaApplication.registeWubaLogin(WubaApplication.java:31)
        at com.wuba.flutter.flutter_hades.WubaApplication.onCreate(WubaApplication.java:15)
        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1119)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5881)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
</code></pre>
<p>9.support-v4</p>
<pre><code>java.lang.RuntimeException: Unable to get provider com.wuba.loginsdk.provider.PassportFileProvider: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at android.app.ActivityThread.installProvider(ActivityThread.java:6447)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950)
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862)
        at android.app.ActivityThread.-wrap1(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690)
        at android.os.Handler.dispatchMessage(Handler.java:105)
        at android.os.Looper.loop(Looper.java:176)
        at android.app.ActivityThread.main(ActivityThread.java:6701)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;com.wuba.loginsdk.provider.PassportFileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        at android.app.ActivityThread.installProvider(ActivityThread.java:6423)
        at android.app.ActivityThread.installContentProviders(ActivityThread.java:5950) 
        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5862) 
        at android.app.ActivityThread.-wrap1(Unknown Source:0) 
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690) 
        at android.os.Handler.dispatchMessage(Handler.java:105) 
        at android.os.Looper.loop(Looper.java:176) 
        at android.app.ActivityThread.main(ActivityThread.java:6701) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:249) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783) 
    	Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Landroid/support/v4/content/FileProvider;
        at java.lang.VMClassLoader.findLoadedClass(Native Method)
        at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:363)
        		... 12 more
     Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;android.support.v4.content.FileProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/lib/arm64, /data/app/com.wuba.flutter.flutter_hades-pyib-R74ajY34PslDyjFsg==/base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]
        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:93)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)
        		... 15 more
</code></pre>
<p>10.wlog&amp;soter&amp;两个图片资源找不到</p>
<h3 id="参考文章">参考文章</h3>
<p>https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html<br>
https://www.jianshu.com/p/185c42fe002b</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Mozziehh.github.io/post/hello-gridea</id>
        <link href="https://Mozziehh.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>