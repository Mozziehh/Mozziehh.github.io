<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Mozziehh.github.io</id>
    <title>mozzie</title>
    <updated>2020-07-07T00:34:40.651Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Mozziehh.github.io"/>
    <link rel="self" href="https://Mozziehh.github.io/atom.xml"/>
    <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
    <logo>https://Mozziehh.github.io/images/avatar.png</logo>
    <icon>https://Mozziehh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, mozzie</rights>
    <entry>
        <title type="html"><![CDATA[聊一聊部落直播的那些事儿]]></title>
        <id>https://Mozziehh.github.io/post/liao-yi-liao-bu-luo-zhi-bo-de-na-xie-shi-er/</id>
        <link href="https://Mozziehh.github.io/post/liao-yi-liao-bu-luo-zhi-bo-de-na-xie-shi-er/">
        </link>
        <updated>2020-07-07T00:11:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="聊一聊部落直播的那些事儿">聊一聊部落直播的那些事儿</h1>
<h2 id="1背景">1.背景</h2>
<p>58同城作为国内最大的生活信息服务平台，一直致力于为用户解决生活难题，迄今为止我们开拓了工作、房、车、生活、服务、金融相关的大量细化业务，很大程度上方便了用户的生活。</p>
<p>然而我们同时发现，用户生活中各式各样的困难很难全部细化为流程，为了方便用户解决个性化的问题，我们上线了“部落”业务。在这里，用户可以不受限于固定流程，自由地询问自己的困惑、分享自己的生活、获取自己需要的信息。</p>
<p>为了让用户更方便、更高效地分享、获取信息，我们进一步提供了直播功能，这就是58同城中直播的应用场景。</p>
<p>58同城做为接入方，负责接入TEG提供的视频/直播SDK，并在它的基础上进行封装，接下来将从两个部分来主要说明：</p>
<ul>
<li>做为接入方针对视频/直播SDK整体架构的理解；</li>
<li>基于这种架构我们的设计实现思路；</li>
</ul>
<h2 id="2直播整体架构的理解">2.直播整体架构的理解</h2>
<h3 id="21-整体架构">2.1 整体架构</h3>
<p>众所周知，直播分为服务端和客户端两部分，客户端又分为推流端（主播）和拉流端（观众）。<br>
要想实现直播功能，需要在服务端和客户端分别完成两部分：一个是音视频流的采集、传输、播放，另一个是客户端与服务端之间的长连接数据同步以及直播间（聊天室）生命周期控制等其他基础服务。</p>
<p>整体结构如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/04/07/pWzDfBtjymAUvb5.png" alt="直播结构图.png" loading="lazy"></figure>
<p>整体流程如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/04/07/s26F8yDiwnvdP53.png" alt="直播流程图.png" loading="lazy"></figure>
<h3 id="22-音视频采集">2.2 音视频采集</h3>
<h4 id="221-音频">2.2.1 音频</h4>
<p>Android中采集音频流数据可以使用以下两个类：</p>
<ul>
<li><code>android.media.MediaRecorder</code>：集成了录音、编码、容器封装等多个步骤，可以直接输出aac、amr、3gp等格式的音频文件，其实内部也是使用了下面的AudioRecord类；</li>
<li><code>android.media.AudioRecord</code>：AudioRecord属于较底层的API，可以输出PCM格式文件(脉冲编码调制，是未经压缩的音频采样数据裸流)，而且可以直接获取到实时音频流，更加符合我们的直播场景。</li>
</ul>
<p>在使用AudioRecord采集音频时，我们可以在构造方法中指定以下参数：</p>
<pre><code class="language-java">/**
 * @param audioSource 音频的输入源
 * @param sampleRateInHz 采样率，44100Hz是通用频率，22050、16000、11025等只适用于特定机型
 * @param channelConfig 声道
 * @param audioFormat 采样格式，即一个采样点用几个字节表示
 * @param bufferSizeInBytes 音频缓冲区大小，不能小于getMinBufferSize
 */
AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes)
</code></pre>
<p>然后<code>startRecording</code>后通过<code>read</code>方法获取音频流输出到buffer数组中，这个音频流数据就是原始PCM格式的。</p>
<h4 id="222-视频">2.2.2 视频</h4>
<p>采集视频可以使用<code>android.hardware.Camera</code>类或者<code>android.hardware.camera2</code>相关类。</p>
<h4 id="2221-camera">2.2.2.1 Camera</h4>
<p>Camera使用较为简单，<code>setPreviewDisplay(SurfaceHolder)</code>或者<code>setPreviewTexture(SurfaceTexture)</code>设置渲染面板，<code>startPreview</code>开启预览后即可在<code>Camera.PreviewCallback#onPreviewFrame(byte[], Camera)</code>回调中获取到每一帧原始YUV格式的数据。</p>
<h4 id="2222-camera2">2.2.2.2 Camera2</h4>
<p>这是Google在android5.0推出的Camera API的升级版本，它有以下几个特点：</p>
<ul>
<li>架构设计更合理：camera2把framework和camera抽象为了AndroidDevice和CameraDevice，它们创建一个CameraCaptureSession会话，AndroidDevice发送CaptureRequest给CameraDevice，然后CameraDevice返回CameraMetadata数据对象；</li>
<li>提供了很多Camera不支持的特性，例如30fps高清连拍、0延迟快门、RAW格式图片拍摄、噪音消除等</li>
<li>依赖于HAL3(Hardware Abstraction Layer 硬件抽象层)，但是很多手机硬件还不能完全支持HAL3协议，很多特性并不一定都可以实现；</li>
</ul>
<p>由于很多设备仍然需要依赖老版本HAL，所以在未来一段时间里CameraAPI都不会删除，我们也可以暂时不做支持。</p>
<h4 id="2223-yuv在58的演进-todo-huhao">2.2.2.3 YUV在58的演进 TODO-huhao</h4>
<p>早期版本确实使用了YUV数据进行图像数据的处理及传递，目前已经放弃直接使用YUV格式数据，改为纹理输出，使用OpenGL ES直接对纹理数据进行处理，然后将纹理数据送入编码器<br>
建议Camera与GLSurfaceView的运用一起讲解</p>
<blockquote>
<p>感兴趣的同学可以看一下Google的两个示例 <a href="https://github.com/googlearchive/android-Camera2Basic">android-Camera2Basic</a>, <a href="https://github.com/googlesamples/android-Camera2Video">android-Camera2Video</a></p>
</blockquote>
<h3 id="23降噪">2.3降噪：</h3>
<h4 id="231-什么是降噪">2.3.1 什么是降噪？</h4>
<p>“噪音是一类引起人烦躁、或音量过强而危害人体健康的声音。从环境保护的角度讲：凡是妨碍人们正常休息、学习和工作的声音，以及对人们要听的声音产生干扰的声音，都属于噪音。从物理学的角度讲：噪音是发声体做无规则振动时发出的声音”</p>
<p>在直播的过程中，噪声主要由主播端传输一些除了主播想要表达的声音之外的额外声音。</p>
<p>所以，降噪就是把在主播端发送这些带有杂音的音频数据进行一个噪声消除的过程。</p>
<h4 id="232-有哪些降噪方案">2.3.2 有哪些降噪方案？</h4>
<p>常见的开源降噪方案</p>
<ul>
<li>Speex</li>
</ul>
<p>Speex是一套主要针对语音的开源免费，无专利保护的应用集合，它不仅包括编解码器，还包括VAD(语音检测)、DTX(不连续传输)、AEC(回声消除)、NS(去噪)等实用模块。</p>
<ul>
<li>WebRTC</li>
</ul>
<p>WebRTC提供了视频会议的核心技术，包括音视频的采集、编解码、网络传输、显示等功能，并且还支持跨平台：Windows、Linux、Mac、Android。我们这里使用的就是WebRTC的音频处理模块audio_processing。</p>
<ul>
<li>RNNoise</li>
</ul>
<p>RNNoise降噪算法是根据纯语音以及噪声通过GRU训练来做。包含特征点提取、预料等核心部分。</p>
<ul>
<li>58降噪处理 TODO-huhao</li>
</ul>
<p>AcousticEchoCanceler（回声消除）</p>
<p>NoiseSuppressor（降噪）</p>
<p>AutomaticGainControl（自动增益）</p>
<p>LoudnessEnhancer（响度增强）处理音频采集数据</p>
<h4 id="233-webrtc的初步介绍">2.3.3 WebRTC的初步介绍？</h4>
<p>WebRTC原本是基于Global IP Solutions公司的一个核心技术，与2010年被Google收购，随后开源。</p>
<p>WebRTC 的本质是将实时通信应用所需要的音/视频捕获及处理模块、网络传输及会话控制等协议集成到Web浏览器中，从而屏蔽底层硬件实现或操作系统之间的差异。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/05/08/a3Yu8MyP2rGkSJb.png" alt="zhibojiangzao.png" loading="lazy"></figure>
<p>上图给出了基于WebRTC开源项目的WebRTC架构的一种实现。第三方Web App开发者可以通过浏览器提供Web API调用音/视频实时通信能力，相关接口函数需符合W3C组织的WebRTC 接口规范。 WebRTC开源项目向浏览器厂商提供相关功能的C++ API 以及代码实现，如音/视频捕获、音/视频处理引擎、网络传输协议、会话控制协议， 从而极大地减小项目开发的成本和风险。 其中，音频、视频处理引擎以及网络传输协议等模块是WebRTC架构新增的，以下将做进一步介绍。</p>
<p>音频处理引擎是从声卡到网络侧音频媒体处理链的总体框架，需要提供如设备控制、语音编码(iLIBC/iSAC/G.711/G.722/PCM16)、NetEQ、加密、声音文件、声音处理、声音输出、 音量控制、 音/视频同步、 网络传输与流控(RTP/ RTCP)等功能。</p>
<p>WebRTC 主要采用两种开源的语 音编码格式:iSAC (internet speech audio codec) 与 iLBC (internet low bitrate codec)，分别用于宽带与窄带语音编码。 iSAC 是一种用于 VoIP 及音频流的宽带或超宽带编码器， 由 Google 从 GIPS 公司获得并开源，使用 16 kHz 或 32 kHz 采样率， 支持 12~52 kbit/s 可变码率;iLBC 是一种专 为分组交换网络通信设计的窄带语音编/解码器，使用 8 kHz 采样率，帧长为 20 ms 时码率可控制为 13.33 kbit/s，帧长为 30 ms 时码率为 15.2 kbit/s。 其算法复杂度与 G.729a 相当， 但由于对分组丢失进行了特别处理， 在分组丢失率较高的网络环境下表现优异， 例如在分组丢失率为5%左右的网络环境下，可达到GSM网络的话音通话效果。</p>
<p>声音处理针对音频数据进行处理， 包括回声消除 (acoustic echo canceler， AEC)、 自动增益 (automatic gain control，AGC)、降噪处理等功能，用来提升声音质量。 NetEQ 模块集成了自适应抖动缓冲区及错误掩盖功能，可减少网 络抖动和分组丢失对话音质量的影响，从而在尽量低的时延下提供高品质的话音通话。 回声消除模块实现了基于软件实时去除由于放音被麦克风再次捕获所造成的声学回响。 降噪模块主要使用信号处理手段除去各种背景噪声， 如VoIP中常见的嘶嘶声或风扇噪声。</p>
<p>此外，WebRTC还有视频处理引擎，它主要负责摄像头到网络侧、网络侧到屏幕显 示的视频处理链。 视频编码部分提供视频设备控制、视频 编码、加密、图像增强等功能，WebRTC采用 VP8(I420)编 解码技术，本文暂时不做描述。</p>
<h4 id="234-58app的具体应用">2.3.4 58APP的具体应用</h4>
<p>APM模块集成WebRTC降噪功能</p>
<p>在58多媒体整体架构上选择把降噪模块单独解耦提取一个APM module，方便58视频编辑、58直播等需要降噪业务统一调用。对外暴露工具类AudioNoiseHelp方便业务接入。APM module的规划以后会接入更多的音频处理模块，现在已经接入降噪、增益模块。</p>
<p>由于58直播SDK支持音频采样率种类大于WebRTC支持的种类，因此需要对数据进行最优音频重采样处理。</p>
<p>由于WebRTC只能处理320byte长度正整数倍的数据，但是58直播的音频采集数据在不同手机、不同采样率上得到的音频数据长度是不固定的，需要对数据进行切分处理。录音采集数据如果是byte格式的，假如长度是4096，那么直接把4096数据传入到WebRTC_NS里处理会出现杂音出现，所以在交给WebRTC_NS模块之前需要用个缓冲区来处理下，一次最多可以传入(4096/320)*320=3840长度数据，并且在数据处理完毕之后还需要用另外一个缓冲区来保证处理之后的长度仍然是4096个。</p>
<p>经过调研对比，我们最终选用WebRTC方案，使用了其音频处理模块audio_processing。</p>
<p>详情请看<a href="https://mp.weixin.qq.com/s/0wEI_h6mRLAwjNHisOJc-Q">音频降噪在58直播中的研究与实现</a><br>
直播过程中录制音频时难免会有噪音产生，除了在硬件方面可以使用专业的直播工具之外，我们也可以在软件端通过对音频流进行处理达到<strong>降噪</strong>的目的。</p>
<h3 id="24-编解码">2.4 编解码</h3>
<p>刚刚采集到的原始音视频数据如果未经处理便直接上传的话，会有以下两个问题：</p>
<ul>
<li>原始数据庞大，直接传输会对服务端、客户端的网络传输产生很大的压力；</li>
<li>android手机型号繁杂，他们采集的音视频格式很有可能是不一样的，这可能导致某些直播无法在部分用户的手机播放。</li>
</ul>
<p>为了解决这两个问题，我们就需要在上传前对原始数据进行<strong>编码</strong>，拉取音视频数据时再进行<strong>解码</strong>。</p>
<h4 id="241-编码原理">2.4.1 编码原理</h4>
<p>同样的一段视频，为什么经过编码之后数据量会变小呢？核心原理就是去除冗余数据，把一组像素值简化为一种描述。主要是从这几个维度去处理：</p>
<ul>
<li>空间冗余：一帧图片的像素点在横向和纵向上大多都会有相关性，对于聚集的相近或相同像素点，可以采用描述的方式去替代它们，从而减少数据量。举个极端的例子，假设长为64的数组[fff, fff...fff]表示一张8*8的白图，我们可以用&quot;8,8,fff&quot;去代替，虽然表述最终都是一个意思，但数据量就会大幅下降；</li>
<li>时间冗余：连续的视频图像之间一般也会有很大的相关性，这里可以使用运动补偿算法去除掉这些冗余信息；</li>
<li>视觉冗余：人类视觉并不能捕捉到所有变化，对于无感知的像素变化可以过滤掉；</li>
<li>结构冗余：对于某些特定的图像区域，可以根据纹理推断出像素值的分布规律；</li>
<li>知识冗余：对于某些图像可以根据现有的经验找到其规律，从而根据经验推断出大量像素点；</li>
<li>信息熵冗余：一串数据并不全是有用的信息，对于附加数据可以简化；</li>
</ul>
<h4 id="242-原始格式">2.4.2 原始格式</h4>
<ul>
<li>视频：android端采集的原始数据是YUV格式，就像RGB格式分为RGB565、RGB555、RGB8888一样，YUV也分为很多种，比较常见的有NV21、YUV444、YUV422、YUV420等；视频采集时需要考虑图像格式、分辨率、采样率、帧率等参数；</li>
<li>音频：android端采集的原始数据是PCM格式，采集时需要设置采样率、采样数(即位宽)、声道等参数；考虑人耳的分辨能力，一般采用44.1kHz/16bit/双声道。</li>
</ul>
<h4 id="243-编码格式">2.4.3 编码格式</h4>
<p>编码格式有非常多，常见的有以下几类：</p>
<ul>
<li>视频：H.26X系列、MPEG系列；</li>
<li>音频：MP3、AAC、WMA、AMR、OGG、FLAC等。</li>
</ul>
<p>58直播选择视频格式是H.264，它有以下优点：</p>
<ol>
<li>具有较高的数据压缩比，同等图像质量下，H.264压缩后的数据量只有MPEG2的1/8，MPEG4的1/3；</li>
<li>视频画质更高，能够在低码率下提供高质量的视频图像；</li>
<li>提供错误恢复功能，提供了解决网络传输包丢失问题的工具；</li>
</ol>
<p>音频格式则是选择AAC，它在音质与压缩比方面做到了比较好的平衡，根据欧洲广播联盟在2003年的<a href="https://blog.csdn.net/leixiaohua1020/article/details/11730661">测评</a>,在码率较低的情况下，几种不同编码方案的音频的音质排序为：AAC+ &gt;  MP3PRO &gt; AAC &gt; RealAudio &gt; WMA &gt; MP3。</p>
<blockquote>
<p>另外，需要区分下<strong>文件封装格式</strong>和<strong>编码格式</strong>，封装格式包括AVI、MP4、TS、FLV、MKV、RMVB等。封装格式可以认为是一个容器，视频编码和音频编码通过muxer生成封装格式，例如我们最终就是生成了flv格式。</p>
</blockquote>
<h4 id="244-编码方式">2.4.4 编码方式</h4>
<p>选定编码格式后，我们还需要在两种编码方式中做选择：</p>
<ul>
<li>软编码：即通过软件方式进行编码，内部是使用CPU；</li>
<li>硬编码：即通过硬件编码，是利用手机硬件芯片GPU。</li>
</ul>
<p>它们的优缺点是互补的：</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
<th>使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>软编码</td>
<td>兼容性强，而且画面精细</td>
<td>速度稍慢，功耗高</td>
<td>第三方编码库</td>
</tr>
<tr>
<td>硬编码</td>
<td>速度快，功耗低</td>
<td>兼容性差，需要适配</td>
<td>系统API调用硬件模块</td>
</tr>
</tbody>
</table>
<p>综上所述，直播SDK采用的方案是这样：</p>
<table>
	<tr>
	    <th></th>
	    <th>音频</th>
	    <th>视频</th>  
	</tr >
	<tr >
	    <td>软编码</td>
	    <td>faac</td>
	    <td>open264</td>
	</tr>
	<tr>
	    <td>硬编码</td>
	    <td colspan="2" align="center">MediaCodec</td>
	</tr>
</table>
<p><em>注：faac是编码库，与之对应还有一个解码库faad。</em></p>
<p>对这一部分的细节我们公众号也有比较详细的介绍：<a href="https://mp.weixin.qq.com/s/UpAyMzfXgdQaOqCkuQ6VIw">Android音视频开发之MediaCodec编解码</a>，<a href="https://mp.weixin.qq.com/s/ck3fzTaLxaury1krEC55yg">短视频sdk编解码方案总结</a>，<a href="https://mp.weixin.qq.com/s/I6vulO1-ZSpD2b-Es2tQIQ">58技术沙龙第十三期-音视频技术实践</a></p>
<h4 id="245-推拉流协议">2.4.5 推拉流协议</h4>
<p>当完成音视频数据的本地处理后，我们需要把数据推送给服务器，目前<strong>推流协议</strong>主要有以下三种：</p>
<ol>
<li>RTMP：Real Time Messaging Protocol（实时消息传输协议），基于TCP连接，它是目前市面上最主流的流媒体传输协议，绝大多数直播产品均是使用此协议，它有以下特点：
<ul>
<li>协议简单，在各大平台上实现都比较容易；</li>
<li>CDN友好，主流CDN厂商都支持；</li>
<li>不支持浏览器推送；</li>
</ul>
</li>
<li>WebRTC：Web Real Time Communication（网页实时通信），基于UDP，在弱网情况下表现较好，主流浏览器支持较好。缺点是如果直接使用浏览器推流，长时间直播稳定性较差，并且CDN支持也较差。</li>
<li>基于UDP自行搭建：自行搭建的好处是自主性高，通过定制化的调优，可以达到比较好的优化效果；但是私有协议的弊端就是成本比较高，另外也不能支持主流CDN，需要自行搭建或者与CDN厂商定制。</li>
</ol>
<p><strong>拉流协议</strong>就比较多了，目前使用较多的主要有这四个：httpflv，rtmp，hls，dash。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">httpflv</th>
<th style="text-align:center">rtmp</th>
<th style="text-align:center">hls</th>
<th style="text-align:center">dash</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>传输方式</strong></td>
<td style="text-align:center">http长连接</td>
<td style="text-align:center">ftp流</td>
<td style="text-align:center">http短连接</td>
<td style="text-align:center">http短连接</td>
</tr>
<tr>
<td style="text-align:center"><strong>视频封装格式</strong></td>
<td style="text-align:center">flv</td>
<td style="text-align:center">flv</td>
<td style="text-align:center">m3u8,ts列表</td>
<td style="text-align:center">Mp4,3gp,webm等</td>
</tr>
<tr>
<td style="text-align:center"><strong>延时</strong></td>
<td style="text-align:center">低</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center"><strong>数据分段</strong></td>
<td style="text-align:center">连续流</td>
<td style="text-align:center">连续流</td>
<td style="text-align:center">切片文件</td>
<td style="text-align:center">切片文件</td>
</tr>
<tr>
<td style="text-align:center"><strong>Html5兼容</strong></td>
<td style="text-align:center">B站flv.js</td>
<td style="text-align:center">使用插件</td>
<td style="text-align:center">可解封包播放(hls.js)</td>
<td style="text-align:center">mp4或webm切片时可直接播放</td>
</tr>
<tr>
<td style="text-align:center"><strong>原理</strong></td>
<td style="text-align:center">请求无限大文件</td>
<td style="text-align:center">tcp数据流</td>
<td style="text-align:center">分段http请求切片</td>
<td style="text-align:center">分段http请求切片</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Bilibili开源库<a href="https://github.com/Bilibili/flv.js">flv.js</a>传送门，可以js+html实现flv的播放，无需flash。</p>
</blockquote>
<h3 id="25-cdn分发">2.5 CDN分发</h3>
<h4 id="251-概念">2.5.1 概念</h4>
<p>CDN即内容分发网络，使用CDN可以降低网络延迟，解决访问速度缓慢的问题。它的基本原理是将内容发布到遍布各地的大量CDN节点，后续用户访问时直接就近访问最优节点，这样就可以一定程度上避免网络拥堵、地域、运营商等因素带来的访问延迟问题，提高了用户体验。</p>
<p>使用CDN的直播分发过程如下图：</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/04/08/A7Nwr1UpLKCv5Zq.png" alt="CDN.png" loading="lazy"></figure>
<h4 id="252-cdn架构">2.5.2 CDN架构</h4>
<p>不同的CDN厂商架构各不相同，但主要组成部分有以下几个：</p>
<ol>
<li>源站：即内容来源，对于直播来说就是主播推流端；</li>
<li>缓存服务器：直接向用户提供访问服务，由一般大量服务器组成；</li>
<li>智能DNS：这是CDN技术的核心所在，它负责将访问指向到距离用户最近、负载最小的缓存服务器。当用户发起访问时，会首先从智能DNS获取距离最近的一台缓存服务器ip，如果访问数据已经存在在该缓存服务器上，则直接返回数据；如果不存在的话会再向相邻近的缓存服务器或者源站抓取；</li>
<li>客户端：即发起访问的用户，对于直播来说就是观众拉流端。</li>
</ol>
<h4 id="253-cdn缺点及限制">2.5.3 CDN缺点及限制</h4>
<ul>
<li>虽然可以提高网络稳定性，但是会提高数据初次访问的延迟，因为数据获取过程中间可能会经过多个节点的缓存；</li>
<li>并不是所有的直播协议都能很好的支持CDN，支持较好的协议主要有RTMP、HTTP-FLV、HLS等，WebRTC协议并不能支持ICE、STUN、TURN等传统CDN，需要自建CDN服务。</li>
</ul>
<p>对于直播业务来说直播稳定性要比延迟要重要的多，接入CDN还是很有必要的，58APP这里是使用了腾讯的CDN服务。</p>
<h4 id="254-长连接数据同步">2.5.4 长连接数据同步：</h4>
<p>网络IO模型根据是否阻塞是否异步有很多种变种，其中jdk提供的有以下三种：（这个不用介绍，直接从websocket框架入手）</p>
<ul>
<li>BIO(Blocking IO)，同步阻塞：一请求对应一线程，在io完成之前，线程会一直等待，效率较差；</li>
<li>NIO(Non-Blocking IO)，同步非阻塞：不阻塞等待，如果数据不能立即获取到时直接返回错误，需要内部添加轮询机制；</li>
<li>AIO(Asynchonized IO)，异步io：自jdk1.7版本升级而来，不阻塞，也无需轮询，数据成功获取时会通过消息回调方式通知调用方。</li>
</ul>
<p>这里我们采用了基于NIO开发的WebSocket框架, 效率满足需求且接入方便。</p>
<blockquote>
<p>其实我们平时使用的okhttp，其内部依赖的okio也是NIO模型。</p>
</blockquote>
<p>以上各模块完成后，主播端已经基本成型了。而观众端除了长连接之外实现一个支持对应格式的视频播放器即可，这里不做详细说明。</p>
<h3 id="26-最优的接入方式">2.6 最优的接入方式</h3>
<p>直播SDK将被分为多个模块（单一职责原则）：pusherRequest长连接数据同步，capture音视频采集，core/hardcodec/softcodec编解码，pusherwrapper音视频推流等。</p>
<p>其中部分模块设计如下：</p>
<h4 id="261-长连接数据同步-pusherrequest">2.6.1 长连接数据同步-pusherRequest</h4>
<p>SDK封装内部实现，仅向外提供WLiveRequestKit和MessageSessionListener两个主类，具体结构如下</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/03/25/VMWrlnOG5JmcoyH.png" alt="pusherrequest结构.png" loading="lazy"></figure>
<p>pusherRequest库遵循接口隔离的设计原则，对外（业务方）仅通过<code>new WLiveRequestKit(MessageSessionListener)</code>发生联系，对底层WebSocket设立两个中间层WSHelper和WSConnection进行包装。</p>
<p>这样可以保证业务方对sdk内部修改无感知，也可以降低sdk与底层实现的耦合程度，哪怕替换了WebSocket核心实现，也不会造成太大的改动。</p>
<h4 id="262-音视频推流-pusherwrapper">2.6.2 音视频推流-pusherWrapper</h4>
<p>SDK向外暴露PusherPresenter和IPusherView，其中PusherPresenter用于调用sdk内逻辑，IPusherView提供了大量生命周期回调以及sdk配置注入方法，具体结构如下：</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/03/25/OyR9sTcFntP2Sbf.png" alt="pusherwrapper结构.png" loading="lazy"></figure>
<p>可以看到，不同的模块分别交由不同的类去实现，对于不同的实现（比如软硬解码的选择）通过抽象注入的方式实现依赖倒置，这样可以较大限度的实现解耦，其中某一块发生变动时，不仅影响不到业务方，甚至sdk中也可以把影响范围控制到最小。</p>
<h2 id="3-部落直播">3. 部落直播</h2>
<p>基于上面对于直播的理解，那么在接入直播时，我们就可以更好地设计与实现我们的现有框架：</p>
<p>部落主要有三个部分：<strong>部落发布页</strong>、<strong>部落详情页</strong>、<strong>部落直播页</strong>；部落发布页面一部分是RN页面，发布的相册是我们提供的交互组件；部落详情页主要是我们维护的页面；部落直播是入TEG提供的SDK，也是本文主要介绍的内容；</p>
<blockquote>
<p>同时，我们也在撰写《关于部落你应该知道的一切》敬请期待</p>
</blockquote>
<p>咳咳，回归主题：部落直播主要分为主播端和观众端，具体的页面如下：</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/05/08/wtkJQop3Pz5vNFH.jpg" alt="tribelive.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2020/05/08/bysoq5pD4CinTuL.jpg" alt="tribeliveau.jpg" loading="lazy"></figure>
<p>部落直播分为主播端和观众端两个Activity，利用同一个LiveSurfaceFragment作为界面交互展示，通过它与LiveSurfacePresenter进行交互。整体使用MVP模式，类结构图如下：</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2020/05/08/vkc1A6QLsM3qJ2Y.png" alt="zhibo.png" loading="lazy"></figure>
<h3 id="31-直播数据的主要来源">3.1 直播数据的主要来源</h3>
<p>APP端即可以当做主播端也可以当做观众端，数据的主要来源有三个部分：跳转协议数据、详情页数据、TEG下发的推流数据协议；</p>
<p>它们分别充当不同的功能：</p>
<ul>
<li>当数据消息必须要实时展示给观众时，使用跳转协议带过来，比如，是否需要美颜、旋转摄像头、礼物等。跳转协议通常是由FE生成，由wbmain://开头；</li>
<li>当数据消息是个性化时，必须用户的头像、昵称数据等，通常是由Server来下发。</li>
<li>当数据是在直播端进行动态变化时，比如公告、弹幕、禁言，用户聊天数据，这些都是由TEG将数据封装好消息流推送过来；</li>
</ul>
<h3 id="32-直播的四大功能区">3.2 直播的四大功能区</h3>
<p>顶部功能区，右侧功能区，弹幕区，底部功能区。</p>
<ul>
<li>顶部功能区主要包括：头像展示区、用户列表区、公告栏等；</li>
<li>右侧功能区：美颜、摄像头翻转、红包；</li>
<li>弹幕：可以展示公告、用户评论、欢迎条、引导关注等逻辑，并可以侧滑消失；</li>
<li>底部功能区包括：发言栏、红包、分享、礼物、点赞；</li>
<li>此外，针对安居客推流涉及到横屏推送，还有在观众端实现全屏双击点赞功能；</li>
</ul>
<h4 id="321-顶部功能区">3.2.1 顶部功能区</h4>
<h5 id="3211-头像部分">3.2.1.1 头像部分</h5>
<p>头像部分数据由跳转协议传递过来：解析其中&quot;jump_data&quot;部分，并封装成LiveRecordBean在LiveSurfacePresenter中使用，最后调用mView.refreshAnchorInfo方法更新头像、昵称、简介、黄蓝V等数据；</p>
<pre><code>mView.refreshAnchorInfo(
                    mRecordBean.displayInfo.thumbnailImgUrl,
                   formatAnchorInfoWord(mRecordBean.displayInfo.nickname),
                    formatAnchorInfoWord(mRecordBean.displayInfo.introduction),
                    mRecordBean.displayInfo.kol
            );
</code></pre>
<h5 id="3212-用户列表区">3.2.1.2 用户列表区</h5>
<p>用户进入直播间后，会接收到推流数据&quot;MSG_INIT_ROOM_SUCCESS = 1011&quot;，这个时候获取getJoinUserList()得到推流的用户列表</p>
<pre><code>for (int i = joinSize - 1; i &gt;= 0; i--) {
                UserInfo rf = roomInfo.getJoinUserList().get(i);
                try {
                    String indexId = rf.getId();
                    // 主播，不加入列表
                    if (mLiveUserId.equals(indexId)) {
                        continue;
                    } else if(audienceSelfBean == null &amp;&amp; !mIsLivePusher) {
                        // 缓存audienceSelfBean
                        if (audienceSelfId.equals(indexId)) {
                            audienceSelfBean = new LiveRoomInfoBean(rf);
                        }
                    }

                    // 检查列表中是否已经存在用户，存在的话移除掉，并在列表顶端加入新的用户
                    int index = -1;
                    if (mJoinList.size() &gt; 0) {
                        int size = mJoinList.size();
                        for (int j = 0; j &lt; size; j++) {
                            LiveRoomInfoBean bean = mJoinList.get(j);
                            if (bean.info.getId().equals(rf.getId())) {
                                index = j;
                                break;
                            }
                        }
                        if (index &gt;= 0) {
                            // 移除原先存在的用户
                            mJoinList.remove(index);
                        }
                    }

                    // 把新用户加入列表顶端
                    mJoinList.add(0, new LiveRoomInfoBean(rf));
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
</code></pre>
<p>此时，还需要注意有用户退出时，要把用户列表中的数据进行清空；</p>
<pre><code>void removeExitWatchersFromJoinList(RoomInfo roomInfo) {
        if (roomInfo.getExitUserList() != null &amp;&amp; mJoinList.size() &gt; 0) {
            synchronized (lock) {
                for (UserInfo rf : roomInfo.getExitUserList()) {
                    Iterator&lt;LiveRoomInfoBean&gt; iterator = mJoinList.iterator();
                    while (iterator.hasNext()) {
                        LiveRoomInfoBean bean = iterator.next();
                        if (bean.info.getId().equals(rf.getId())) {
                            iterator.remove();
                            break;
                        }
                    }
                }
            }
        }
    }
</code></pre>
<p>以及，网络断开再恢复时，用户列表的刷新；</p>
<h4 id="322-右侧功能区">3.2.2 右侧功能区</h4>
<ul>
<li>
<p>右侧功能区在主播端主要包含美颜、翻转、镜像；</p>
</li>
<li>
<p>观众端主要包含红包功能；</p>
</li>
</ul>
<p>1.观众端配置一些可以发红包的用户id，在进入详情页之后可以向Server发起请求，判断是否可以发红包，此时会跳转到支付SDK提供H5页面，进入红包的发送功能；</p>
<p>2.红包发送成功后，客户端会接收到10007的推流消息，并且弹出抢红包弹窗，弹窗20秒后自动关闭， 并且常驻在右上方，直到用户进行抢操作；</p>
<pre><code>public static class LiveRedPacket {
        public static final int REDPACKET_HAD_GOT = 0; //已经抢过
        public static final int REDPACKET_GETTING = 1; //抢到红包弹窗
        public static final int REDPACKET_GET_NOT = -1; //未抢到红包弹窗
        public static final int REDPACKET_FOCUSE_NOT = -2; //未关注弹窗
        public static final int REDPACKET_INVALIDATE = -3; //红包失效
        public static final int MESSAGE_REDPACKET = 10007;
    }
</code></pre>
<p>3.某用户后进入直播间，这时已经接受不到当时发红包的推流消息，所以通过详情页返回的数据判断是否有红包，有的话则弹出抢红包弹窗；</p>
<p>4.用户进行抢红包操作后，会有抢到、未抢到、未关注、红包失效等各种状态码，客户端根据状态码进行进一步操作；</p>
<ul>
<li>
<p>美颜使用的是TEG中SDK提供的功能，最终是调用了OpenGL中的shader。美颜由详情页数据“beauty”字段来控制，1是关，0是开启；默认是开启；</p>
</li>
<li>
<p>翻转和镜像都很简单，就是调用了相机的API；</p>
</li>
</ul>
<h4 id="323-弹幕区">3.2.3 弹幕区</h4>
<p>直播的大部分消息都是通过推流过来的，弹幕也不例外。通过实现TEG提供的接口“WLiveRequestKit.MessageSessionListener”，即可以在重写的onMessageReceived的方法中获取到对应的推流消息；</p>
<p>弹幕会根据推流的消息来决定弹出某些引导、策略性话术，比如公告、引导关注、引导评论、其他用户发来的评论消息，当然还包括删除消息，还有未读消息数展示等策略；</p>
<pre><code>public static class LiveComment implements Serializable {
        public int interval;//用户发送弹幕间隔时间
        public String intervalToast;
        public String notice;//房间公告
        public SubscribeGuide subscribeGuide;
        public CommentGuide commentGuide;
        public Welcome welcome;
    }
</code></pre>
<p>比如，引导评论是每隔4条（Server端来控制&quot;liveComment.welcome.interval &quot;）发送一次；引导关注也是由server下发，在下发多少条评论之后，展示一条引导关注；还有当其他用户进入直播间之后，可以展示欢迎xxx进入直播间等字样；</p>
<p>最后，直播间弹幕外层包裹了TribeSwipeBackLayout用于用户在弹幕区域的展示状态，解决了滑动冲突，并且可以实现弹幕支持手势的左右滑动；</p>
<h4 id="324-底部功能区">3.2.4 底部功能区</h4>
<p>底部功能区包括底部评论区、分享、点赞；</p>
<ul>
<li>
<p>底部评论区<br>
底部评论区，主要使用部落详情页中的自定义键盘，并且传入表情符号，其中一个难点在于针对一加手机的适配问题。</p>
</li>
<li>
<p>分享组件<br>
分享主要调用的是我们自己的分享组件；通过跳转协议传进来的需要被分享的形式内容；</p>
</li>
<li>
<p>点赞<br>
点赞功能主要是长按点赞和单击点赞，使用贝塞尔曲线完成点赞内容动态上升；它主要是接收推流消息LivePusherListener中onMessageReceived里面LiveConstant.SOCKET_MESSAGE_TYPE_LIKE = 5 ，收到消息之后就会进行更新；</p>
</li>
</ul>
<h2 id="4-直播优化的各种思考">4. 直播优化的各种思考</h2>
<p>在梳理了代码逻辑结构之后和实际的开发过程中，发现从接入逻辑、设计层面、代码层面都有很多值得优化的地方。</p>
<h3 id="41-代码层面的优化">4.1 代码层面的优化：</h3>
<p>随着业务逻辑的扩充，P层现在已经越来越大，维护成本也会随之增加，主要包括以下几个方面：</p>
<h4 id="411-p层任务过于繁重">4.1.1 P层任务过于繁重</h4>
<p>现阶段是一个Presenter管理整个直播端和观众端，交互和数据全部在一个P层里面完成；</p>
<p>拆分思路：整体页面逻辑严格按照功能区来划分，利用组合模式，按照功能区解耦，如果是组件和组件之间的通信可以使用父组件的形式进行交互；如果是数据传递，可以利用EventBus来传递；</p>
<h4 id="412-公共数据从p层抽离">4.1.2 公共数据从P层抽离</h4>
<p>问题：现在数据层主要来源有三个，跳转协议、推流、详情页获取，获取之后它们都保存在P层里面，并直接进行转发，这样会导致当跳转协议、推流、详情页中如果有数据公用时，会发生数据同步困难的问题；</p>
<p>解决方案：在上层抽取成一个TribeSession类，用于专门存放跳转协议、推流、详情页数据三个Bean，需要同步时，只需要在获取之后进行一次同步即可，这样可以收敛逻辑；</p>
<h4 id="413-整合断网逻辑抽取成公共组件扩展p层">4.1.3 整合断网逻辑，抽取成公共组件，扩展P层；</h4>
<p>断网等控制逻辑，还在V层里面，这样的设计非常不友好，还是要抽离的干净一些；</p>
<p>解决方法：V层的逻辑数据都要进行抽离；</p>
<h3 id="42-直播用户体验优化">4.2 直播用户体验优化：</h3>
<h4 id="421-降低直播延迟">4.2.1 降低直播延迟</h4>
<ol>
<li>
<p>尝试开启CDN：CDN主要用来解决由于网络带宽小、用户访问量大、网点分布不均匀等导致用户访问网站速度慢的问题。通过在现有的网络中增加一层新的网络架构，将网站的内容发布到离用户最近的网络节点上，解决网络拥堵、访问延迟高的问题。</p>
</li>
<li>
<p>使用动态码率：主播端在推流过程中，如果上行带宽较小，可以适当降低分辨率和帧率，从而降低码率。</p>
</li>
<li>
<p>观看端降低画质：可以同时添加多种清晰度画质的支持，如果观看端网络状况不好，卡顿、丢帧现象比较严重，可以动态调整画质，接入较低的画质流。</p>
</li>
</ol>
<h4 id="422-直播暂停状态的处理">4.2.2 直播暂停状态的处理</h4>
<p>主播端暂停或切换到后台，如果不做处理直播画面会卡住，为了提高用户体验，可以设置一张占位图提示观众当前直播已暂停。</p>
<p>设置占位图时可以按当前推流设置的宽、高对图片进行压缩，最终转换成视频流推送出去，在使用时需要注意占位图片的分辨率以及图片质量，避免过度压缩导致图片模糊，影响体验。</p>
<h4 id="423-直播画面绿屏">4.2.3 直播画面绿屏</h4>
<p>这是因为部分机型（例如Oppo R7、乐视1S）推流的输入源为NV21格式，并不支持硬解码导致，对于特定机型我们可以采用强制软编码的方式去避免此错误。</p>
<h3 id="43-直播性能数据监控闭环">4.3 直播性能数据监控闭环</h3>
<p>问题：目前还没有监控部落直播的性能体系，虽然在TEG那边会上传一些用户的数据，但是这些数据如果不在我们这边，对于我们也没有参考价值；</p>
<p>解决方法：使用systrace + 插桩 &amp; MethodTraceMan等监控方式，对部落直播中的各个阶段进行监控；处理耗时问题并逐步进行优化；</p>
<h2 id="结语">结语</h2>
<p>直播技术发展到今天已经比较成熟，各类方案在技术社区均能找到，部分开源框架甚至可以做到半小时内快速搭建，实现简单的直播已经不再是难题。</p>
<p>随着5G时代的到来，网络门限变得越来越小，直播业务也会在各个行业内呈现百花齐放百家争鸣的状态。58在积极探索自己的模式，追求用户的极致体验，为直播贡献一份绵薄之力，愿我们“只争朝夕，不负韶华”。</p>
<blockquote>
<p>参考文章：</p>
<p>《Android音视频开发》</p>
<p>https://cloud.tencent.com/document/product/454/7937</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RecyclerView的适配]]></title>
        <id>https://Mozziehh.github.io/post/recyclerview-de-gua-pei/</id>
        <link href="https://Mozziehh.github.io/post/recyclerview-de-gua-pei/">
        </link>
        <updated>2020-05-20T08:24:01.000Z</updated>
        <summary type="html"><![CDATA[<p>适配</p>
]]></summary>
        <content type="html"><![CDATA[<p>适配</p>
<!-- more -->
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://Mozziehh.github.io/post-images/1589963077565.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gradle与插件的升级-3.5排坑之旅]]></title>
        <id>https://Mozziehh.github.io/post/gradle-yu-cha-jian-de-sheng-ji-541-pai-keng-zhi-lu/</id>
        <link href="https://Mozziehh.github.io/post/gradle-yu-cha-jian-de-sheng-ji-541-pai-keng-zhi-lu/">
        </link>
        <updated>2020-02-11T02:18:18.000Z</updated>
        <summary type="html"><![CDATA[<p>2020年来了，一年一度的升级活动又要如期展开了，项目里面的老东西也该改进改进了。随着项目越来越大，编译时间成为了我们的瓶颈，虽然改变工程结构等方式能够提升编译速度，但是升级Gradle其实是不二法门。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2020年来了，一年一度的升级活动又要如期展开了，项目里面的老东西也该改进改进了。随着项目越来越大，编译时间成为了我们的瓶颈，虽然改变工程结构等方式能够提升编译速度，但是升级Gradle其实是不二法门。</p>
<!-- more -->
<p>目前项目的状态：<br>
android studio : 3.4.2<br>
gradle : 4.10.1<br>
gradle插件：3.3.1<br>
首次执行编译时间（执行命令-&gt; ./gradlew assembleDebug）：9m 17s<br>
第二次执行编译时间： 6m 18s</p>
<p>以下是来自官网的数据：<br>
插件版本              所需的 Gradle 版本<br>
1.0.0 - 1.1.3        2.2.1 - 2.3<br>
1.2.0 - 1.3.1        2.2.1 - 2.9<br>
1.5.0                2.2.1 - 2.13<br>
2.0.0 - 2.1.2        2.10 - 2.13<br>
2.1.3 - 2.2.3        2.14.1+<br>
2.3.0+               3.3+<br>
3.0.0+               4.1+<br>
3.1.0+               4.4+<br>
3.2.0 - 3.2.1        4.6+<br>
3.3.0 - 3.3.2        4.10.1+<br>
3.4.0 - 3.4.1        5.1.1+<br>
3.5.0+               5.4.1-5.6.4</p>
<p>预计更新为：<br>
android studio : 3.5.0（必须）<br>
gradle : 5.4.1<br>
gradle插件：3.5.3<br>
SDK Build Tools： 28.0.3 +</p>
<p>优点：<br>
代码缩减（即摇树优化）：从应用及其库依赖项中检测并安全地移除未使用的类、字段、方法和属性（这使其成为了一个对于规避 64k 引用限制非常有用的工具）。例如，如果您仅使用某个库依赖项的少数几个 API，缩减功能可以识别应用“未”使用的库代码并仅从应用中移除这部分代码。如需了解详情，请转到介绍如何缩减代码的部分。<br>
资源缩减：从封装应用中移除不使用的资源，包括应用库依赖项中的不使用的资源。此功能可与代码缩减功能结合使用，这样一来，移除不使用的代码后，也可以安全地移除不再引用的所有资源。如需了解详情，请转到介绍如何缩减资源的部分。<br>
混淆处理：缩短类和成员的名称，从而减小 DEX 文件的大小。如需了解详情，请转到介绍如何对代码进行混淆处理的部分。<br>
优化：检查并重写代码，以进一步减小应用的 DEX 文件的大小。例如，如果 R8 检测到从未采用过给定 if/else 语句的 else {} 分支，则会移除 else {} 分支的代码。如需了解详情，请转到介绍代码优化的部分。<br>
默认情况下，在构建应用的发布版本时，R8 会自动执行上述编译时任务。不过，您也可以停用某些任务或通过 ProGuard 规则文件自定义 R8 的行为。 事实上，R8 支持所有现有 ProGuard 规则文件，因此您在更新 Android Gradle 插件以使用 R8 时，无需更改现有规则。</p>
<p>#影响范围<br>
根据下文的初步调研，这里给出影响范围，以备参考：<br>
##整体升级计划</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>是否影响到安居客</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android Studio</td>
<td>升级到3.5</td>
<td>系统运行状况、功能完善和错误修复，参考《Android Studio升级表》</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Gradle</td>
<td>升级5.4.1</td>
<td>优化语法，使用R8提升编译速度，参考《Gradle升级表》</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Gradle 插件</td>
<td>升级3.5.3</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>SDK Build Tools</td>
<td>28.0.3 +</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>JDK</td>
<td>1.8</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
<tr>
<td>Kotlin Gradle 插件</td>
<td>1.3.40</td>
<td>同上，配套使用</td>
<td>是，需要同步升级</td>
</tr>
</tbody>
</table>
<p>##Android Studio升级表</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>增量注释</td>
<td>数据绑定注释处理器支持增量注释处理</td>
<td>提高了增量构建的性能</td>
<td>暂时用不到</td>
</tr>
<tr>
<td>单元测试</td>
<td>可缓存的单元测试</td>
<td>提效</td>
<td>暂时用不到</td>
</tr>
<tr>
<td>推荐内存设置</td>
<td>手动分配RAM上限</td>
<td>提高性能</td>
<td>开发者根据需要自己设置</td>
</tr>
<tr>
<td>内存使用情况报告</td>
<td>提交内存使用报告</td>
<td>供goolge完成内存分析</td>
<td>开发者根据需要自己设置</td>
</tr>
<tr>
<td>Windows：防病毒文件 I/O 优化</td>
<td>防病毒检测</td>
<td>防止病毒侵害</td>
<td>无win，不用</td>
</tr>
<tr>
<td>Apply Changes</td>
<td>将代码和资源更改推送给正在运行的应用</td>
<td>无需重复构建</td>
<td>需要运行在Android 8.0及更高</td>
</tr>
<tr>
<td>Layout Editor</td>
<td>对布局可视化、管理和互动功能</td>
<td>ConstraintLayout构建布局时会更方便</td>
<td>升级即可使用</td>
</tr>
<tr>
<td>NDK 并排版本</td>
<td>同一计算机上可以使用不同版本的 NDK，甚至可以指定项目中每个模块应使用的 NDK 版本</td>
<td>并行构建</td>
<td>开发者可用</td>
</tr>
</tbody>
</table>
<p>##Gradle升级表</p>
<table>
<thead>
<tr>
<th>升级</th>
<th>具体内容</th>
<th>升级收益</th>
<th>是否影响到安居客</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认标签</td>
<td>不再需要enableFeaturePreview('IMPROVED_POM_SUPPORT')和enableFeaturePreview('STABLE_PUBLISHING')标志</td>
<td>自动配置</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>Java 9 &amp; JAXB</td>
<td>默认捆绑</td>
<td>自动配置</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>语法修改</td>
<td>publishing {}不支持延时操作</td>
<td>使用afterEvaluate {}</td>
<td>是，若有，则找到对应代码并删除</td>
</tr>
<tr>
<td>Java库分发插件</td>
<td>基于Java库插件而不是Java插件</td>
<td>使其行为略有不同</td>
<td>是，若有，则请确保在升级后检查内部版本是否符合预期</td>
</tr>
<tr>
<td>Java库分发插件</td>
<td>基于Java库插件而不是Java插件</td>
<td>使其行为略有不同</td>
<td>是，若有，则请确保在升级后检查内部版本是否符合预期</td>
</tr>
<tr>
<td>属性修改</td>
<td>CheckstyleReport和FindBugsReport的html属性现在返回一个CustomizableHtmlReport实例</td>
<td>更易于从静态类型的语言（如Java和Kotlin）进行配置</td>
<td>是，若有，则请确保在升级后检查是否符合预期</td>
</tr>
<tr>
<td>语法修改</td>
<td>&lt;&lt;对于任务定义不再有效</td>
<td>不能使用语法task myTask &lt;&lt; { … } ，改用Task.doLast（）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>域对象名称使用规范</td>
<td>不能使用<space> / \ : &lt; &gt; &quot; ? * .作为项目和任务名称，也不能将.用作开头或结尾字符</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-Dtest.single</td>
<td>命令行删除，使用test filtering替代</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-Dtest.debug</td>
<td>命令行删除，使用--debug-jvm替代</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>-u / --no-search-upward</td>
<td>命令行删除，使用settings.gradle文件</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>--recompile-scripts</td>
<td>命令行删除</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>DirectoryBuildCache.setTargetSizeInMB(long)方法已被删除</td>
<td>改成DirectoryBuildCache.removeUnusedEntriesAfterDays</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>语法修改</td>
<td>.org.gradle.readLoggingConfigFile系统属性不再执行任何操作</td>
<td>使用java.util.logging设置</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>不再可以使用as关键字或asType()方法将FileCollection对象转换为其他类型</td>
<td>无</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>不能再传递null作为CopySpec.from（Object，Action）的配置</td>
<td>无</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>CopySpec.duplicatesStrategy不再可以为空</td>
<td>默认值的方法. 请改用DuplicatesStrategy.INHERIT</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>FileCollection.stopExecutionIfEmpty()方法已被删除</td>
<td>在FileCollection任务属性上使用@SkipWhenEmpty批注</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>FileCollection.add()方法已删除</td>
<td>使用Project.files（）和Project.fileTree（）创建可配置的文件集合/文件树，并通过ConfigurableFileCollection.from（）将其添加到它们</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>SimpleFileCollection已被删除</td>
<td>改为使用Project.files（Object ...）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>文件操作</td>
<td>无法扩展AbstractFileCollection改用Project.files（）方法</td>
<td>改为使用getBuildDependencies()方法</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>CompileOptions.bootClasspath属性已被删除</td>
<td>请改用CompileOptions.bootstrapClasspath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>无法将-source-path用作通用编译器参数</td>
<td>CompileOptions.sourcepath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>无法将-processorpath用作通用编译器参数</td>
<td>应改用CompileOptions.annotationProcessorPath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>不再自动应用编译类路径上的注释处理器</td>
<td>应改用CompileOptions.annotationProcessorPath</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>testClassesDir属性已从&quot; 测试&quot;任务中删除</td>
<td>改用testClassesDirs</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>从JDepend任务和SourceSetOutput中都删除了classesDir属性</td>
<td>改用JDepend.classesDirs和SourceSetOutput.classesDirs属性</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>JavaBasePlugin.configureForSourceSet()方法已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Java构建</td>
<td>不可以创建自己的JavaPluginConvention ， ApplicationPluginConvention ， WarPluginConvention ， EarPluginConvention ， BasePluginConvention和ProjectReportsPluginConvention实例</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了以下属性</td>
<td>使用ObjectFactory.property（）创建Property实例</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了内部的@Option和@OptionValues注释</td>
<td>改用公共@Option和@OptionValues</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了Task.deleteAllActions()方法</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了Task.dependsOnTaskDidWork()方法</td>
<td>改用声明的输入和输出</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Tasks &amp; properties</td>
<td>删除了TaskInternal的以下属性和方法</td>
<td>重用的实用程序方法或Worker API代替直接执行任务</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Kotlin DSL</td>
<td>Artifact配置访问器现在具有NamedDomainObjectProvider<Configuration>类型，而不是Configuration</td>
<td>请参阅Gradle Kotlin DSL发行说明</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>Kotlin DSL</td>
<td>PluginAware.apply<T>(to)重命名为PluginAware.applyTo<T>(target)</td>
<td>请参阅Gradle Kotlin DSL发行说明</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>ConfigurableReport.setDestination(Object)方法已被删除</td>
<td>改用ConfigurableReport.setDestination（File）</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>Signature.setFile(File)方法已被删除，只读的Signature.toSignArtifact属性已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>@DeferredConfigurable批注已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>方法isDeferredConfigurable()已从ExtensionSchema中删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>.IdeaPlugin.performPostEvaluationActions()和EclipsePlugin.performPostEvaluationActions()已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>BroadcastingCollectionEventRegister.getAddAction()方法已被删除</td>
<td></td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>内部的org.gradle.util软件包默认不再导入</td>
<td>显式导入</td>
<td>是，若有，则需要修改</td>
</tr>
<tr>
<td>其他</td>
<td>Tooling API不能再使用Gradle 2.6以下的Gradle版本连接到构建</td>
<td>升级到3.0</td>
<td>是，若有，则需要修改，可能也涉及到QA的改动</td>
</tr>
</tbody>
</table>
<!-- more -->
<!-- more -->
<p>接下来，开撸：</p>
<p>#升级Android Studio</p>
<p>首先，要升级一下Android Studio：Android Studio -&gt; check for updates...<br>
点击之后就会出现让你升级的按钮，耐心的等一会：<br>
<img src="https://Mozziehh.github.io/post-images/1581424536552.png" alt="" loading="lazy"></p>
<p>升级的过程中会报错，如果不继续就无法继续升级，好吧：<br>
<img src="https://Mozziehh.github.io/post-images/1581424635886.png" alt="" loading="lazy"></p>
<p>升级完成之后效果：<br>
<img src="https://Mozziehh.github.io/post-images/1581424849282.png" alt="" loading="lazy"></p>
<!-- more -->
<p>重启之后就是漫长的等待，没事，它等待它的，我们看看这Android Studio 3.5都干了啥：</p>
<p>Android Gradle 插件 3.5.0 和 Android Studio 3.5 是一个重大版本，同时也是 Project Marble 计划的成果，该计划主要围绕 Android 开发者工具的三大核心领域进行改进，分别是系统运行状况、功能完善和错误修复。值得注意的是，本次更新的重中之重是提高项目的构建速度。</p>
<p>要详细了解这些更新以及其他 Project Marble 更新，请参阅 Android 开发者博文或以下几个部分的内容。</p>
<p>此版本的 Android 插件需要使用以下工具：</p>
<p>Gradle 5.4.1 或更高版本。要了解详情，请阅读有关更新 Gradle 的部分。</p>
<p>3.5.3（2019 年 12 月）<br>
本次要更新对 Android Studio 3.5.3 构成补充，修复了各种错误并做出了多项性能改进。<br>
3.5.2（2019 年 11 月）<br>
本次要更新对 Android Studio 3.5.2 构成补充，修复了各种错误并做出了多项性能改进。要查看重要问题修复列表，请阅读版本更新博客上的相关博文。<br>
3.5.1（2019 年 10 月）<br>
本次要更新对 Android Studio 3.5.1 构成补充，修复了各种错误并做出了多项性能改进。要查看重要问题修复列表，请阅读版本更新博客上的相关博文。</p>
<p>##增量注释处理<br>
如果您在 gradle.properties 文件中设置了 android.databinding.incremental=true，数据绑定注释处理器支持增量注释处理。这项优化提高了增量构建的性能。要查看经过优化的注释处理器的完整列表，请参阅增量注释处理器表格。</p>
<p>此外，KAPT 1.3.30 及更高版本也支持增量注释处理器，您可以通过在 gradle.properties 文件中添加 kapt.incremental.apt=true 来启用此支持。</p>
<p>##可缓存的单元测试<br>
通过将 includeAndroidResources 设置为 true，您可以允许单元测试使用 Android 资源、资产和清单，此时 Android Gradle 插件会生成包含绝对路径的测试配置文件，绝对路径会打破缓存可再定位性。您可以指示插件使用相对路径生成测试配置，以便通过在 gradle.properties 文件中添加以下内容来完全缓存 AndroidUnitTest 任务：<br>
android.testConfig.useRelativePath = true</p>
<p>##已知问题<br>
在使用 Kotlin Gradle 插件 1.3.31 或更早版本时，您可能会在构建或同步项目时看到以下警告：</p>
<p>WARNING: API 'variant.getPackageLibrary()' is obsolete and has been replaced<br>
with 'variant.getPackageLibraryProvider()'.</p>
<p>要解决此问题，请将插件升级到 1.3.40 或更高版本。</p>
<p>##推荐内存设置</p>
<p>现在，如果 Android Studio 检测到您可以通过增加操作系统应该为 Android Studio 进程（例如核心 IDE、Gradle 守护进程和 Kotlin 守护进程）分配的 RAM 上限来提高性能，它会通知您。您可以通过点击通知中的操作链接来接受推荐设置，或者，您可以通过以下方式手动调整这些设置：依次选择 File &gt; Settings（或者，在 macOS 上依次选择 Android Studio &gt; Preferences），然后在 Appearance &amp; Behavior &gt; System Settings 下找到 Memory Settings 部分。<br>
<img src="https://Mozziehh.github.io/post-images/1581425138056.png" alt="" loading="lazy"></p>
<p>##内存使用情况报告<br>
Android Studio 中的内存问题有时难以重现和报告。为了解决此问题，您可以在 Android Studio 中从菜单栏依次点击 Help &gt; Analyze Memory Usage，生成内存使用情况报告。执行此操作后，Android Studio 会在本地清理掉数据中的个人信息，然后询问您是否希望将数据发送给 Android Studio 团队以帮助识别内存问题的来源。<br>
PS：不过这个功能对开发而言好像没啥用。</p>
<p>##Windows：防病毒文件 I/O 优化<br>
Android Studio 现在会自动检查某些项目目录是否已从实时防病毒扫描中排除。当能够进行调整以提高构建性能时，Android Studio 会通知您并提供有关如何优化防病毒配置的说明。<br>
PS：Mac表示没有此类困扰</p>
<p>##Apply Changes：<br>
借助 Apply Changes，您可以将代码和资源更改推送给正在运行的应用，而无需重启应用（在某些情况下，甚至无需重启当前的 Activity）。Apply Changes 实现了一种全新的方法来保持应用的状态。与重写 APK 字节码的 Instant Run 不同，Apply Changes 会利用 Android 8.0（API 级别 26）或更高版本中支持的运行时插桩，实时地重新定义类。<br>
<img src="https://Mozziehh.github.io/post-images/1581425288637.png" alt="" loading="lazy"></p>
<p>##Layout Editor<br>
Android Studio 3.5 对布局可视化、管理和互动功能进行了多项改进。</p>
<p>使用 ConstraintLayout 时，Attributes 面板中新的 Constraints 部分会列出所选界面组件的约束关系。您可以从设计图面或约束列表中选择一个约束条件，突出显示这两个区域中的约束条件。</p>
<p><img src="https://Mozziehh.github.io/post-images/1581425465223.png" alt="" loading="lazy"><br>
同样，您现在可以选择某个约束条件并按 Delete 键，删除约束条件。您还可以按住 Control 键（在 macOS 上，按住 Command）并点击约束条件定位点来删除约束条件。请注意，当您按住 Control 或 Command 键并将鼠标悬停在定位点上时，任何关联的约束条件都会变成红色，表示您可以点击以将其删除。</p>
<p>选择视图后，您可以点击 Attributes 面板的 Constraint Widget 部分的任何一个 + 图标来创建约束条件，如下图所示。当您创建新的约束条件时，Layout Editor 现在会选择并突出显示该约束条件，为您刚刚添加的约束条件提供即时视觉反馈。<br>
<img src="https://Mozziehh.github.io/post-images/1581425489275.png" alt="" loading="lazy"></p>
<p>##NDK 并排版本<br>
现在，您可以并排使用 NDK 的多个版本。此功能可让您更灵活地配置项目，例如，如果项目在同一计算机上使用了不同版本的 NDK。</p>
<p>如果您的项目使用 Android Gradle 插件 3.5.0 或更高版本，您还可以指定项目中每个模块应使用的 NDK 版本。您可以使用此功能来创建可重现的构建版本，并缓解 NDK 版本与 Android Gradle 插件之间的不兼容性。</p>
<p>##从4.10更新过来的同学看这里<br>
接下来我们来说说，Gradle升级的好处：<br>
如果您尚未使用4.10版本，请跳至适用于当前Gradle版本的部分，然后逐步升级，直至到达此处. 然后，从Gradle 4.10移至5.0时应用这些更改.</p>
<p>1.不再需要enableFeaturePreview('IMPROVED_POM_SUPPORT')和enableFeaturePreview('STABLE_PUBLISHING')标志. 现在默认情况下启用了这些功能.</p>
<p>2.Gradle现在捆绑了Java 9及更高版本的JAXB . 您可以从org.gradle.jvmargs删除--add-modules java.xml.bind选项（如果已设置）.</p>
<p>##其他可能会出现问题的点</p>
<p>1.对publishing {}块的评估不再推迟到需要时才执行，但其行为与其他任何块一样. 如果您需要推迟评估，请使用afterEvaluate {} .</p>
<p>2.Javadoc和Groovydoc任务现在在执行之前删除了文档的目标目录. 已添加它以从上一次任务执行中删除过时的输出文件.</p>
<p>3.Java库分发插件现在基于Java库插件而不是Java插件 .<br>
在应用Java插件时，其行为略有不同（例如，它添加了api配置）. 因此，请确保在升级后检查内部版本是否符合预期.</p>
<p>4.CheckstyleReport和FindBugsReport的html属性现在返回一个CustomizableHtmlReport实例，该实例更易于从静态类型的语言（如Java和Kotlin）进行配置.</p>
<p>5.以下重大更改将在Gradle 4.10中作为弃用警告显示：</p>
<p>##General<br>
&lt;&lt;对于任务定义不再有效. 换句话说，您不能使用语法task myTask &lt;&lt; { … } .<br>
改用Task.doLast（）方法，如下所示：<br>
task myTask {<br>
doLast {<br>
...<br>
}<br>
}<br>
您不能再在域对象名称中使用以下任何字符，例如项目和任务名称：<space> / \ : &lt; &gt; &quot; ? * | .您也不应将.用作开头或结尾字符.</p>
<p>##Running Gradle &amp; build environment<br>
如前所述，Gradle不能再在Java 7上运行.但是，您仍然可以使用派生的编译和测试来构建和测试Java 6及更高版本的软件.</p>
<p>1.The -Dtest.single command-line option has been removed — use test filtering instead.</p>
<p>2.-Dtest.debug命令行选项已删除-使用--debug-jvm选项代替.</p>
<p>3.-u / --no-search-upward命令行选项已被删除-确保所有构建均具有settings.gradle文件.</p>
<p>4.--recompile-scripts命令行选项已删除.</p>
<p>5.除非嵌套的构建具有settings.gradle文件，否则您不能再将Gradle嵌套在另一个Gradle构建的子目录中.</p>
<p>6.DirectoryBuildCache.setTargetSizeInMB(long)方法已被删除-改用DirectoryBuildCache.removeUnusedEntriesAfterDays .</p>
<p>7.org.gradle.readLoggingConfigFile系统属性不再执行任何操作-更新受影响的测试以使用您的java.util.logging设置.</p>
<h2 id="文件操作">文件操作</h2>
<p>1.您不再可以使用as关键字或asType()方法将FileCollection对象转换为其他类型.</p>
<p>2.您不能再传递null作为CopySpec.from（Object，Action）的配置操作.</p>
<p>3.为了与Kotlin DSL更好地兼容， CopySpec.duplicatesStrategy不再可以为空. 属性设置器不再接受null作为将属性重置为其默认值的方法. 请改用DuplicatesStrategy.INHERIT .</p>
<p>4.FileCollection.stopExecutionIfEmpty()方法已被删除-在FileCollection任务属性上使用@SkipWhenEmpty批注.</p>
<p>FileCollection.add()方法已删除-使用Project.files（）和Project.fileTree（）创建可配置的文件集合/文件树，并通过ConfigurableFileCollection.from（）将其添加到它们.</p>
<p>5.SimpleFileCollection已被删除-改为使用Project.files（Object ...） .</p>
<p>6.没有您自己的类扩展AbstractFileCollection改用Project.files（）方法. 此问题可能表现为缺少的getBuildDependencies()方法.</p>
<p>##Java构建<br>
1.CompileOptions.bootClasspath属性已被删除，请改用CompileOptions.bootstrapClasspath .</p>
<p>2.您不能再将-source-path用作通用编译器参数，而应改用CompileOptions.sourcepath .</p>
<p>3.您不能再将-processorpath用作通用编译器参数，而应改用CompileOptions.annotationProcessorPath .</p>
<p>4.Gradle将不再自动应用编译类路径上的注释处理器，而应改用CompileOptions.annotationProcessorPath .</p>
<p>5.testClassesDir属性已从&quot; 测试&quot;任务中删除-改用testClassesDirs .</p>
<p>6.从JDepend任务和SourceSetOutput中都删除了classesDir属性. 请改用JDepend.classesDirs和SourceSetOutput.classesDirs属性.</p>
<p>7.JavaLibrary(PublishArtifact, DependencySet)构造函数— Shadow Plugin使用了该构造函数，因此请确保至少升级到该插件的2.x版本.</p>
<p>8.JavaBasePlugin.configureForSourceSet()方法已被删除.</p>
<p>9.您不再可以创建自己的JavaPluginConvention ， ApplicationPluginConvention ， WarPluginConvention ， EarPluginConvention ， BasePluginConvention和ProjectReportsPluginConvention实例.</p>
<p>10.Maven插件用于发布过时的Maven 2元数据格式. 它已更改，现在将发布Maven 3元数据，就像Maven Publish插件一样.<br>
随着Maven 2支持的删除，配置唯一快照行为的方法也已删除. Maven 3仅支持唯一的快照，因此我们决定删除它们.</p>
<p>##Tasks &amp; properties<br>
1.删除了以下与惰性属性相关的旧类和方法-使用ObjectFactory.property（）创建Property实例：</p>
<p>PropertyState<br>
DirectoryVar<br>
RegularFileVar<br>
ProjectLayout.newDirectoryVar()<br>
ProjectLayout.newFileVar()<br>
Project.property(Class)<br>
Script.property(Class)<br>
ProviderFactory.property(Class)<br>
使用任务配置避免 API配置和注册的任务对可以从配置操作中调用的其他方法有更多限制.</p>
<p>2.内部的@Option和@OptionValues注释（软件包org.gradle.api.internal.tasks.options ）已被删除. 请改用公共@Option和@OptionValues批注.</p>
<p>3.Task.deleteAllActions()方法已被删除，无法替代.</p>
<p>4.Task.dependsOnTaskDidWork()方法已被删除-改用声明的输入和输出 .</p>
<p>5.已删除TaskInternal的以下属性和方法-使用任务依赖项，任务规则，可重用的实用程序方法或Worker API代替直接执行任务.<br>
execute()<br>
executer<br>
getValidators()<br>
addValidator()<br>
TaskInputs.file（Object）方法不能再使用可解析为单个常规文件以外的任何参数的参数来调用.<br>
TaskInputs.dir（Object）方法不能再使用解析为单个目录以外的任何参数的参数来调用.<br>
您不再可以通过TaskInputs和TaskOutputs注册无效的输入和输出.<br>
TaskDestroyables.file()和TaskDestroyables.files()方法已被删除-改用TaskDestroyables.register（） .<br>
SimpleWorkResult已被删除-使用WorkResult.didWork .<br>
现在，覆盖4.8中弃用的内置任务会产生错误.<br>
尝试替换内置任务将产生类似于以下内容的错误：</p>
<blockquote>
<p>Cannot add task 'wrapper' as a task with that name already exists.<br>
Scala &amp; Play<br>
不再支持Play 2.2-请升级您使用的Play版本.<br>
ScalaDocOptions.styleSheet属性已被删除-Scala 2.11.8及更高版本中的Scaladoc Ant任务不再支持此属性.</p>
</blockquote>
<p>##Kotlin DSL<br>
Artifact配置访问器现在具有NamedDomainObjectProvider<Configuration>类型，而不是Configuration<br>
PluginAware.apply<T>(to)重命名为PluginAware.applyTo<T>(target) .<br>
两项更改都可能导致脚本编译错误. 请参阅Gradle Kotlin DSL发行说明，以获取更多信息以及如何修复因上述更改而损坏的构建.</p>
<p>##Miscellaneous<br>
1.ConfigurableReport.setDestination(Object)方法已被删除-改用ConfigurableReport.setDestination（File） .</p>
<p>2.Signature.setFile(File)方法已被删除-Gradle不支持更改生成的签名的输出文件.<br>
只读的Signature.toSignArtifact属性已被删除-永远不应成为公共API的一部分.</p>
<p>3.@DeferredConfigurable批注已被删除.</p>
<p>4.方法isDeferredConfigurable()已从ExtensionSchema中删除.</p>
<p>5.IdeaPlugin.performPostEvaluationActions()和EclipsePlugin.performPostEvaluationActions()已被删除.</p>
<p>6.The `BroadcastingCollectionEventRegister.getAddAction()方法已被删除，无法替代.</p>
<p>7.内部的org.gradle.util软件包默认不再导入.<br>
理想情况下，您不应该使用此程序包中的类，但是，作为一种快速解决方案，您可以将显式导入添加到这些类的构建脚本中.</p>
<p>8.The gradlePluginPortal() repository no longer looks for JARs without a POM by default.</p>
<p>9.Tooling API不能再使用Gradle 2.6以下的Gradle版本连接到构建. 通过TestKit运行的构建也是如此.</p>
<p>10.Gradle 5.0需要最低版本的Tooling API客户端版本3.0. 较旧的客户端库无法再使用Gradle 5.0运行构建.</p>
<p>11.IdeaModule Tooling API模型元素包含用于检索资源和测试资源的方法，因此这些元素已从IdeaModule.getSourceDirs()和IdeaModule.getTestSourceDirs()的结果中删除.<br>
In previous Gradle versions, the source field in SourceTask was accessible from subclasses. This is not the case anymore as the source field is now declared as private.</p>
<p>12.在Worker API中， 不能再设置worker的工作目录 .<br>
与依赖关系和版本约束有关的行为更改可能会影响少量用户.<br>
对DefaultTask上的属性工厂方法进行了一些更改，这些更改可能会影响自定义任务的创建.</p>
<p>#升级Gradle和Gradle插件</p>
<p>升级跟砍传奇一样，只有你升级了之后才之后哪些是报错，哪些不是报错，报错了一个一个解决，都解决完成，升级完成。</p>
<p>##报错一<br>
ERROR: Unable to resolve dependency for ':58WuxianClient@wubaDebug/compileClasspath': Could not resolve com.anjuke.mobile:sign:1.1.2-SNAPSHOT.</p>
<p>##报错二<br>
com.facebook.imagepipeline.image.CloseableAnimatedImage 错误:找不到符号<br>
解决：经排查是因为&quot;com.facebook.fresco:animated-base&quot;这个库找不到导致，在原来的版本上是可以有这一层依赖的。它是在animated-gif下，不过目前看到的是没有的。所以，最后添加了对此库的依赖。</p>
<p>##报错三<br>
transformClassesAndResourcesWithR8ForWubaRelease FAILED<br>
解决：这是R8编译时发生的错误，禁止R8即可；<br>
Disables R8 for Android Library modules only.<br>
android.enableR8.libraries = false<br>
Disables R8 for all modules.<br>
android.enableR8 = false</p>
<p>##报错四<br>
Caused by: com.android.tools.r8.utils.AbortException: Error: null, Cannot fit requested classes in the main-dex file (# methods: 69437 &gt; 65536)<br>
[exec]  at com.android.tools.r8.utils.Reporter.a(:21)<br>
[exec]  at com.android.tools.r8.utils.Reporter.a(:7)<br>
[exec]  at com.android.tools.r8.dex.VirtualFile.a(:33)<br>
[exec]  at com.android.tools.r8.dex.VirtualFile$e.a(:37)<br>
[exec]  at com.android.tools.r8.dex.ApplicationWriter.a(:13)<br>
[exec]  at com.android.tools.r8.dex.ApplicationWriter.write(:35)<br>
[exec]  at com.android.tools.r8.D8.d(:44)<br>
[exec]  at com.android.tools.r8.D8.b(:1)<br>
[exec]  at com.android.tools.r8.utils.t.a(:23)</p>
<p>分析：目前有两种方案，一种是没有配置multidex，一种是java的JDK没有升级1.8</p>
<p>添加了android.enableD8=false之后，发现会报错：<br>
Java 8 language support, as requested by 'android.enableD8.desugaring= true' in your gradle.properties file, is not supported when 'android.enableD8= false'</p>
<p>现在反向思路解决不了问题，咱们就正向解决，让它放在main-dex里面，然后再分析，先保证打包能过去；<br>
去掉了一些文件在主dex之后，继续开启编译之路，但是很快，就遇到了新的问题：</p>
<p>##报错五<br>
com.android.tools.build.apkzlib.zip.compress.Zip64NotSupportedException: Zip64 EOCD locator found but Zip64 format is not supported: /opt/build/temp/74638/beta/android/58WuxianClient/build/intermediates/transforms/proguard/wuba/release/0.jar</p>
<p>从字面意思分析是从配置上支持了使用Zip64打包APK，但是发现我们release下的jar包不支持。那大概有两种思路，一种是让我们的包支持zip64，另外一种是想办法把zip64禁用。</p>
<p>我尝试了本地打包，居然通过了，看的我老泪纵横：<br>
Tasks spend time &gt; 50ms:<br>
04:25.78   :58WuxianClient:multiDexListWubaDebug<br>
04:17.27   :58WuxianClient:transformClassesWithDexBuilderForWubaDebug<br>
02:41.24   :58WuxianClient:javaPreCompileWubaDebug<br>
01:29.50   :58WuxianClient:mergeWubaDebugResources<br>
01:06.02   :58WuxianClient:checkConflictDependencies<br>
00:55.43   :58WuxianClient:mergeDexWubaDebug<br>
00:46.11   :58WuxianClient:processWubaDebugResources<br>
00:30.93   :58WuxianClient:mergeWubaDebugNativeLibs<br>
00:28.55   :58WuxianClient:compileWubaDebugJavaWithJavac<br>
00:24.20   :58WuxianClient:packageWubaDebug<br>
00:21.95   :58WuxianClient:mergeWubaDebugJavaResource<br>
00:19.80   :58WuxianClient:checkWubaDebugDuplicateClasses<br>
00:14.39   :58WuxianClient:stripWubaDebugDebugSymbols<br>
00:12.02   :58WuxianClient:processWubaDebugManifest<br>
00:05.95   :58WuxianClient:transformClassesWithAjxForWubaDebug<br>
00:04.09   :PublishDex:javaPreCompileDebug<br>
00:03.39   :PublishDex:mergeDebugJavaResource<br>
00:03.17   :PublishDex:transformClassesWithDexBuilderForDebug<br>
00:02.84   :PublishDex:mergeExtDexDebug<br>
00:02.67   :58WuxianClient:transformClassesWithCom.alibaba.arouterForWubaDebug<br>
00:02.56   :PublishDex:compileDebugJavaWithJavac<br>
00:02.29   :PublishDex:processDebugResources<br>
00:01.87   :58WuxianClient:mergeWubaDebugAssets<br>
00:01.04   :PublishDex:packageDebug<br>
00:00.68   :PublishDex:processDebugManifest<br>
00:00.63   :PublishDex:mergeDebugResources<br>
00:00.26   :PublishDex:mergeDexDebug<br>
00:00.22   :58WuxianClient:clean<br>
00:00.11   :PublishDex:generateDebugBuildConfig<br>
00:00.10   :PublishDex:checkDebugManifest<br>
00:00.08   :PublishDex:preBuild<br>
00:00.07   :58WuxianClient:mergeWubaDebugShaders<br>
BUILD SUCCESSFUL in 11m 4s<br>
53 actionable tasks: 53 executed<br>
bjdhj-124-7:58ClientProject $</p>
<p>看了一下具体的区别，发现我们是没有构建release的包的过程，本地目前用的是debug，而AVM用的是Release构建，想到这，我发现有一个配置：useProguard true，跟我本地配置是不太一样的。</p>
<p>解决：<br>
查看配置文件，发现我们配置了：android.useDeprecatedNdk=true，所以直接去掉就行了，编译器会自动帮我们做。</p>
<p>#问题六</p>
<blockquote>
<p>Cannot get the value of write-only property 'isSourceDependency' for script of type ajk_dependencies_dq8xyz4cdpugj2rk4pphbca0e.</p>
</blockquote>
<p>//用户标识是否为源码依赖，修改 isSourceDependency 可实现全局aar依赖或源码依赖<br>
@Field def isSourceDependency = true</p>
<p>A problem occurred configuring project ':58AnjukeLib'.<br>
[exec] &gt; compileSdkVersion is not specified.</p>
<p>#问题七</p>
<blockquote>
<p>Task :58WuxianClient:transformClassesWithMultidexlistForWubaRelease<br>
multiDexTask.name transformClassesWithMultidexlistForWubaRelease<br>
[collectWubaDebugMultiDexComponents, collectWubaReleaseMultiDexComponents]</p>
</blockquote>
<p>multiDexBuildMainlistTask.nametransformClassesWithMultidexlistForWubaRelease<br>
[transformClassesWithMultidexlistForWubaDebug，transformClassesWithMultidexlistForWubaRelease]</p>
<p>这个task没有执行导致task无法正常运行；<br>
但是，下面这个task就执行了，咱们看看人家为啥执行：</p>
<blockquote>
<p>Task :58WuxianClient:transformClassesWithNewLensTransformForWubaRelease<br>
看不出来，咱们缺的task还有：<br>
Task :58WuxianClient:transformClassesWithDexBuilderForWubaRelease<br>
Task :58WuxianClient:transformClassesWithMultidexlistForWubaRelease<br>
事实证明人家就是把transformClassesWithDexBuilderForxxx这个task给删除了；或者说人家执行了 ，但是压根没给你暴露出来<br>
解决办法：<br>
#问题八<br>
def isSourceDependency 报错找不到：修改为： ext { isSourceDependency = true }</p>
</blockquote>
<p>#问题九<br>
官方的API描述：task的getFile方法描述：Returns the output files of this task.但是我没有找到<br>
https://docs.gradle.org/5.4.1/javadoc/org/gradle/api/tasks/TaskOutputs.html</p>
<p>#问题十<br>
使用R8一直报错，总是报<br>
58WuxianClient:transformClassesAndResourcesWithR8ForWubaRelease in 58AnjukeLib Finished<br>
R8: Cannot fit requested classes in the main-dex file (# methods: 66075 &gt; 65536)<br>
咱们已经使用R8了，而且已经配置了multidex但是依然还是不生效，仔细一看，果然是因为这个lib没有单独做配置；导致它打包的时候全都在主dex里面；<br>
那是不是所有的库，都需要这么配置呢？</p>
<p>#问题十一</p>
<pre><code> [exec]       05:38.92   :58WuxianClient:transformClassesAndResourcesWithR8ForWubaRelease
 [exec]       02:41.08   :58WuxianClient:mergeWubaReleaseJavaResource
 [exec]       02:11.56   :58WuxianClient:transformClassesWithNewLensTransformForWubaRelease
 [exec]       01:17.21   :58WuxianClient:resguardWubaRelease
 [exec]       00:51.20   :58WuxianClient:packageWubaRelease
 [exec]       00:25.99   :58WuxianClient:transformClassesWithWmdaInjectForWubaRelease
 [exec]       00:21.68   :58WuxianClient:processWubaReleaseResources
 [exec]       00:19.77   :58WuxianClient:mergeWubaReleaseResources
 [exec]       00:09.78   :58WuxianClient:checkConflictDependencies
 [exec]       00:08.49   :58WuxianClient:compileWubaReleaseJavaWithJavac
 [exec]       00:03.56   :58WuxianClient:javaPreCompileWubaRelease
 [exec]       00:02.37   :58WuxianClient:processWubaReleaseManifest
 [exec]       00:02.30   :58WuxianClient:transformClassesWithAjxForWubaRelease
 [exec]       00:01.13   :58WuxianClient:mergeWubaReleaseAssets
 [exec]       00:00.93   :58WuxianClient:stripWubaReleaseDebugSymbols
 [exec]       00:00.88   :58WuxianClient:transformClassesWithCom.alibaba.arouterForWubaRelease
 [exec]       00:00.06   :58WuxianClient:mergeWubaReleaseGeneratedProguardFiles
</code></pre>
<p>#问题十二<br>
折腾来折腾去，最终发现我们的老方法已经行不通了，而且它已经使用了3年了，是时候使用正规的混淆方法了。</p>
<p>dexOptions {<br>
...<br>
additionalParameters = [//dex参数详见 dx --help<br>
'--multi-dex', //多分包<br>
'--set-max-idx-number=55000', //每个包内方法数上限<br>
//'--main-dex-list=' + projectDir +<br>
//'/maindexlist.txt', //打包进主classes.dex的文件列表<br>
//'--minimal-main-dex' //使上一句生效<br>
...<br>
]<br>
}</p>
<p>#问题十三<br>
Java 8 language support, as requested by 'android.enableD8.desugaring= true' in your gradle.properties file, is not supported when 'android.enableD8= false'</p>
<p>使用方式的变化<br>
不再需要使用 apply plugin:'com.android.application'，如果您是 portal 工程，仅仅需要 apply plugin:'com.alipay.portal'。<br>
如果您是 bundle 工程，也需要删除 apply plugin:'com.android.application', 仅需要使用 apply plugin:'com.alipay.bundle'。<br>
library 工程依然使用 apply plugin:'com.android.library'。<br>
如果使用最新稳定版本 Android Studio 3.5 或以上，那么您需要在 gradle.properties 里面新增 android.buildOnlyTargetAbi=false。<br>
由于我们的无线保镖组件暂不支持 V2 签名，如果您需要使用 Android Studio 调试并安装您的 APK，那么您需要禁用 V2 签名；如果您使用命令行进行构建，且您的 minSdkVersion 大于等于 24，则您也需要禁用 V2 签名。禁用 V2 签名的方式如下：<br>
v2SigningEnabled false</p>
<p>#问题十四<br>
DX和D8的区别<br>
<img src="https://Mozziehh.github.io/post-images/1584063787625.png" alt="" loading="lazy"><br>
<img src="https://Mozziehh.github.io/post-images/1584063835796.png" alt="" loading="lazy"></p>
<p>#问题十五</p>
<p>AAPT2 aapt2-3.5.3-5435860-linux Daemon #0: shutdown<br>
[exec] R8: The rule <code>-keep class * extends com.facebook.react.bridge.JavaScriptModule { [exec] *; [exec] }</code> uses extends but actually matches implements.</p>
<p>R8: The rule <code>-keep public class * extends androidx.versionedparcelable.VersionedParcelable { [exec] &lt;init&gt;(); [exec] }</code> uses extends but actually matches implements.<br>
[exec] AAPT2 aapt2-3.5.3-5435860-linux Daemon #1: shutd</p>
<p>R8: The rule <code>-keep class * extends com.facebook.react.bridge.JavaScriptModule { [exec] *; [exec] }</code> uses extends but actually matches implements.</p>
<p>解决：这是versionedparcelable 1.0.0的bug，在1.1.0版本已经修改，修改方法：</p>
<p>https://r8.googlesource.com/r8/+/6a4e7c1dc82838cefc5ef5964186fa088ad9bee1/src/main/java/com/android/tools/r8/naming/signature/GenericSignatureRewriter.java</p>
<p>1、在proguard文件中添加：<br>
-keep public class * implements androidx.versionedparcelable.VersionedParcelable</p>
<p>2、在build.gradle文件中添加：<br>
implementation &quot;androidx.versionedparcelable:versionedparcelable:1.1.0&quot;</p>
<p>3、在build.gradle中添加：<br>
packagingOptions {<br>
exclude 'META-INF/androidx.versionedparcelable_versionedparcelable.version'<br>
}</p>
<p>#问题十六<br>
R8: Invalid signature 'Lcom/squareup/haha/guava/collect/AbstractMapBasedMultimap&lt;TK;TV;&gt;.com/squareup/haha/guava/collect/AbstractMapBasedMultimap<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi>r</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>d</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo separator="true">;</mo><mi>L</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>S</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>T</mi><mi>V</mi><mo separator="true">;</mo><mo>&gt;</mo><msup><mo separator="true">;</mo><mo mathvariant="normal">′</mo></msup><mi>f</mi><mi>o</mi><mi>r</mi><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>u</mi><mi>p</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>a</mi><mi>h</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>g</mi><mi>u</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>A</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">WrappedCollection;Ljava/util/SortedSet&lt;TV;&gt;;&#x27; for class com.squareup.haha.guava.collect.AbstractMapBasedMultimap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mpunct"><span class="mpunct">;</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>WrappedSortedSet.<br>
[exec] Signature is ignored and will not be present in the output.<br>
[exec] Parser error: Expected ; at position 70</p>
<p>#问题十七</p>
<p>我有一个相关的错误,但与React Native 0.47.1略有不同：<br>
java.lang.NoSuchFieldError: no &quot;Lcom/facebook/jni/HybridData;&quot; field &quot;mHybridData&quot; in class &quot;Lcom/facebook/react/bridge/JavaScriptExecutor;&quot; or its superclasses<br>
at com.facebook.react.bridge.CatalystInstanceImpl.initializeBridge(Native Method)<br>
at com.facebook.react.bridge.CatalystInstanceImpl.<init>(SourceFile:114)<br>
at com.facebook.react.bridge.CatalystInstanceImpl.<init>(SourceFile:42)<br>
at bnv.a(SourceFile:574)<br>
at bmg.a(SourceFile:999)<br>
at bmg.a(SourceFile:109)<br>
at bmg$4.run(SourceFile:802)<br>
at java.lang.Thread.run(Thread.java:761)<br>
我必须在我的Proguard文件中添加稍微不同的行来修复：</p>
<p>-keep class com.facebook.react.bridge.CatalystInstanceImpl { *; }<br>
-keep class com.facebook.react.bridge.JavaScriptExecutor { *; }<br>
-keep class com.facebook.react.bridge.queue.NativeRunnable { *; }<br>
-keep class com.facebook.react.bridge.ReadableType { *; }</p>
<p>#问题十八<br>
R8: Missing class: org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImplWrapper<br>
[exec] R8: Missing class: org.springframework.http.converter.GenericHttpMessageConverter<br>
[exec] R8: Missing class: org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl<br>
[exec] R8: Missing class: org.glassfish.jersey.internal.spi.AutoDiscoverable<br>
[exec] R8: Missing class: org.springframework.messaging.converter.AbstractMessageConverter<br>
[exec] R8: Missing class: com.android.org.conscrypt.OpenSSLSocketImplWrapper<br>
[exec] R8: Missing class: com.huawei.android.app.HwMultiWindowEx<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>C</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mo>[</mo><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mo>]</mo><mi>R</mi><mn>8</mn><mo>:</mo><mi>M</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mo>:</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>r</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>O</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>S</mi><mi>S</mi><mi>L</mi><mi>S</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>I</mi><mi>m</mi><mi>p</mi><mi>l</mi><mo>[</mo><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mo>]</mo><mi>R</mi><mn>8</mn><mo>:</mo><mi>M</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mo>:</mo><mi>o</mi><mi>r</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>w</mi><mi>e</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>A</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>S</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>J</mi><mi>s</mi><mi>M</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>C</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>c</mi><mo>[</mo><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mo>]</mo><mi>R</mi><mn>8</mn><mo>:</mo><mi>M</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mo>:</mo><mi>a</mi><mi>n</mi><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>p</mi><mi>h</mi><mi>o</mi><mi>n</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>T</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>p</mi><mi>h</mi><mi>o</mi><mi>n</mi><mi>y</mi><mi>M</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">StateChangeListener
     [exec] R8: Missing class: com.android.org.conscrypt.OpenSSLSocketImpl
     [exec] R8: Missing class: org.springframework.web.socket.sockjs.frame.AbstractSockJsMessageCodec
     [exec] R8: Missing class: android.telephony.TelephonyManager</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>CellInfoCallback<br>
[exec] R8: Missing class: org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice<br>
[exec] R8: Missing class: org.springframework.http.converter.AbstractHttpMessageConverter<br>
[exec] R8: Missing class: org.springframework.data.redis.serializer.RedisSerializer<br>
[exec] R8: Missing class: android.arch.paging.PositionalDataSource<br>
[exec] R8: Missing class: org.springframework.web.servlet.view.AbstractView</p>
<p>##问题十九<br>
proguard.txt 里面有一个...那个问题得解决</p>
<p>##问题二十</p>
<h1 id="for-native-methods-see-httpproguardsourceforgenetmanualexampleshtmlnative">For native methods, see http://proguard.sourceforge.net/manual/examples.html#native</h1>
<p>-keepclasseswithmembernames class * {<br>
native <methods>;<br>
}<br>
-keepclasseswithmembernames,includedescriptorclasses class * {<br>
native <methods>;<br>
}<br>
在混淆里面加入</p>
<p>##问题二十一</p>
<ul>
<li>What went wrong:<br>
[exec] Execution failed for task ':58WuxianClient:transformClassesAndResourcesWithR8ForWubaRelease'.<br>
[exec] &gt; java.util.NoSuchElementException (no error message)<br>
这是因为使用了不匹配的buildToolsVersion，将其改为buildToolsVersion=29.0.2好了</li>
</ul>
<p>##问题二十二<br>
发布AAR报错<br>
就在我以为我可以的时候，突然间发布AAR报错了，老子万念俱灰；</p>
<p>Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no]<br>
The response from https://scans-in.gradle.com/in/5.6.4/2.4.2 was not from the build scan server.<br>
Your network environment may be interfering, or the service may be unavailable.</p>
<p>If you believe this to be in error, please report this problem via https://gradle.com/scans/help/plugin and include the following via copy/paste:</p>
<hr>
<h2 id="gradle-version-564plugin-version-242request-url-httpsscans-ingradlecomin564242request-id-0bcae986-da07-4567-a4b2-5a32fd4079b0response-status-code-502response-content-type-texthtmlresponse-server-type-cloudflare">Gradle version: 5.6.4<br>
Plugin version: 2.4.2<br>
Request URL: https://scans-in.gradle.com/in/5.6.4/2.4.2<br>
Request ID: 0bcae986-da07-4567-a4b2-5a32fd4079b0<br>
Response status code: 502<br>
Response content type: text/html<br>
Response server type: cloudflare</h2>
<p>Task has not declared any outputs despite executing actions</p>
<p>Task ':WubaCommonsLib:mergeDebugNativeLibs' is not up-to-date because:<br>
Output property 'cacheDir' file /Users/huhao/AndroidStudioProjects/wuba/58ClientProject/WubaCommonsLib/build/intermediates/incremental/debug-mergeNativeLibs/zip-cache has been removed.<br>
Output property 'outputDir' file /Users/huhao/AndroidStudioProjects/wuba/58ClientProject/WubaCommonsLib/build/intermediates/merged_native_libs/debug/out has been removed.<br>
Output property 'outputDir' file /Users/huhao/AndroidStudioProjects/wuba/58ClientProject/WubaCommonsLib/build/intermediates/merged_native_libs/debug/out/lib has been removed.</p>
<p>https://s0docs0gradle0org.icopy.site/current/dsl/org.gradle.api.publish.maven.MavenPublication.html maven发布报错</p>
<p>https://www.icode9.com/content-4-493255.html<br>
##参考链接<br>
https://developer.android.google.cn/studio/releases/gradle-plugin?hl=zh_cn<br>
https://www.jianshu.com/p/13a62e1ac396</p>
<p>https://developer.android.google.cn/studio/releases/gradle-plugin#updating-gradle</p>
<p>https://blog.csdn.net/Gdeer/article/details/83106449</p>
<p>https://www.jianshu.com/p/9eb063fa9c79</p>
<p>https://juejin.im/entry/5a7807926fb9a063517250b1</p>
<p>https://help.aliyun.com/knowledge_detail/151447.html?spm=5176.13910061.0.0.153b3a2dPjuJZs&amp;aly_as=mBoSMf9d</p>
<p>https://docs.gradle.org/5.4.1/javadoc/</p>
<p>https://www.jianshu.com/p/f2cd43e488a6</p>
<p>https://r8.googlesource.com/r8</p>
<p>https://blog.csdn.net/xiongya8888/article/details/94446803</p>
<p>https://blog.csdn.net/xyq046463/article/details/102929528?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</p>
<p>https://developer.android.com/studio/command-line/d8</p>
<p>https://developer.android.com/studio/build/multidex?hl=zh-cn</p>
<p>https://d.android.com/r/studio-ui/d8-overview.html</p>
<p>https://developer.android.com/studio/build/multidex</p>
<p>https://developer.android.com/studio/build/apk-analyzer</p>
<p>https://www.guardsquare.com/en/products/proguard/manual/usage#keepoptions</p>
<p>https://www.jianshu.com/p/dd932f951137 官网建议</p>
<p>https://developer.android.com/studio/build/shrink-code#java R8优化</p>
<p>https://www.guardsquare.com/en/blog/proguard-and-r8 混淆优化说明</p>
<p>https://fucknmb.com/2019/05/28/R8-%E8%B8%A9%E5%9D%91%E8%AE%B0/ R8踩坑记</p>
<p>https://fucknmb.com/2017/06/01/Android-Gradle-Plugin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E7%BC%96%E8%AF%91/<br>
gradle源码查看<br>
https://www.jianshu.com/p/11f030b2034f gradle插件源码查看</p>
<p>https://android.googlesource.com/platform/tools/base/+/studio-master-dev/build-system/gradle-core/src/main/java/com/android/build/gradle/internal/scope/VariantScopeImpl.java</p>
<p>https://zhuanlan.zhihu.com/p/62794593 关于脱糖</p>
<p>https://www.cnblogs.com/skymxc/p/gradle-custom-plugin.html 开发一个gradle插件</p>
<p>https://juejin.im/post/5c5bee986fb9a049bc4d1b58 缩减MainDex大小</p>
<p>https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[android开源框架分析系列之-EventBus]]></title>
        <id>https://Mozziehh.github.io/post/eventbuszen-me-jiu-xue-bu-ming-bai-ni/</id>
        <link href="https://Mozziehh.github.io/post/eventbuszen-me-jiu-xue-bu-ming-bai-ni/">
        </link>
        <updated>2020-02-10T14:01:54.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在看开源框架，对于经常使用的EventBus，觉得用起来非常简单，所以比较好奇，看了几篇文章。然后把EventBus的关键点提取到了Anki上，随着时间的推移，突然发现印象越来越模糊，反反复复的看光是看理论印象还是不够深刻。于是，打算深挖一下EventBus的源码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在看开源框架，对于经常使用的EventBus，觉得用起来非常简单，所以比较好奇，看了几篇文章。然后把EventBus的关键点提取到了Anki上，随着时间的推移，突然发现印象越来越模糊，反反复复的看光是看理论印象还是不够深刻。于是，打算深挖一下EventBus的源码。</p>
<!-- more -->
<p>开篇习惯，带着问题看源码，如果你能回答出如下问题，那么，出门右转，不要浪费宝贵的大好青春~<br>
1.简单的描述一个EventBus的使用Demo？<br>
2.EventBus的注册是怎么回事？<br>
3.当我使用PostEvent发送事件之后，EventBus会执行哪些流程？它是如何找到对应的事件的？<br>
4.EventBus的取消注册是怎么回事？<br>
5.简单的说一下粘性事件？</p>
<!-- more -->
<p>#关于EventBus</p>
<p>EventBus的简介，网上有的是，这里不再赘述，你只要知道，它使用的是观察者模式，通过Event来传递。</p>
<p>#带着问题看源码</p>
<p>##简单的描述一个EventBus的使用Demo？</p>
<p>###注册</p>
<pre><code>EventBus.getDefault().register(this)；
</code></pre>
<p>###自定义事件</p>
<pre><code>public class MessageEvent{
    private String message;
    public  MessageEvent(String message){
        this.message=message;
    }
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>
<p>###发送</p>
<pre><code>EventBus.getDefault().post(messageEvent);
</code></pre>
<p>###处理事件</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MAIN)
public void XXX(MessageEvent messageEvent) {
    ...
}
</code></pre>
<p>###取消注册</p>
<pre><code>EventBus.getDefault().unRegister(this)；
</code></pre>
<p>##EventBus的注册是怎么回事？</p>
<p>接下来就带你看看注册的源码是怎么回事，先回忆一下上一节的代码，我们就使用了一句简单的EventBus.getDefault().register(this)；就完成了注册，它主要分为两个部分：getDefault()和register(this)；</p>
<p>那么getDefault是什么呢？<br>
查看源代码得知，原来它就是一个使用了volatile和synchronized双重锁单例：</p>
<pre><code>static volatile EventBus defaultInstance;
public static EventBus getDefault() {
        EventBus instance = defaultInstance;
        if (instance == null) {
            synchronized (EventBus.class) {
                instance = EventBus.defaultInstance;
                if (instance == null) {
                    instance = EventBus.defaultInstance = new EventBus();
                }
            }
        }
        return instance;
}

这里面还有一个小技巧：
/**
 * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a
 * central bus, consider {@link #getDefault()}.
 */
public EventBus() {
    this(DEFAULT_BUILDER);
}

public static EventBusBuilder builder() {
    return new EventBusBuilder();
}
发现没，它是在单例的EventBus里面，默认设置了一个EventBusBuilder，通过EventBusBuilder的名字你大概能轻易的猜出来使用了构建者模式，最终返回的这个真正的EventBus。
</code></pre>
<p>在得到单例之后，就进行了注册：</p>
<p>下面就是注册方法：<br>
注册的时候要注意，首先使用注册就一定要使用反注册，否则，你将会一直收到该消息；然后是一定要为处理该消息的方法进行声明，Subscribe也行，或者是再加上ThreadMode和优先级；</p>
<pre><code>    public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>注册主要分为两步：<br>
###获取到注册类的所有的声明了Subscribe注解的事件：<br>
注册的时候，会获取你注册的类对象，然后调用findSubscriberMethods方法，返回List<SubscriberMethod>集合，我们叫做观察者集合（我自己起的名）。<br>
这里面用到了一个METHOD_CACHE，它是一个ConcurrentHashMap，考考你：什么是ConcurrentHashMap？它是如何使用size()方法如何容器大小的？</p>
<pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {

        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);
        //这个地方就是一个设计模式：享元
        if (subscriberMethods != null) {
            return subscriberMethods;
        }

        if (ignoreGeneratedIndex) {
            subscriberMethods = findUsingReflection(subscriberClass);
        } else {
            subscriberMethods = findUsingInfo(subscriberClass);
        }
        if (subscriberMethods.isEmpty()) {
            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
        } else {
            METHOD_CACHE.put(subscriberClass, subscriberMethods);
            return subscriberMethods;
        }
    }
</code></pre>
<p>然后接下来就是findUsingReflection</p>
<p>#参考文章<br>
https://www.jianshu.com/p/f9ae5691e1bb</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python使用规范]]></title>
        <id>https://Mozziehh.github.io/post/python-shi-yong-gui-fan/</id>
        <link href="https://Mozziehh.github.io/post/python-shi-yong-gui-fan/">
        </link>
        <updated>2020-01-07T06:10:45.000Z</updated>
        <content type="html"><![CDATA[<p>最近一直在写python脚本，马上开源了，发现里面有很多不规范的使用方法，在这里特别记录：</p>
<p>##编码</p>
<ul>
<li>统一使用 UTF-8 编码；</li>
<li>导入的包在代码的最前面；</li>
<li>每行代码不宜过长，不要超过120字符；</li>
<li>使用面向对象思想编程，按照功能划分类，按照职责划分方法；</li>
</ul>
<p>##关于注释</p>
<ul>
<li>单行文档注释可以使用#标注；</li>
<li>多行可以使用三个双引号&quot;&quot;&quot;...&quot;&quot;&quot;；</li>
<li>关键方法要使用注释，方便维护；</li>
</ul>
<p>##类和方法</p>
<ul>
<li>对于一个类，里面有多个方法可以使用_init_()方法来初始化变量，以便该类中各个方法使用；假如接入该类只有一个方法，那么可以忽略_init()方法，直接自定义方法;</li>
<li>方法之间可以不空行，类与类之间要空行；</li>
<li>类的名字使用驼峰命名法，首字母大写；</li>
<li>所有方法，全部使用小写；</li>
<li>私有方法，使用_下划线开头；</li>
<li>常量使用大写；</li>
<li>每个语句执行完可以不加&quot;;&quot;，但是要注意使用换行</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开源框架分析系列之-Fresco]]></title>
        <id>https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco/</id>
        <link href="https://Mozziehh.github.io/post/android-kai-yuan-kuang-jia-fen-xi-xi-lie-zhi-fresco/">
        </link>
        <updated>2019-12-14T02:43:38.000Z</updated>
        <content type="html"><![CDATA[<p>##为什么选择Fresco<br>
1、它是Facebook出品的开源库，避免重复造轮子；</p>
<p>2、Fresco 支持 Android2.3(API level 9) 及其以上系统,基本上可以含盖目前市场上的绝大部分android手机，我们目前的支持的最低版本android 4.0(API level 14);</p>
<p>3、在5.0以下系统，Fresco将图片放到一个特别的内存共享区域（ashmem）。在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
<p>4、使用简单，一行代码setImageURI()就可以加载图片和显示；</p>
<p>5、支持三级缓存，Bitmap缓存、未解码图片缓存、文件缓存；</p>
<p>6、对okHttp和volley网络库的兼容，目前我们项目中使用的是volley网络库，可以灵活配置；</p>
<p>7、支持的图片格式有jpg/jpeg、png、jpeg图片的渐进式呈现、gif、webP；</p>
<p>##带着问题看文章<br>
按照国际惯例，请先阅读如下题目，如果你会了，那么就可以关闭文章了：</p>
<p>1、Fresco和Glide的对比？（大小、加载生命周期、图片格式、旋转裁减、缓存方式）</p>
<p>2、DraweeView中成员变量DraweeHolder与DraweeHierarchy与DraweeController三者之间的关系？</p>
<p>3、当view被从ViewGroup临时分离时回调，执行了Fresco的哪个方法？</p>
<p>4、Fresco加载图片的几种方式？（Center.CENTER_INSIDE、Fit.CENTER等）</p>
<p>5、Fresco在管理ashmem区域采用了哪种方式回收内存？</p>
<p>6、Fresco在加载图片时，为了缓解OOM除了采用ashmem，还有什么策略？采样的策略是如何做的？</p>
<p>7、Fresco内部使用LRU算法维护图片池，那么对于那些不经常变动但是需要常驻的图片，Fresco可以怎么处理？</p>
<p>8、Fresco内部是如何获取本地缓存路径的？<br>
##它和Glide的对比<br>
###包大小&amp;复杂度<br>
fresco的包比较复杂，因此Facebook将其拆分成几个不同的aar库，可根据需要分别加载依赖，大小3M左右。</p>
<p>glide包还好，除okhttp拆分出单独的aar包外，其他功能均在一个aar包中。glide拆分出了单独的图片处理库，可以支持对图片的裁剪，旋转，模糊和滤镜等操作，大小300KB左右。</p>
<p>###影响一次图片加载过程的生命周期对象（即一次图片加载受谁的生命周期控制影响）<br>
fresco：图片的加载受view生命周期的影响</p>
<p>glide：图片的加载受context的生命周期影响，context可以是fragment、activity、application。</p>
<p>###支持的图片格式<br>
fresco：png、jpeg、webp、gif、jfif；<br>
glide：png、jpeg、webp、gif。</p>
<p>###支持图片的旋转和裁剪<br>
fresco和glide均支持图片的旋转和裁剪。</p>
<p>fresco：</p>
<p>图片旋转：</p>
<p>imageRequestBuilder.setRotationOptions(RotationOptions.forceRotation(RotationOptions.ROTATE_90));</p>
<p>图片的裁剪：</p>
<p>imageRequestBuilder.setResizeOptions(new ResizeOptions(reqWidth, reqHeight));</p>
<p>glide：</p>
<p>图片的旋转：</p>
<p>创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new RotateTransformation( context, 90f )).into( imageView);</p>
<p>图片的裁剪：</p>
<p>a、直接使用override(imageWidth, imageWidth)方法，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).override(imageWidth, imageWidth).into( imageView);</p>
<p>b、创建BitmapTransformation 对象在加载图片的时候传入，</p>
<p>Glide.with( context ).load( eatFoodyImages[0] ).transform( new ResizeTransformation( context, width,height )).into( imageView);</p>
<h3 id="缓存方式">缓存方式</h3>
<p>fresco：三级缓存：二级内存缓存 + 磁盘文件缓存，只有第一级内存缓存在UI线程中操作，其他均在io线程中</p>
<p>fresco二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、png、jpeg等格式的文件缓存，需要解码成bitmap对象。</p>
<p>glide：二级内存缓存（严格意义上来说只有一级，第二级可以忽略）加磁盘文件缓存，内存缓存均在UI线程中，磁盘缓存在io线程中操作。</p>
<p>glide二级内存缓存分别是：</p>
<p>a、bitmap对象缓存；</p>
<p>b、WeakReference(bitmap)缓存，即弱引用bitmap对象缓存。</p>
<h3 id="代码侵入式">代码侵入式</h3>
<p>fresco在使用的时候基本都要引入其封装的DraweeView，代码侵入性很强。glide代码侵入性相比不强。</p>
<p>##Fresco架构<br>
<img src="https://Mozziehh.github.io/post-images/1576291547391.png" alt="" loading="lazy"></p>
<p>DraweeView中成员变量DraweeHolder主要用于控制逻辑层，DraweeHolder包含DraweeHierarchy和DraweeController，DraweeHierarchy用于存储图像，DraweeController用于控制显示图像，为什么把DraweeHierarchy和DraweeController封装到DraweeHolder 中呢？是为了解藕，通过DraweeHolder可以方便的使用这两个组件。DraweeView 把获得的 Event 转发给 Controller，然后 Controller 根据 Event 来决定是否需要显示和隐藏 （包括动画）图像，而这些图像都存储在 Hierarchy 中，最后 DraweeView 绘制时直接通过 getTopLevelDrawable 就可以获取需要显示的图像。</p>
<p>##Fresco核心显示处理<br>
看一下DraweeView重写了View的四个方法：<br>
@Override<br>
protected void onAttachedToWindow() {<br>
super.onAttachedToWindow();<br>
mDraweeHolder.onAttach();<br>
}</p>
<pre><code>@Override
protected void onDetachedFromWindow() {
super.onDetachedFromWindow();
mDraweeHolder.onDetach();
}

@Override
public void onStartTemporaryDetach() {
super.onStartTemporaryDetach();
mDraweeHolder.onDetach();
}

@Override
public void onFinishTemporaryDetach() {
super.onFinishTemporaryDetach();
mDraweeHolder.onAttach();
}
</code></pre>
<p>onAttachedToWindow 是view 本身的回调，当view 被添加到window中，被绘制之前的回调。如addview（this view）；<br>
onDetachedFromWindow 是view 本身的回调，当view被从window中删除时的回调。如 removeview（this view）;<br>
onStartTemporaryDetach 是view本身的回调，当view被从ViewGroup临时分离时回调，如listview中的item移出屏幕时；<br>
onFinishTemporaryDetach 是view本身的回调，当view在回调onStartTemporaryDetach完成改变后，再次添加到ViewGroup时回调，如listview中复用的item划入屏幕时；<br>
DraweeView通过这个两对方法来保证当view移出屏幕容器和添加进入屏幕容器时来调用mDraweeHolder.onAttach()和mDraweeHolder.onDetach()来保证显示图片的逻辑的，mDraweeHolder.onAttach()就是从Controller中获取要现实的图片资源显示，mDraweeHolder.onAttach()就是释放资源，具体实现可以跟一下源码查看；</p>
<p>##fresco对内存缓存策略</p>
<p>Fresco的内存缓存策略是根据android系统版本不同做了不同处理，5.0以下系统：图片不存储在Java heap，而是存储在ashmem，中间的字节 buffer同样位于native heap。使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，这块存储区域是别于堆 内存之外的一块空间，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统 Fresco将Bitmap缓存直接放到了堆内存中。</p>
<p>关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种 为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性inPurgeable：</p>
<pre><code>BitmapFactory.Options = new BitmapFactory.Options();
options.inPurgeable = true;
Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);
</code></pre>
<p>所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。</p>
<p>既然Fresco中Bitmap缓存在5.0以下是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收 它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个 SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方 法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提 供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同 时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在 调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与 CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：</p>
<p>1）在赋值CloseableReference给新对象的时候，调用.clone()进行赋值</p>
<p>2）在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用</p>
<p>##图片采样处理<br>
为防止使用者对图片的大小没有概念或者直接加载过大图片时造成内存溢出的风险加大，按照经验统一了三个采样标准：<br>
DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE<br>
DefaultConfigCentre.ResizeOptionsType.BIG_TYPE</p>
<p>##对于那些不经常变动的图片，我们应该怎么处理；</p>
<p>当我们有些图片不经常动时需要能长时间保存，但如果放入同一个本地缓存文件下时，随着不断加载图片到文件缓存设定上限时，根据LruCach的规则，需要长时间保存的图片可能就会被清除掉，那这就不满足我们的需求了，应该怎么处理呢？</p>
<p>1）强大的fresco已经给我们提供了解决方案，引用官网资料：<br>
用一个文件还是两个文件缓存?<br>
如果要使用2个缓存，在配置image pipeline 时调用 setMainDiskCacheConfig 和 setSmallImageDiskCacheConfig 方法即可。大部分的应用有一个文件缓存就够了，但是在一些情况下，你可能需要两个缓存。比如你也许想把小文件放在一个缓存中，大文件放在另外一个文件中，这样小文件就不会因大文件的频繁变动而被从缓存中移除。<br>
至于什么是小文件，这个由应用来区分，在创建image request, 设置 ImageType 即可:<br>
ImageRequest request = ImageRequest.newBuilderWithSourceUri(uri)<br>
.setImageType(ImageType.SMALL)</p>
<p>如果你仅仅需要一个缓存，那么不调用setSmallImageDiskCacheConfig即可。Image pipeline 默认会使用同一个缓存，同时ImageType也会被忽略。</p>
<p>2）实现方法：</p>
<pre><code>配置
DiskCacheConfig diskCacheConfig = DiskCacheConfig.newBuilder()            
.setBaseDirectoryName()//设置主缓存目录文件名
.setBaseDirectoryPath()//设置主缓存目录根目录
.setMaxCacheSize()//设置主缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置主缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置主缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();
DiskCacheConfig smallDiskCacheConfig = DiskCacheConfig.newBuilder()
.setBaseDirectoryName()//设置次缓存目录文件名
.setBaseDirectoryPath()//设置次缓存目录根目录
.setMaxCacheSize()//设置次缓存文件夹最大缓存数
.setMaxCacheSizeOnLowDiskSpace()//设置次缓存文件夹当磁盘空间低时的最大的最大缓存值
.setMaxCacheSizeOnVeryLowDiskSpace()//设置次缓存文件夹当磁盘剩余空间极低时的最大缓存值
.build();

ImagePipelineConfig pipelineConfig = ImagePipelineConfig.newBuilder(mContext)
.setSmallImageDiskCacheConfig(smallDiskCacheConfig)//磁盘缓存配置，存储首页图片的配置（总，三级缓存）
.setMainDiskCacheConfig(diskCacheConfig)//磁盘缓存配置（总，三级缓存）
.setCacheKeyFactory(new CdnAwareCacheKeyFactory())//uri匹配策略，目前只匹配path，就是为了避免cdn图片会多次请求
.build();
</code></pre>
<p>自定义WubaDraweeView控件中添加缓存到次缓存目录的方法；</p>
<pre><code>public void setSmallDiskImageURI(Uri uri){
ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)
.setImageType(ImageRequest.ImageType.SMALL)
.build();
DraweeController controller = FrescoWubaCore.newDraweeControllerBuilder()
.setImageRequest(request)
.setOldController(getController())
.build();
setController(controller);
}
</code></pre>
<p>对于需要不经常变动需要长时间保存的可以使用以上方法；<br>
目前ImageRequest.ImageType只支持两种，以下是fresco源码，Default是默认的回放入DiskCacheConfig，根据类型选择disk缓存策略，源码：</p>
<pre><code>/**    * An enum describing type of the image.
*/
public enum ImageType {
/* Indicates that this image should go in the small disk cache, if one is being used */
SMALL,

/* Default */
DEFAULT,
}

public void produceResults(
final Consumer&lt;EncodedImage&gt; consumer,
final ProducerContext producerContext) {
ImageRequest imageRequest = producerContext.getImageRequest();
if (!imageRequest.isDiskCacheEnabled()) {
maybeStartInputProducer(consumer, consumer, producerContext);
return;
}

producerContext.getListener().onProducerStart(producerContext.getId(), PRODUCER_NAME);

final CacheKey cacheKey =
    mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());
boolean isSmallRequest = (imageRequest.getImageType() == ImageRequest.ImageType.SMALL);
final BufferedDiskCache preferredCache = isSmallRequest ?
    mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;//根据类型选择disk缓存；
</code></pre>
<p>......</p>
<p>##如何获取本地缓存路径？<br>
有时我们将需要fresco已加载的图片的本地路径获取到，然后对本地路径作处理，获取方法：<br>
1）判断图片的uri是否已缓存；</p>
<pre><code>/**
* 判断是否已缓存本地
* @param loadUri
* @return
*/
private boolean isDownloaded(Uri loadUri) {
    if (loadUri == null) {
        return false;
    }
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    return ImagePipelineFactory.getInstance()
            .getMainFileCache().hasKey(cacheKey);
}
</code></pre>
<p>2）如果已缓存可获取本地路径</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>/**
* 根据uri获取本地缓存路径
* @param loadUri
* @return
*/
private String getPath(Uri loadUri){
    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(loadUri)
            .build();
    CacheKey cacheKey = new CdnAwareCacheKeyFactory()
            .getEncodedCacheKey(imageRequest);
    BinaryResource resource = ImagePipelineFactory.getInstance()
            .getMainFileCache().getResource(cacheKey);
    File file=((FileBinaryResource)resource).getFile();
    return file.getPath();
}
</code></pre>
<p>看一下cachkey的中标规则，hasKey(cacheKey)的源码：</p>
<pre><code>@Override
public boolean hasKey(final CacheKey key) {
synchronized (mLock) {
    if (hasKeySync(key)) {
    return true;
    }
    try {
    String resourceId = null;
    boolean retval = false;
    if (mIndex.containsKey(key)) {
        resourceId = mIndex.get(key);
        retval = mStorage.contains(resourceId, key);
    } else {
        List&lt;String&gt; resourceIds = getResourceIds(key);
        for (int i = 0; i &lt; resourceIds.size(); i++) {
        resourceId = resourceIds.get(i);
        retval = mStorage.contains(resourceId, key);
        if (retval) {
            break;
        }
        }
    }
    if (retval) {
        mIndex.put(key, resourceId);
    } else {
        mIndex.remove(key);
    }
    return retval;
    } catch (IOException e) {
    return false;
    }
}
}
@VisibleForTesting
static List&lt;String&gt; getResourceIds(final CacheKey key) {
try {
    final List&lt;String&gt; ids;
    if (key instanceof MultiCacheKey) {
    List&lt;CacheKey&gt; keys = ((MultiCacheKey) key).getCacheKeys();
    ids = new ArrayList&lt;&gt;(keys.size());
    for (int i = 0; i &lt; keys.size(); i++) {
        ids.add(SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;)));
    }
    } else {
    ids = new ArrayList&lt;&gt;(1);
    ids.add(SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes(&quot;UTF-8&quot;)));
    }
    return ids;
} catch (UnsupportedEncodingException e) {
    // This should never happen. All VMs support UTF-8
    throw new RuntimeException(e);
}
}

public static String makeSHA1HashBase64(byte[] bytes) {
try {
    MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);
    md.update(bytes, 0, bytes.length);
    byte[] sha1hash = md.digest();
    return Base64.encodeToString(sha1hash, Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP);
} catch (NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
}
}
</code></pre>
<p>可以看出CachKey的匹配规则时，调用SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes(&quot;UTF-8&quot;))用UTF－8对CachKey的toString值encode，然后用SHA-1算法加密获取摘要，再用Base64 encode成字符串来进行比较的，所以关键方法时CachKey的toString方法，一切操作都是基于这个方法生成的；</p>
<p>##为降低OOM风险，我们应该向下采样Downsampling，设置setResizeOptions</p>
<p>###向下采样如何配置；<br>
向下采样是一个正在实验中的特性。使用的话需要在设置 image pipeline 时进行设置：<br>
.setDownsampleEnabled(true)<br>
如果开启该选项，pipeline 会向下采样你的图片， 同时需要设置setResizeOptions 。<br>
如果不开启该项，设置setResizeOptions，只有JPEG图片格式才起作用；<br>
向下采样在大部分情况下比 resize 更快。除了支持 JPEG 图片，它还支持 PNG 和 WebP(除动画外) 图片；</p>
<p>###自定义向下采样的方法；</p>
<pre><code>/**
* 根据图片的uri、屏幕要显示图片的宽高来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeWidth 图片要显示的宽 单位px
* @param resizeHeight 图片要显示的高 单位px
* @param uri 图片的uri
*
*/
public void setResizeOptionsImageURI(@Nullable Uri uri,int resizeWidth,int resizeHeight){
    LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeWidth=&quot;+resizeWidth+&quot;,resizeHeight=&quot;+resizeHeight);
    ImageRequest imageRequest = null;
    if (uri == null){
        LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == uri is null&quot;);
    }else {
        ResizeOptions options = null;
        if (resizeHeight&gt;0&amp;&amp;resizeWidth&gt;0) {
            options = new ResizeOptions(resizeWidth, resizeHeight);
        }else{
            LOGGER.d(DefaultConfigCentre.DEFAULT_TAG,&quot;WubaDraweeView:setResizeOptionsImageURI == resizeHeight &lt; 0 or resizeWidth &lt; 0&quot;);
        }
        imageRequest = ImageRequestBuilder.newBuilderWithSource(uri)
                .setResizeOptions(options)
                .build();
    }
    setControllerWithParams(imageRequest,null);
}
/**
* 根据图片的uri、屏幕要显示图片采样类型的来加载图片
* 为的是根据实际显示尺寸来加载图片
* @param resizeOptionsType 图片采样类型，DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE/MIDDLE_TYPE/BIG_TYPE；
* @param uri 图片的uri
*
*/
public void setResizeOptionsTypeImageURI(Uri uri,int resizeOptionsType){
    setResizeOptionsImageURI(uri, WubaResizeOptionsUtil.getNewResizeOptionsByType(resizeOptionsType));
}
</code></pre>
<p>###自定义向下采样的类型有三种，大中小；<br>
根据项目中使用图片宽高频率较多的情况分为三种：</p>
<pre><code>/**
* 根据图片的采样类型获取ResizeOptions对象；
* @param resizeOptionsType 图片的采样类型
*/
public static ResizeOptions getNewResizeOptionsByType(int resizeOptionsType){
    int width = 0;
    int height = 0;
    switch (resizeOptionsType){
        case DefaultConfigCentre.ResizeOptionsType.SMALL_TYPE:
            width = 200;
            height = 150;
            break;
        case DefaultConfigCentre.ResizeOptionsType.MIDDLE_TYPE:
            width = 360;
            height = 300;
            break;
        case DefaultConfigCentre.ResizeOptionsType.BIG_TYPE:
            width = 720;
            height = 600;
            break;
        default:
            checkResizeOptionsType(resizeOptionsType);
            break;

    }
    return new ResizeOptions(width,height);
}
</code></pre>
<p>###默认向下采样类型；<br>
如果我们不设置向下采样的类型，那默认我们会采用DefaultConfigCentre.ResizeOptionsType.BIG_TYPE，是为了预防图片太大，我们默认处理造成OOM的情况；</p>
<pre><code>@Override
public void setImageURI(Uri uri, @Nullable Object callerContext) {
    setResizeOptionsTypeImageURI(uri,DefaultConfigCentre.ResizeOptionsType.BIG_TYPE);
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java知识体系之-泛型与泛型擦除]]></title>
        <id>https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu/</id>
        <link href="https://Mozziehh.github.io/post/java-zhi-shi-ti-xi-zhi-fan-xing-yu/">
        </link>
        <updated>2019-12-06T05:59:36.000Z</updated>
        <content type="html"><![CDATA[<p>#Java泛型与进阶<br>
##什么是泛型<br>
泛型是Java中一种常用的用于解决编译期间的类型转换异常的方式，防止在运行期间出现classCastException。</p>
<p>代码如下：</p>
<pre><code>public class GlmapperGeneric&lt;T&gt; {
		private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
  
    public static void main(String[] args) {
        // do nothing
    }

  /**
    * 不指定类型
    */
  public void noSpecifyType(){
    GlmapperGeneric glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 需要强制类型转换
    String test = (String) glmapperGeneric.get();
    System.out.println(test);
  }

  /**
    * 指定类型
    */
  public void specifyType(){
    GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric();
    glmapperGeneric.set(&quot;test&quot;);
    // 不需要强制类型转换
    String test = glmapperGeneric.get();
    System.out.println(test);
  }
}
</code></pre>
<p>##泛型中的通配符<br>
在泛型中，通常使用的通配符有如下几种：T，E，K，V ？ ，这些符号你可以自己指定，但是为了更好的理解，我们通常使用上述作为默认规则。<br>
T：代表指定的Java类型；<br>
E：代表Element；<br>
K和V：用于在Map中存储的key-value；<br>
？：代表不确定的Java类型；</p>
<p>###？通配符<br>
我们先来看一个例子：List&lt;? extend Animals&gt; list = new List();<br>
此时，它表示的意思就是我们的这个list可以传递的就是继承了Animals的子类；</p>
<p>###上届通配符<br>
所谓的上届通配符就是&lt; ? extends E&gt;，代表的意思是传递任意一个E本身或者E的子类都OK。<br>
###下届通配符<br>
所谓的下届通配符就是&lt; ? super E&gt;，代表的意思是传递任意一个是E本身或者E的父类都OK。</p>
<pre><code>private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src){
    for (T t : src) {
        dst.add(t);
    }
}

public static void main(String[] args) {
    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();
    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();
    new Test3().test(animals,dogs);
}
// Dog 是 Animal 的子类
class Dog extends Animal {

}
</code></pre>
<p>###？和T的区别<br>
从字面的意思上来看：？代表的是非指定的任意Java类，T代表的是指定的Java类，T只可以继承某个类，而？可以标识父类或者子类：? extend A , ? super A。</p>
<p>##泛型擦除</p>
<pre><code>// 指定泛型为String

List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
// 指定泛型为Integer
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();

System.out.println(list1.getClass() == list2.getClass()); // true
</code></pre>
<p>在编译时，对于这些已经指定过的泛型，编译器会将它们都清除掉，这样的操作我们叫做泛型擦除。<br>
规则：如果我们给泛型指定了上届，那么在擦除之后，它会指定到上届。否则，它将指定到Object。</p>
<p>##参考地址</p>
<p>https://juejin.im/post/5d5789d26fb9a06ad0056bd9</p>
<p>https://juejin.im/post/5ceba1a2f265da1b95703558</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-线程池[转]]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan/</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-xian-cheng-chi-zhuan/">
        </link>
        <updated>2019-12-05T12:46:45.000Z</updated>
        <content type="html"><![CDATA[<p>#线程池概念<br>
线程池： 简单理解，它就是一个管理线程的池子。</p>
<p>#带着问题看文章<br>
问题1：Java的线程池说一下，各个参数的作用，如何进行的?<br>
问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。<br>
问题3：线程池都有哪几种工作队列？<br>
问题4：使用无界队列的线程池会导致内存飙升吗？<br>
问题5：说说几种常见的线程池及使用场景?</p>
<p>#线程池的优点<br>
·它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗：<br>
因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。<br>
·提高响应速度：<br>
如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。<br>
·重复利用：<br>
线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
<p>#线程池的创建<br>
线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue&lt;Runnable&gt; workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) 
</code></pre>
<p>corePoolSize： 线程池核心线程数最大值<br>
maximumPoolSize： 线程池最大线程数大小<br>
keepAliveTime： 线程池中非核心线程空闲的存活时间大小<br>
unit： 线程空闲存活时间单位<br>
workQueue： 存放任务的阻塞队列<br>
threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。<br>
handler：  线城池的饱和策略事件，主要有四种类型。</p>
<p>#任务执行<br>
线程池执行流程，即对应execute()方法：<br>
<img src="https://Mozziehh.github.io/post-images/1575550465980.png" alt="" loading="lazy"></p>
<p>·提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。<br>
·如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。<br>
·当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达·到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。<br>
·如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p>
<p>#四种拒绝策略<br>
·AbortPolicy(抛出一个异常，默认的)<br>
·DiscardPolicy(直接丢弃任务)<br>
·DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）<br>
·CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p>
<p>#为了形象描述线程池执行，我打个比喻：</p>
<p>·核心线程比作公司正式员工<br>
·非核心线程比作外包员工<br>
·阻塞队列比作需求池<br>
·提交任务比作提需求</p>
<figure data-type="image" tabindex="1"><img src="https://Mozziehh.github.io/post-images/1575550700308.png" alt="" loading="lazy"></figure>
<p>·当产品提个需求，正式员工（核心线程）先接需求（执行任务）<br>
·如果正式员工都有需求在做，(即核心线程数已满），产品就把需求先放需求池（阻塞队列）。<br>
·如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。<br>
·如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。<br>
·如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</p>
<p>##问题1 Java的线程池说一下，各个参数的作用，如何进行的?</p>
<p>答案：线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</p>
<p>#线程池异常处理</p>
<p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<p>#线程池exec.submit(runnable)的执行流程</p>
<p>通过debug上面有异常的submit方法（建议大家也去debug看一下,图上的每个方法内部是我打断点的地方），处理有异常submit方法的主要执行流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://Mozziehh.github.io/post-images/1575551509586.png" alt="" loading="lazy"></figure>
<p>#线程池的工作队列<br>
##线程池都有哪几种工作队列？</p>
<p>·ArrayBlockingQueue:（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<p>·LinkedBlockingQueue:（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p>
<p>·DelayQueue:是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<p>·PriorityBlockingQueue:（优先级队列）是具有优先级的无界阻塞队列；</p>
<p>·SynchronousQueue:（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，</p>
<p>·newCachedThreadPool线程池使用了这个队列。</p>
<p>#几种常用的线程池</p>
<p>##newFixedThreadPool (固定数目线程的线程池)<br>
##newCachedThreadPool(可缓存线程的线程池)<br>
##newSingleThreadExecutor(单线程的线程池)<br>
##newScheduledThreadPool(定时及周期执行的线程池)</p>
<p>##newFixedThreadPool<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory);
    }
</code></pre>
<p>###线程池特点：<br>
核心线程数和最大线程数大小一样<br>
没有所谓的非空闲时间，即keepAliveTime为0<br>
阻塞队列为无界队列LinkedBlockingQueue</p>
<p>####工作机制：<br>
<img src="https://Mozziehh.github.io/post-images/1575555765273.png" alt="" loading="lazy"></p>
<p>####提交任务<br>
如果线程数少于核心线程，创建核心线程执行任务<br>
如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列<br>
如果线程执行完任务，去阻塞队列取任务，继续执行。</p>
<p>####实例代码</p>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);
                for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
                    executor.execute(()-&gt;{
                        try {
                            Thread.sleep(10000);
                        } catch (InterruptedException e) {
                            //do nothing
                        }
        });
</code></pre>
<p>####使用场景<br>
FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<p>###newCachedThreadPool</p>
<p>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {<br>
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>
60L, TimeUnit.SECONDS,<br>
new SynchronousQueue<Runnable>(),<br>
threadFactory);<br>
}<br>
####线程池特点：<br>
核心线程数为0<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是SynchronousQueue<br>
非核心线程空闲存活时间为60秒</p>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。<br>
工作机制<br>
<img src="https://Mozziehh.github.io/post-images/1575555947765.png" alt="" loading="lazy"></p>
<p>####提交任务<br>
因为没有核心线程，所以任务直接加到SynchronousQueue队列。<br>
判断是否有空闲线程，如果有，就去取出任务执行。<br>
如果没有空闲线程，就新建一个线程执行。<br>
执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newCachedThreadPool();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
用于并发执行大量短期的小任务。</p>
<p>###newSingleThreadExecutor</p>
<p>public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {<br>
return new FinalizableDelegatedExecutorService<br>
(new ThreadPoolExecutor(1, 1,<br>
0L, TimeUnit.MILLISECONDS,<br>
new LinkedBlockingQueue<Runnable>(),<br>
threadFactory));<br>
}<br>
####线程池特点</p>
<p>核心线程数为1<br>
最大线程数也为1<br>
阻塞队列是LinkedBlockingQueue<br>
keepAliveTime为0</p>
<p>####工作机制</p>
<p>####提交任务<br>
线程池是否有一条线程在，如果没有，新建线程执行任务<br>
如果有，讲任务加到阻塞队列<br>
当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</p>
<p>####实例代码<br>
ExecutorService executor = Executors.newSingleThreadExecutor();<br>
for (int i = 0; i &lt; 5; i++) {<br>
executor.execute(() -&gt; {<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
});<br>
}</p>
<p>####使用场景<br>
适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<p>###newScheduledThreadPool</p>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
</code></pre>
<p>####线程池特点<br>
最大线程数为Integer.MAX_VALUE<br>
阻塞队列是DelayedWorkQueue<br>
keepAliveTime为0<br>
scheduleAtFixedRate() ：按某种速率周期执行<br>
scheduleWithFixedDelay()：在某个延迟后执行</p>
<p>####工作机制<br>
添加一个任务<br>
线程池中的线程从 DelayQueue 中取任务<br>
线程从 DelayQueue 中获取 time 大于等于当前时间的task<br>
执行完后修改这个 task 的 time 为下次被执行的时间<br>
这个 task 放回DelayQueue队列中</p>
<p>####实例代码<br>
/**<br>
创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间<br>
*/<br>
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);<br>
scheduledExecutorService.scheduleWithFixedDelay(()-&gt;{<br>
System.out.println(&quot;current Time&quot; + System.currentTimeMillis());<br>
System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);<br>
}, 1, 3, TimeUnit.SECONDS);</p>
<p>####运行结果：</p>
<pre><code>/**
创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) 
*/
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
        System.out.println(&quot;current Time&quot; + System.currentTimeMillis());
        System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
    }, 1, 3, TimeUnit.SECONDS);;
</code></pre>
<p>####使用场景<br>
周期性执行任务的场景，需要限制线程数量的场景</p>
<p>##线程池状态<br>
线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。<br>
//线程池状态<br>
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;<br>
复制代码线程池各个状态切换图：<br>
<img src="https://Mozziehh.github.io/post-images/1575556444104.png" alt="" loading="lazy"></p>
<p>###RUNNING</p>
<p>该状态的线程池会接收新任务，并处理阻塞队列中的任务;<br>
调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;<br>
调用线程池的shutdownNow()方法，可以切换到STOP状态;</p>
<p>###SHUTDOWN</p>
<p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>
队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</p>
<p>###STOP</p>
<p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>
线程池中执行的任务为空,进入TIDYING状态;</p>
<p>###TIDYING</p>
<p>该状态表明所有的任务已经运行终止，记录的任务数量为0。<br>
terminated()执行完毕，进入TERMINATED状态</p>
<p>###TERMINATED</p>
<p>该状态表示线程池彻底终止</p>
<p>作者：Jay_huaxiao<br>
链接：https://juejin.im/post/5d1882b1f265da1ba84aa676</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android源码阅读系列之-Handler]]></title>
        <id>https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler/</id>
        <link href="https://Mozziehh.github.io/post/android-yuan-ma-yue-du-xi-lie-zhi-handler/">
        </link>
        <updated>2019-12-05T07:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>##概述<br>
工作中，我们经常遇到多线程用来处理耗时任务，因为主线程中操作很容易引起ANR。于是在Android中使用Handler进行异步的消息处理，处理完成后将再返回给UI线程执行后续逻辑。</p>
<p>##带着问题去看文章</p>
<p>Q1：子线程可以更新UI么，为什么？</p>
<p>Q2：一个Thread可以有几个Looper？几个Handler？</p>
<p>Q3：可以在子线程直接new一个Handler吗？该怎么做？</p>
<p>Q4：Message的创建方法有几种？哪种效果更好，为什么？</p>
<p>Q5：主线程中Looper的轮询死循环为何没有阻塞主线程？</p>
<p>Q6：使用Hanlder的postDealy()后消息队列会发生什么变化？</p>
<p>Q7：点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>Q8：Handler是如何完成子线程和主线程通信的？</p>
<p>Q9：关于ThreadLocal，谈谈你的理解？</p>
<p>Q10：生产者-消费者设计模式？</p>
<p>Q11：享元设计模式？</p>
<p>Q12：Thread两次调用start()方法会发生问题么？</p>
<p>Q13：开启三个线程，循环打印出1到100；<br>
T1：1,4,7....  T2:2,5,8.....  T3:3,6,9....</p>
<p>上述这十三个问题，如果你能清晰透彻的了解，那么你大可关闭这篇文章~</p>
<p>##常见用法</p>
<pre><code>//处理
private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MESSAGE_TEXT_VIEW:
                    mTextView.setText(&quot;UI成功更新&quot;);
                default:
                    super.handleMessage(msg);
            }
        }
};

//调用
new Thread(new Runnable() {
            @Override
            public void run() {
				mHandler.obtainMessage(MESSAGE_TEXT_VIEW).sendToTarget();
            }
        }).start();
</code></pre>
<p>##Handler的构造方法<br>
我们先来剖析一下Handler的构造方法：</p>
<pre><code>public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre>
<p>在构造方法里面，我们看到通过Looper.myLooper()去获取当前Hander的looper，发现获取不到，于是触发异常：&quot;Can't create handler inside thread that has not called Looper.prepare()&quot;，它的意思就是不能在没有得到looper的情况下，就使用handler。但是，我们发现在实际的使用过程中，我们并没有调用Looper.prepare()方法，也没有事，其实是主线程已经帮我们调用，让我们看一下如下的代码：</p>
<p>在ActivityThread中的main方法，它主要做了两个事情：一个准备mainLooper，一个是通过loop()方法创建一个looper：</p>
<pre><code>public static void main(String[] args) {
    ...

    Looper.prepareMainLooper();

    ...
    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre>
<p>在得到looper之后，又通过looper获取了消息队列，这个消息队列其实是一个消息链表，它里面存储的就是Message，即消息。</p>
<p>然后我们再来看一下这个Looper.prepareMainLooper（）</p>
<pre><code>public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre>
<p>所以说，ActivityThread在启动的过程中就创建了looper和messageQueue。</p>
<p>##Looper<br>
接下来，我们看一下Looper.prepare()方法里面都做了什么？</p>
<pre><code>static final ThreadLocal sThreadLocal = new ThreadLocal();

public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
</code></pre>
<p>我们看到，它是在ThreadLocal中存储了对应的Looper对象；我们看到ThreadLocal是被static和final同时修饰，所以，它是不可以被继承的并且全局静态的。所以，它只存在一份。</p>
<pre><code>private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<p>所以，这里我们看到，当我们多次调用prepare的时候，就会报错：&quot;Only one Looper may be created per thread&quot;	，意思是：每一个线程有且只有一个Looper。</p>
<p>那么，这个Looper里面都有什么呢？</p>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>首先Looper会定义一个消息链表，然后获取Handler当前的线程。<br>
Looper的最主要作用：开启消息循环机制，不断从MessageQueue里面获取Message，然后调用msg.target.dispatchMessage将消息分发出去。</p>
<p>接下来，我们去看一下Loop()方法：</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    
    //无限循环，这里可以思考一下，为什么不会阻塞主线程
    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;+ Long.toHexString(ident) + &quot; to 0x&quot;+ Long.toHexString(newIdent) + &quot; while dispatching to &quot;+ msg.target.getClass().getName() + &quot; &quot;+ msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre>
<p>#消息的发送<br>
发送消息，我们调用的是obtainMessage，然后sendtoTarget();在obtainMessage中我们获取的是Message.obtain()方法：</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>这是一个静态的方法，使用了同步锁，获取消息，同时把自己清空掉，放在链表头；然后，sendToTarget负责发送消息，最终调用的是sendMessageAtTime(Message msg, long uptimeMillis)</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<p>首先，获取消息链表，然后把消息入链表。</p>
<p>##消息的处理</p>
<p>刚才我们说过，我们调用的是msg.target.dispatchMessage，这个msg.target获取的就是handler。然后我们来看一下dispatchMessage都做了什么？</p>
<pre><code>public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>
<p>这个时候我们可以看到，当我们没有给Message设置callback或者没有设置全局的callback的时候，它会默认的调用handleMessage(msg);这个时候，我们自己的handler就接收到了这个handleMessage。</p>
<p>##问题回顾</p>
<p>###子线程可以更新UI么，为什么？<br>
子线程更新UI要分两种情况，一种是在onCreate里面，一种是在onResume里面。onCreate里面调用没事（如果不sleep()的话），在onResume里面调用就会发生异常：&quot;Only the original thread that created a view hierarchy can touch its views.&quot;，根本原因是在Activity初始化的时候，使用WindowManagerGlobal的addView方法，构造出ViewRootImpl，然后使用ViewRootImpl来判断是否在子线程中，而它的创建是在onResume方法里面进行回调的。</p>
<p>###一个Thread可以有几个Looper？几个Handler？<br>
一个Looper，因为调用Looper.prepare()会得到一个looper，多次调用会报错。一个Thread里面可以有多个Handler，通过msg.target进行关联。</p>
<p>###可以在子线程直接new一个Handler吗？该怎么做？<br>
我们正常是不会调用Looper.prepare()方法的，是主线程帮我们调用的。但是假如我们在Thread里面创建了一个Handler的时候，你会发现这个Handler直接在构造函数的时候就会报错。所以解决办法是：在new Handler之前，手动给它创建一个looper，也就是Looper.prepare()；</p>
<p>###Message的创建方法有几种？哪种效果更好，为什么？<br>
三种，new Message(), Message.obtain(), mHandler.obtainMessage()<br>
第一种就是直接创建，后两种是从消息链表里面取Message，使用了享元模式。</p>
<pre><code>public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</code></pre>
<p>###主线程中Looper的轮询死循环为何没有阻塞主线程？<br>
android的UI线程本质上就是一个轮训机制，你可以理解如果没有这个循环，那么将无法监听用户的时间，无法响应UI。</p>
<p>###使用Hanlder的postDealy()后消息队列会发生什么变化？假如这个时候再来一条延迟消息Handler应该怎么处理？</p>
<p>MessageQueue里面调用nativePollOnce方法来停止阻塞线程，阻塞的时间根据msg.when与now的差值来计算应该阻塞多长时间，如果再来一条非延迟消息，会将当前时间清空，直接执行，如果再来一条延迟消息，会计算当前时间与上一个时间比较，然后执行短的那个。</p>
<pre><code>int nextPollTimeoutMillis = 0;
for(;;) {
    if (nextPollTimeoutMillis != 0) {
        Binder.flushPendingCommands();
    }
 
    nativePollOnce(ptr, nextPollTimeoutMillis);
 
    synchronized (this) {
        // Try to retrieve the next message.  Return if found.
        final long now = SystemClock.uptimeMillis();
        Message prevMsg = null;
        Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            // Stalled by a barrier.  Find the next asynchronous message in the queue.
            do {
                prevMsg = msg;
                msg = msg.next;
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        if (msg != null) {
            if (now &lt; msg.when) {
                // Next message is not ready.  Set a timeout to wake up when it is ready.
                nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
            } else {
                // Got a message.
                mBlocked = false;
                if (prevMsg != null) {
                    prevMsg.next = msg.next;
                } else {
                    mMessages = msg.next;
                }
                msg.next = null;
                if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                msg.markInUse();
                return msg;
            }
        } else {
            // No more messages.
            nextPollTimeoutMillis = -1;
        }
        ...
    }
    nextPollTimeoutMillis = 0;
</code></pre>
<p>###点击页面上的按钮后更新TextView的内容，谈谈你的理解？</p>
<p>###Handler是如何完成子线程和主线程通信的？<br>
见消息的处理</p>
<p>###关于ThreadLocal，谈谈你的理解？</p>
<p>static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();</p>
<p>Thread相当于是简单了实现了一个HashMap，key对应的是每一个线程，value对应它的looper。为啥不用HashMap？因为HashMap里面有很多功能是不需要的，所以单独实现了一个。</p>
<p>###生产者-消费者设计模式？<br>
一个用于生产，一个用于消费，生产者将事件丢进缓冲区，缓冲区满则不继续生产，消费者去消费缓冲区的事件，如果缓冲区空就不消费，并且会通知生产者去生产，同时，生产者生产完成后，要通知消费者去消费。</p>
<p>###Thread两次调用start()方法会发生问题么？</p>
<p>线程首先会运行一次，然后抛出java.lang.IllegalThreadStateException<br>
异常。</p>
<pre><code>if (threadStatus != 0 || started)
            throw new IllegalThreadStateException();
</code></pre>
<p>###使用三个线程顺序打印1到100<br>
使用wait和notifyAll，然后利用同步锁volatile将loackNum加锁，利用synchronized对object加锁，实现同步。</p>
<pre><code>static volatile int loackNum = 1;
static Object object = new Object();
public static void main(String args[]){
    final Thread thread1 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 1) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        }
    });
    Thread thread2 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 2) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    Thread thread3 = new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (object){
                while (loackNum &lt;= 100) {
                    if (loackNum % 3 == 0) {
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + loackNum++);
                    }
                    object.notifyAll();
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });
    thread1.start();
    thread2.start();
    thread3.start();
}
</code></pre>
<p>#总结<br>
Handler负责发送消息和处理消息，Message就是那个消息，通过obtain方法获取消息队列，使用sendMessage将消息入队列。最终通过Looper.loop()方法中的无限循环去dispatchMessage回调到Handler里面。</p>
<p>参考：</p>
<p>https://juejin.im/entry/5708b3c38ac247004c1deef7</p>
<p>https://blog.csdn.net/songzi1228/article/details/82835982</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GifView在android的应用指南]]></title>
        <id>https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan/</id>
        <link href="https://Mozziehh.github.io/post/gifview-zai-android-de-ying-yong-zhi-nan/">
        </link>
        <updated>2019-11-22T00:48:04.000Z</updated>
        <content type="html"><![CDATA[<p>##背景<br>
目前，大部分市场应用在展示产品的时候都会选择图片配文字的形式，显得更加直观。随着人们手机设备性能的提高与Wifi以及4G网络的提速，为了能让用户的体验更加立体，很多APP在”秀“自己的产品的时候都会直接展示视频。然而图片和视频之间还是有一定的流量差距，为了让用户可以更好的过渡这一差距，图片展示gifview，点击gifview观看视频这样的用户行为正在慢慢的被接受。</p>
<p>##部落来袭<br>
58部落目前是非常大的用户群体，他们也会经常发表一些自己的作品，看法，目前也是列表页展示图片，点击进入后展示详情。那么如果需要有这个过渡，就需要在列表页上增加gifview来达到更好的曝光率。</p>
<p>##大众点评&amp;马蜂窝</p>
<p>###点评 &amp; 马蜂窝 效果展示</p>
<!--todo-->
<p>###效果分析<br>
我们先来自己想想，如果要是我们自己来实现这个效果应该如何来做：</p>
<p>两种方法：</p>
<p><em><strong>方案一：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义GifView，包含展示静态图和gif图的功能；</p>
<p>3.进入页面，请求首页，获取json得到gif；</p>
<p>4.解析gif的第一帧，得到Image的比特流，让GifView展示图片；</p>
<p>5.图片展示完成后，自定义GifView播放GifView；</p>
<hr>
<p>优点：</p>
<p>简化json输出，json里面的返回值返回一套gif就可以，自己解析gif的第一帧用于展示图片；</p>
<p>缺点：</p>
<p>速度慢，本来列表页快速滑动展示大图片都考虑加载时间，如果再去自己解析，成本太高，内存要求大；</p>
<hr>
<p><em><strong>方案二：</strong></em></p>
<!--todo-->
<p>1.使用recyclerview实现列表页用于展示；</p>
<p>2.自定义ImageView，展示Image；</p>
<p>3.自定义GifView，展示gif图；</p>
<p>4.进入页面，请求首页，获取json得到image和gif；</p>
<p>5.自定义ImageView展示imageview占位，然后紧接着加载gif；</p>
<p>优点：</p>
<p>1.速度快；</p>
<p>2.解耦，一旦出现问题，可以快速降级；</p>
<hr>
<p>另外，从版本的迭代的上来考虑，我个人更倾向于方案二：</p>
<p>###点评效果深入研究<br>
接下来，先上常规操作让我们看一下大众点评是不是酱样婶的吧：</p>
<p>####dump一下，你不知道<br>
Running activities (most recent first):<br>
Run #1: ActivityRecord{1b8520 u0 com.dianping.v1/.NovaMainActivity t15792}<br>
Run #0: ActivityRecord{2a47964 u0 com.tencent.mm/.ui.LauncherUI t15793}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{945d44 u0 com.miui.home/.launcher.Launcher t1}<br>
Running activities (most recent first):<br>
Run #0: ActivityRecord{52d96ba u0 com.android.systemui/.recents.RecentsActivity t15788}<br>
ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)<br>
User #0: state=RUNNING_UNLOCKED</p>
<p>首先，我们来看一下dump信息，NovaMainActivity，是它的首页，但是显然根据这个我们没有任何头绪。正向查一个控件我们要知道哪个布局，哪个控件，哪个View。所以，我想能不能看看Log，结果还真的让我找到了蛛丝马迹。</p>
<p>####logcat<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been stoped:<br>
2019-09-14 10:59:54.304 31909-31909/? D/GifImageView: gifIv has already been started:</p>
<p>在我快速滑动的时候，我发现居然有这么些可爱的代码在控制台打印出来。于是，我就看到了新的曙光。</p>
<p>万幸的是，我还在logcat里面额外看到了webp格式的图片和动图的日志：</p>
<pre><code>//动图
https://img.xxx.net/coverpic/2d348f2ea08616ab1e8c652800373740.webp
//非动图
https://img.xxx.net/coverpic/4cf4cfa5469f95444986f83f194f6acb35706.jpg%40320w_426h_1e_1c_1l%7Cwatermark%3D0.webp
</code></pre>
<p>这个日志初步印证了我的想法，我决定看一下&quot;GifImageVIew&quot;都干了啥。点评是有混淆和做了加壳的，常规的jd-gui查看的代码看不到。通过脱壳，获取其相关代码，为了更好地理解，里面的关键代码做了注释：</p>
<pre><code>public class GifImageView extends FrameLayout {

    public GifImageView(Context context) {
        super(context);
    }
    public static final String TAG = &quot;GifImageView&quot;;
    public PicassoImageView gifImageView; //Picasso 
    private String gifIvGroup;
    private double gifPriority; //gif的优先级
    private String gifUrl; //gif的url
    public PicassoImageView imageView;  //又来一个Picasso

	 //构造函数
    public GifImageView(Context context) {
        this(context, null);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet) {
        this(context, attributeSet, 0);
    }

    //构造函数
    public GifImageView(Context context, AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
        init(context);
    }
    
    //初始化 *关键*
    private void init(Context context) {
        LayoutParams layoutParams = new FrameLayout.LayoutParams(-1, -1);
        this.imageView = new PicassoImageView(context);
        this.gifImageView = new PicassoImageView(context);
        this.gifImageView.setFadeInDisplayEnabled(false);
        addView(this.gifImageView, layoutParams);
        addView(this.imageView, layoutParams);
        //开始进行gif加载的设置
        this.gifImageView.setOnLoadChangeListener(new u() {

            //gif加载开始
            public void onImageLoadStart() {
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
  
            //gif加载完成
            public void onImageLoadSuccess(Bitmap bitmap) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif success : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.GONE);
            }
  
            //加载失败如何处理
            public void onImageLoadFailed() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(&quot;load gif failed : &quot;);
                stringBuilder.append(GifImageView.this.gifImageView.getURL());
                b.a(GifImageView.class, stringBuilder.toString());
                GifImageView.this.imageView.setVisibility(View.VISIBLE);
            }
        });
    }
    
    //设置布局
    public void setLayoutParams(LayoutParams layoutParams) {
        super.setLayoutParams(layoutParams);
        setViewParams(this.imageView, layoutParams);
        setViewParams(this.gifImageView, layoutParams);
    }


    //设置布局
    private void setViewParams(View view, LayoutParams layoutParams) {
        LayoutParams layoutParams2 = view.getLayoutParams();
        if (layoutParams2 instanceof FrameLayout.LayoutParams) {
            layoutParams2.width = layoutParams.width;
            layoutParams2.height = layoutParams.height;
            view.setLayoutParams(layoutParams2);
        }
    }


    //开始执行gif播放
    public void startGif() {
        if (this.gifImageView.isImageAnimating()) {
            Log.d(TAG, &quot;gifIv has already been started: &quot;);
        } else {
            this.gifImageView.setAnimatedImageLooping(-1);
            this.gifImageView.startImageAnimation();
            Log.d(TAG, &quot;gifIv has been started: &quot;);
        }
    }

    //停止执行gif播放
    public void stopGif() {
        if (this.gifImageView.isImageAnimating()) {
            this.gifImageView.setAnimatedImageLooping(0);
            this.gifImageView.stopImageAnimation();
            Log.d(TAG, &quot;gifIv has been stoped: &quot;);
        } else {
            Log.d(TAG, &quot;gifIv has already been stoped: &quot;);
        }
    }

    //设置image和gif图像地址
    public void setGifImage(String str, String str2) {

        this.imageView.setImage(str);
        this.gifImageView.setAnimatedImageLooping(0);
        this.gifImageView.setImage(str2);
        this.imageView.setVisibility(0);
        this.gifUrl = str2;
        if (TextUtils.isEmpty(str2)) {
            GifImageViewManager.getInstance().addGifIv(this);
        } else {
            GifImageViewManager.getInstance().removeGifIv(this);
        }
    }

    public void setAnimatedImageLooping(int i) {
        this.imageView.setAnimatedImageLooping(i);
    }

    public void setScaleType(ImageView.ScaleType scaleType) {
        this.imageView.setScaleType(scaleType);
        this.gifImageView.setScaleType(scaleType);
    }

    //支持直接设置drawable
    public void setImageDrawable(Drawable drawable) {
        this.imageView.setVisibility(0);
        this.imageView.setImageDrawable(drawable);
    }
   
   .....此处省略1000字
}
</code></pre>
<p>另外，还发现它的自定义图片PicassoImageView（好像跟git上面的Picasso没什么关系）。</p>
<pre><code>import com.dianping.imagemanager.DPImageView;
public class PicassoImageView extends DPImageView implements Clippable {
}


public class DPImageView extends ImageView implements OnClickListener {
}
</code></pre>
<p>还有。。。。咳咳，让我们点到为止吧。</p>
<p>###点评效果总结<br>
所以，点评的基本逻辑跟我之前说的第二种方案几乎无差，我们再来回顾一下：</p>
<p>1.自定义View命名为PicassoImageView，可以展示Gif图也可以展示ImageView；</p>
<p>2.封装GifImageView，里面包含两个PicassoImageView；</p>
<p>3.其中一个PicassoImageView展示imageview占位，同时另外一个PicassoImageView进行gif的加载，加载完成后，把第一个PicassoImageView消失；</p>
<p>so，感谢点评为我们提供宝贵的思路，接下来让我们去看看马蜂窝是怎么实现的吧。</p>
<p>###马蜂窝效果深入研究<br>
####dump之后依然没有有用信息<br>
也不是完全没有用，至少你知道了程序的入口在哪里。<br>
####看看logcat</p>
<pre><code>2019-09-18 16:53:11.786 25404-25919/? D/SoLoader: About to load: libgifimage.so
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so not found on /data/data/com.mfw.roadbook/lib-main
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: libgifimage.so found on /data/app/com.mfw.roadbook-U4eSwGYqvGPqtvkBe8R4gw==/lib/arm
2019-09-18 16:53:11.787 25404-25919/? D/SoLoader: Not resolving dependencies for libgifimage.so
2019-09-18 16:53:11.795 25404-25919/? D/SoLoader: Loaded: libgifimage.so
</code></pre>
<p>嗯，果然，看看还是有收获的。又Get到一个新知识，可以通过加载so（libgifimage.so）的方式，提升GifView加载速度。</p>
<p>###马蜂窝效果总结</p>
<p>在实际体验的过程中，我发现滑动到没有加载的图片时，马蜂窝会用一个加载的灰色占位图占位，然后去下载gif，它旁边的图片都展示出来了，gif还没有下载完，体验不是很好。这点可以借鉴一下大众点评的。</p>
<p>由于马蜂窝也加壳了，脱壳其实是很开(fei)心(shen)的，有了点评的思路，我就没有特别深入的研究马蜂窝的内部实现，其实直接看效果也能看出个大概。</p>
<p>##有没有开源的库呢？<br>
我们并不想把点评或者马蜂窝的代码直接拷过来，毕竟人家没有开源，而且也不一定契合我们的风格。在git上找一个demo实现以下？<br>
于是，我看到了这个android-gif-drawable，这个看起来还不错，7K的赞，Fork了1.6K，正合我意，来吧，研究一波。</p>
<p>###API解读<br>
android-gif-drawable是通过JNI来渲染帧的，比使用WebView或者Movie性能要好一些。</p>
<p><strong>依赖</strong></p>
<pre><code>dependencies {
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'
}

repositories {
	mavenCentral()
	maven { 
		url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; }
	}
	dependencies {
    i	mplementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.+'
	}

&lt;dependency&gt;
    &lt;groupId&gt;pl.droidsonroids.gif&lt;/groupId&gt;
    &lt;artifactId&gt;android-gif-drawable&lt;/artifactId&gt;
    &lt;version&gt;insert latest version here&lt;/version&gt;
    &lt;type&gt;aar&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
<p>基本使用：</p>
<pre><code>//1. asset文件
GifDrawable gifFromAssets = new GifDrawable( getAssets(), &quot;anim.gif&quot; );

//2. resource (drawable or raw)
GifDrawable gifFromResource = new GifDrawable( getResources(), R.drawable.anim );

//3. byte array
byte[] rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//4. FileDescriptor
FileDescriptor fd = new RandomAccessFile( &quot;/path/anim.gif&quot;, &quot;r&quot; ).getFD();
GifDrawable gifFromFd = new GifDrawable( fd );

//5. file path
GifDrawable gifFromPath = new GifDrawable( &quot;/path/anim.gif&quot; );

//6. file
File gifFile = new File(getFilesDir(),&quot;anim.gif&quot;);
GifDrawable gifFromFile = new GifDrawable(gifFile);

//7. AssetFileDescriptor
AssetFileDescriptor afd = getAssets().openFd( &quot;anim.gif&quot; );
GifDrawable gifFromAfd = new GifDrawable( afd );

//8. InputStream (it must support marking)
InputStream sourceIs = ...
BufferedInputStream bis = new BufferedInputStream( sourceIs, GIF_LENGTH );
GifDrawable gifFromStream = new GifDrawable( bis );

//9. direct ByteBuffer
ByteBuffer rawGifBytes = ...
GifDrawable gifFromBytes = new GifDrawable( rawGifBytes );

//10.加载网络图片其实本质上也离不开上面这些内容，推荐RxJava；
</code></pre>
<p>额外的API：</p>
<pre><code>- 停止GIF动画
·stop() 

- 开始GIF动画
·start() 

- GIf动画是否在执行
isRunning() 

- 重置GIF动画
reset() 

- 控制执行动画的速度
setSpeed(float factor) 

- 从该动画的执行位置开始执行
seekTo(int position) 

- 动画的持续时间
getDuration() 

- 当前动画的播放时间
getCurrentPosition() 
</code></pre>
<p>调用方法也是非常简单：</p>
<pre><code>&lt;pl.droidsonroids.gif.GifImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:src=&quot;@drawable/src_anim&quot;
android:background=&quot;@drawable/bg_anim&quot;
/&gt;

try {
            GifDrawable gifFromResDrawable = new GifDrawable( mContext.getResources(), getIntGifRes(imageData.gifUrl));
            viewHolder.gifImageView.setImageDrawable(gifFromResDrawable);
            viewHolder.gifImageView.setVisibility(View.VISIBLE);
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre>
<p>所以，我们看到，本质上还是这个GifDrawable在起作用，因为GifImageView继承的是ImageView。</p>
<p>###效果如下</p>
<!--todo-->
<p>##撸一个Demo<br>
我们看完了大众点评、马蜂窝、github上的实现效果。它们有自己的优点，结合58自己的技术特点，我打算采用的技术架构：FRESCO + RecyclerView的StaggeredGridLayoutManager，具体实现思路如下：</p>
<p>###使用StaggeredGridLayoutManager实现瀑布布局；</p>
<pre><code>RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);
    StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2,
            StaggeredGridLayoutManager.VERTICAL);
    recyclerView.setLayoutManager(layoutManager);

    FrescoAdapter adapter = new FrescoAdapter(this, DataUtils.getFrescoImageData());
    recyclerView.setAdapter(adapter);
</code></pre>
<p>###自定义Adapter继承自RecyclerView.Adapter，用于加载图片和GIF：</p>
<pre><code>static class ViewHolder extends RecyclerView.ViewHolder{

    SimpleDraweeView draweeImage;
    SimpleDraweeView draweeGif;
    TextView textView;
    public ViewHolder(@NonNull View itemView) {
        super(itemView);
        draweeImage = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview);
        draweeGif = (SimpleDraweeView) itemView.findViewById(R.id.item_draweeview_gif);
        textView = (TextView) itemView.findViewById(R.id.item_draweeview_text);
    }
}
</code></pre>
<p>###加载图片和GIF</p>
<pre><code>/**
     * Fresco 加载webp图片
     * @param draweeView
     * @param imageUrl
     */
    public static void loadWebpImage(final Context context, final SimpleDraweeView draweeView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()
                .setUri(Uri.parse(imageUrl))
                .setAutoPlayAnimations(true)
                .setOldController(draweeView.getController())
                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }

                        if(imageData.getScale() == 0){
                            int width = imageInfo.getWidth();
                            int height = imageInfo.getHeight();
                            float scale = (float) width/ (float) height;
                            imageData.setScale(scale);
                        }
                        final ViewGroup.LayoutParams layoutParams = draweeView.getLayoutParams();
                        layoutParams.width = DisplayUtils.getScreenWidth((Activity) context) / 2 - DisplayUtils.dp2px(context,10);
                        layoutParams.height = (int) (layoutParams.width/ imageData.getScale());

                        imageData.setWidth(layoutParams.width);
                        imageData.setHeight(layoutParams.height);

                        imageData.setPosition(position);

                        draweeView.setLayoutParams(layoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        draweeView.setController(controller);

    }

    /**
     * Fresco 加载webpGID
     * @param imageView
     * @param imageUrl
     */
    public static void loadWebpGif(final Context context, final SimpleDraweeView imageView,final SimpleDraweeView gifView, final ImageData imageData, String imageUrl, final boolean reSize, final int position) {
        DraweeController controller = Fresco.newDraweeControllerBuilder()

                .setUri(Uri.parse(imageUrl))

                .setAutoPlayAnimations(true)

                .setOldController(gifView.getController())

                .setControllerListener(new ControllerListener&lt;ImageInfo&gt;() {
                    @Override
                    public void onSubmit(String id, Object callerContext) {

                    }

                    @Override
                    public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {
                        if (imageInfo == null) {
                            return;
                        }
                        final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
                        final ViewGroup.LayoutParams gifLayoutParams = gifView.getLayoutParams();
                        gifLayoutParams.width = layoutParams.width;
                        gifLayoutParams.height = layoutParams.height;

                        gifView.setLayoutParams(gifLayoutParams);

                    }

                    @Override
                    public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {

                    }

                    @Override
                    public void onIntermediateImageFailed(String id, Throwable throwable) {

                    }

                    @Override
                    public void onFailure(String id, Throwable throwable) {

                    }

                    @Override
                    public void onRelease(String id) {

                    }
                })
                .build();

        gifView.setController(controller);
    }
</code></pre>
<p>###效果如下：</p>
<!--todo-->
<p>###缺点与不足<br>
Demo里面还有很多的异常边界情况没有考虑，比如各类的容错判断，性能问题监控，等等</p>
<p>传送门：<a href="https://github.com/Mozziehh/GifView">github.com/mozzie</a></p>
<p>##参考文章</p>
<ol>
<li>
<p>https://www.jianshu.com/p/057f48df855b</p>
</li>
<li>
<p>https://github.com/koral--/android-gif-drawable</p>
</li>
<li>
<p>https://www.dev2qa.com/how-to-play-gif-file-use-android-graphics-movie-class/</p>
</li>
<li>
<p>https://blog.csdn.net/feather_wch/article/details/79558240</p>
</li>
</ol>
]]></content>
    </entry>
</feed>